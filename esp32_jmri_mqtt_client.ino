/*
 * ESP32 JMRI MQTT Client
 * 
 * This project provides an ESP32-based MQTT client for interfacing with JMRI
 * for model railroad control. Features include:
 * - Sensor feedback detection
 * - Turnout control
 * - Signal control
 * - OTA updates
 * - WiFi configuration via web interface
 * - MQTT communication with JMRI
 * 
 * Author: Generated by AI Assistant
 * Date: 2024
 */

#include "config.h"
#include <WiFi.h>
#include <PubSubClient.h>
#include <ArduinoJson.h>
#include <WebServer.h>
#include <Update.h>
#include <SPIFFS.h>
#include <Preferences.h>
#include <ArduinoOTA.h>

// WiFi configuration
const char* default_ssid = DEFAULT_SSID;
const char* default_password = DEFAULT_PASSWORD;
String wifi_ssid = "";
String wifi_password = "";

// MQTT topics - Updated to match JMRI format
String mqtt_base_topic = String(MQTT_TOPIC_PREFIX) + "/";
String mqtt_sensor_topic = mqtt_base_topic + "sensor/";
String mqtt_turnout_topic = mqtt_base_topic + "turnout/";
String mqtt_signal_topic = mqtt_base_topic + "signal/";
String mqtt_light_topic = mqtt_base_topic + "light/";
String mqtt_status_topic = mqtt_base_topic + "status/";

// Global objects
WiFiClient espClient;
PubSubClient mqtt_client(espClient);
WebServer web_server(80);
Preferences preferences;

// MQTT broker info storage
String mqtt_broker_ip = "";
int mqtt_broker_port = 0;
String mqtt_channel_name = "";

// State variables
bool wifi_configured = false;
bool mqtt_connected = false;
unsigned long last_mqtt_attempt = 0;
// Removed periodic status publishing - only publish on state changes

// Sensor states
bool sensor_states[4] = {false, false, false, false};
bool last_sensor_states[4] = {false, false, false, false};

// Turnout states
bool turnout_states[2] = {false, false};

// Signal states
int signal_state = 0; // 0=red, 1=yellow, 2=green

void displaySystemInfo() {
  Serial.println("=== System Information ===");
  Serial.println("Device: " + String(DEVICE_NAME));
  Serial.println("Firmware Version: " + String(FIRMWARE_VERSION));
  Serial.println("Free Sketch Space: " + String(ESP.getFreeSketchSpace()) + " bytes");
  Serial.println("Free Heap: " + String(ESP.getFreeHeap()) + " bytes");
  Serial.println("Flash Chip Size: " + String(ESP.getFlashChipSize()) + " bytes");
  Serial.println("Max OTA Size: " + String(ESP.getFreeSketchSpace() - 0x1000) + " bytes");
  Serial.println("SDK Version: " + String(ESP.getSdkVersion()));
  Serial.println("CPU Frequency: " + String(ESP.getCpuFreqMHz()) + " MHz");
  Serial.println("===============================");
}

void setup() {
  Serial.begin(SERIAL_BAUD_RATE);
  Serial.println("\n\n=== ESP32 JMRI MQTT Client ===");
  Serial.println("Firmware Version: " + String(FIRMWARE_VERSION));
  
  // Display system information
  displaySystemInfo();
  
  // Initialize pins
  initializePins();
  
  // Initialize SPIFFS
  if (!SPIFFS.begin(true)) {
    Serial.println("SPIFFS initialization failed");
  }
  
  // Initialize preferences
  preferences.begin("jmri_client", false);
  
  // Load saved WiFi credentials
  loadWiFiCredentials();
  
  // Load saved MQTT credentials
  loadMQTTCredentials();
  
  // Setup WiFi
  setupWiFi();
  
  // Wait for WiFi to stabilize
  if (WiFi.status() == WL_CONNECTED) {
    delay(2000);  // Give WiFi time to stabilize
    Serial.println("WiFi connected, attempting MQTT connection...");
    
    // Now setup MQTT with the loaded credentials
  setupMQTT();
    
    // Test broker connectivity before attempting connection
    testMQTTBrokerConnectivity();
    
    // Attempt initial MQTT connection
    Serial.println("Attempting initial MQTT connection...");
    mqttReconnect();
  } else {
    // If WiFi didn't connect, still setup MQTT for when it does connect
    setupMQTT();
  }
  
  // Setup web server for configuration
  setupWebServer();
  
  // Setup OTA
  setupOTA();
  
  Serial.println("Setup complete!");
}

void loop() {
  // Feed the watchdog to prevent resets
  yield();
  
  // Handle WiFi
  if (WiFi.status() != WL_CONNECTED) {
    handleWiFiReconnection();
  }
  
  // Handle MQTT
  if (WiFi.status() == WL_CONNECTED) {
    handleMQTT();
  }
  
  // Handle sensors
  handleSensors();
  
  // Handle web server
  web_server.handleClient();
  
  // Handle OTA
  ArduinoOTA.handle();
  
  // Only publish device status when states actually change
  // Removed periodic status publishing - JMRI only needs state change notifications
  
  // Connection status (keep minimal logging)
  static unsigned long last_connection_log = 0;
  if (millis() - last_connection_log > 60000) { // Log every minute
    if (WiFi.status() == WL_CONNECTED) {
      Serial.println("SSID: " + WiFi.SSID());
      Serial.println("IP: " + WiFi.localIP().toString());
      Serial.println("RSSI: " + String(WiFi.RSSI()) + " dBm");
    }
    Serial.println("MQTT Status: " + String(mqtt_connected ? "Connected" : "Disconnected"));
    if (mqtt_connected) {
      Serial.println("Broker: " + mqtt_broker_ip + ":" + String(mqtt_broker_port));
    }
    last_connection_log = millis();
  }
  
  delay(10);
}

void initializePins() {
  // Sensor pins (input with pull-up)
  pinMode(SENSOR_PIN_1, INPUT_PULLUP);
  pinMode(SENSOR_PIN_2, INPUT_PULLUP);
  pinMode(SENSOR_PIN_3, INPUT_PULLUP);
  pinMode(SENSOR_PIN_4, INPUT_PULLUP);
  
  // Turnout pins (output)
  pinMode(TURNOUT_PIN_1, OUTPUT);
  pinMode(TURNOUT_PIN_2, OUTPUT);
  digitalWrite(TURNOUT_PIN_1, LOW);
  digitalWrite(TURNOUT_PIN_2, LOW);
  
  // Signal pins (output)
  pinMode(SIGNAL_PIN_RED, OUTPUT);
  pinMode(SIGNAL_PIN_YELLOW, OUTPUT);
  pinMode(SIGNAL_PIN_GREEN, OUTPUT);
  digitalWrite(SIGNAL_PIN_RED, HIGH);   // Start with red
  digitalWrite(SIGNAL_PIN_YELLOW, LOW);
  digitalWrite(SIGNAL_PIN_GREEN, LOW);
  
  // Status LED
  pinMode(STATUS_LED, OUTPUT);
  digitalWrite(STATUS_LED, LOW);
}

void loadWiFiCredentials() {
  wifi_ssid = preferences.getString("wifi_ssid", "");
  wifi_password = preferences.getString("wifi_password", "");
  wifi_configured = (wifi_ssid.length() > 0);
  
  if (wifi_configured) {
    Serial.println("Loaded saved WiFi credentials for: " + wifi_ssid);
  } else {
    Serial.println("No saved WiFi credentials found");
  }
}

void loadMQTTCredentials() {
  Serial.println("=== Loading MQTT Credentials ===");
  
  // Load MQTT settings from preferences if they exist
  String broker = preferences.getString("mqtt_broker", "");
  int port = preferences.getInt("mqtt_port", 0);
  String client_id = preferences.getString("mqtt_client_id", "");
  String channel_name = preferences.getString("mqtt_channel_name", "");
  String topic_prefix = preferences.getString("mqtt_topic_prefix", "");
  
  Serial.println("From preferences:");
  Serial.println("  Broker: " + (broker.length() > 0 ? broker : "NOT SET"));
  Serial.println("  Port: " + (port > 0 ? String(port) : "NOT SET"));
  Serial.println("  Client ID: " + (client_id.length() > 0 ? client_id : "NOT SET"));
  Serial.println("  Channel Name: " + (channel_name.length() > 0 ? channel_name : "NOT SET"));
  Serial.println("  Topic Prefix: " + (topic_prefix.length() > 0 ? topic_prefix : "NOT SET"));
  
  if (broker.length() > 0 && port > 0 && client_id.length() > 0 && topic_prefix.length() > 0) {
    Serial.println("‚úÖ Loaded saved MQTT credentials for broker: " + broker + ":" + String(port));
    // Update MQTT client settings
    mqtt_broker_ip = broker;
    mqtt_broker_port = port;
    mqtt_channel_name = channel_name.length() > 0 ? channel_name : String(MQTT_CHANNEL_NAME);
    
    // Update topic strings with channel name prefix
    String channel_prefix = mqtt_channel_name;
    if (!channel_prefix.startsWith("/")) {
      channel_prefix = "/" + channel_prefix;
    }
    mqtt_base_topic = channel_prefix + "/" + String(topic_prefix) + "/";
    mqtt_sensor_topic = mqtt_base_topic + "sensor/";
    mqtt_turnout_topic = mqtt_base_topic + "turnout/";
    mqtt_signal_topic = mqtt_base_topic + "signal/";
    mqtt_light_topic = mqtt_base_topic + "light/";
    mqtt_status_topic = mqtt_base_topic + "status/";
    
    Serial.println("Updated topic strings:");
    Serial.println("  Base: " + mqtt_base_topic);
    Serial.println("  Sensors: " + mqtt_sensor_topic);
    Serial.println("  Turnouts: " + mqtt_turnout_topic);
    Serial.println("  Signals: " + mqtt_signal_topic);
    Serial.println("  Status: " + mqtt_status_topic);
  } else {
    Serial.println("‚ö†Ô∏è No saved MQTT credentials found, will use defaults from config.h");
    Serial.println("Default values from config.h:");
    Serial.println("  Broker: " + String(MQTT_BROKER));
    Serial.println("  Port: " + String(MQTT_PORT));
    Serial.println("  Client ID: " + String(MQTT_CLIENT_ID));
    Serial.println("  Channel Name: " + String(MQTT_CHANNEL_NAME));
    Serial.println("  Topic Prefix: " + String(MQTT_TOPIC_PREFIX));
    
    // Set default channel name
    mqtt_channel_name = String(MQTT_CHANNEL_NAME);
  }
  
  Serial.println("===============================");
}

void setupWiFi() {
  if (wifi_configured) {
    // Try to connect to saved network
    Serial.println("=== WiFi Setup ===");
    Serial.println("Attempting to connect to saved WiFi network: " + wifi_ssid);
    Serial.println("WiFi mode: Station");
    
    WiFi.mode(WIFI_STA);
    WiFi.begin(wifi_ssid.c_str(), wifi_password.c_str());
    
    int attempts = 0;
    while (WiFi.status() != WL_CONNECTED && attempts < WIFI_MAX_ATTEMPTS) {
      delay(500);
      Serial.print(".");
      attempts++;
    }
    
    if (WiFi.status() == WL_CONNECTED) {
      Serial.println("\n‚úÖ WiFi connected successfully!");
      Serial.println("SSID: " + WiFi.SSID());
      Serial.println("IP address: " + WiFi.localIP().toString());
      Serial.println("Gateway: " + WiFi.gatewayIP().toString());
      Serial.println("DNS: " + WiFi.dnsIP().toString());
      Serial.println("RSSI: " + String(WiFi.RSSI()) + " dBm");
      Serial.println("Channel: " + String(WiFi.channel()));
      digitalWrite(STATUS_LED, HIGH);
      Serial.println("=== WiFi Setup Complete ===");
    } else {
      Serial.println("\n‚ùå Failed to connect to saved WiFi");
      Serial.println("WiFi status: " + String(WiFi.status()));
      wifi_configured = false;
    }
  }
  
  if (!wifi_configured) {
    // Start configuration mode
    Serial.println("=== Starting WiFi Configuration Mode ===");
    WiFi.mode(WIFI_AP);
    WiFi.softAP(default_ssid, default_password);
    Serial.println("AP SSID: " + String(default_ssid));
    Serial.println("AP Password: " + String(default_password));
    Serial.println("AP IP address: " + WiFi.softAPIP().toString());
    Serial.println("Connect to '" + String(default_ssid) + "' network with password '" + String(default_password) + "'");
    Serial.println("Then navigate to http://" + WiFi.softAPIP().toString() + " to configure");
    Serial.println("=== WiFi Configuration Mode Active ===");
  }
}

void setupMQTT() {
  Serial.println("=== Setting up MQTT ===");
  
  // Check if we have loaded credentials from preferences
  if (mqtt_broker_ip.length() > 0 && mqtt_broker_port > 0) {
    Serial.println("Using loaded credentials from preferences:");
    Serial.println("  Broker: " + mqtt_broker_ip);
    Serial.println("  Port: " + String(mqtt_broker_port));
    Serial.println("  Client ID: " + String(MQTT_CLIENT_ID));
    Serial.println("  Topic Prefix: " + String(MQTT_TOPIC_PREFIX));
  } else {
    Serial.println("No credentials loaded, using defaults from config.h:");
    Serial.println("  Broker: " + String(MQTT_BROKER));
    Serial.println("  Port: " + String(MQTT_PORT));
    Serial.println("  Client ID: " + String(MQTT_CLIENT_ID));
    Serial.println("  Channel Name: " + String(MQTT_CHANNEL_NAME));
    Serial.println("  Topic Prefix: " + String(MQTT_TOPIC_PREFIX));
    
    // Set default values if none were loaded
    mqtt_broker_ip = String(MQTT_BROKER);
    mqtt_broker_port = MQTT_PORT;
    if (mqtt_channel_name.length() == 0) {
      mqtt_channel_name = String(MQTT_CHANNEL_NAME);
    }
  }
  
  // Update MQTT client settings
  mqtt_client.setServer(mqtt_broker_ip.c_str(), mqtt_broker_port);
  mqtt_client.setCallback(mqttCallback);
  mqtt_client.setKeepAlive(60);
  mqtt_client.setSocketTimeout(30);
  
  // Update topic strings with current values including channel name
  String channel_prefix = mqtt_channel_name;
  if (!channel_prefix.startsWith("/")) {
    channel_prefix = "/" + channel_prefix;
  }
  mqtt_base_topic = channel_prefix + "/" + String(MQTT_TOPIC_PREFIX) + "/";
  mqtt_sensor_topic = mqtt_base_topic + "sensor/";
  mqtt_turnout_topic = mqtt_base_topic + "turnout/";
  mqtt_signal_topic = mqtt_base_topic + "signal/";
  mqtt_light_topic = mqtt_base_topic + "light/";
  mqtt_status_topic = mqtt_base_topic + "status/";
  
  Serial.println("Final MQTT configuration:");
  Serial.println("  Broker: " + mqtt_broker_ip + ":" + String(mqtt_broker_port));
  Serial.println("  Base Topic: " + mqtt_base_topic);
  Serial.println("  Sensor Topic: " + mqtt_sensor_topic);
  Serial.println("  Turnout Topic: " + mqtt_turnout_topic);
  Serial.println("  Signal Topic: " + mqtt_signal_topic);
  Serial.println("  Status Topic: " + mqtt_status_topic);
  Serial.println("===============================");
}

void setupWebServer() {
  // Configuration page
  web_server.on("/", HTTP_GET, handleRoot);
  web_server.on("/configure", HTTP_POST, handleWiFiConfig);
  web_server.on("/configure_mqtt", HTTP_POST, handleMQTTConfig); // New handler for MQTT config
  web_server.on("/status", HTTP_GET, handleStatus);
  web_server.on("/control", HTTP_POST, handleDeviceControl); // Device control endpoint
  web_server.on("/restart", HTTP_POST, handleRestart);
  
  // Test endpoint for debugging
  web_server.on("/test", HTTP_GET, []() {
    web_server.send(200, "text/plain", "Web server is working! Firmware version: " + String(FIRMWARE_VERSION));
  });
  
  // OTA update page
  web_server.on("/update", HTTP_GET, handleUpdatePage);
  web_server.on("/doUpdate", HTTP_POST, handleDoUpdate, handleUpdateBody);
  
  web_server.begin();
  Serial.println("Web server started");
}

void setupOTA() {
  Serial.println("Setting up OTA...");
  
  ArduinoOTA.setHostname(DEVICE_NAME);
  ArduinoOTA.setPassword("admin");
  
  // Set OTA port (default is 3232)
  ArduinoOTA.setPort(3232);
  
  ArduinoOTA.onStart([]() {
    Serial.println("=== OTA Update Started ===");
    Serial.println("Disabling watchdog during update...");
    digitalWrite(STATUS_LED, LOW);
  });
  
  ArduinoOTA.onProgress([](unsigned int progress, unsigned int total) {
    Serial.printf("OTA Progress: %u%%\n", (progress / (total / 100)));
    // Feed watchdog during progress
    yield();
  });
  
  ArduinoOTA.onEnd([]() {
    Serial.println("=== OTA Update Completed ===");
    Serial.println("Update successful, restarting...");
    digitalWrite(STATUS_LED, HIGH);
  });
  
  ArduinoOTA.onError([](ota_error_t error) {
    Serial.printf("=== OTA Error: %u ===\n", error);
    Serial.println("Error details:");
    switch (error) {
      case OTA_AUTH_ERROR:
        Serial.println("Auth Failed");
        break;
      case OTA_BEGIN_ERROR:
        Serial.println("Begin Failed");
        break;
      case OTA_CONNECT_ERROR:
        Serial.println("Connect Failed");
        break;
      case OTA_RECEIVE_ERROR:
        Serial.println("Receive Failed");
        break;
      case OTA_END_ERROR:
        Serial.println("End Failed");
        break;
      default:
        Serial.println("Unknown Error");
        break;
    }
    digitalWrite(STATUS_LED, LOW);
  });
  
  ArduinoOTA.begin();
  Serial.println("OTA ready on port 3232");
  Serial.println("You can also use Arduino IDE or other OTA tools to update");
}

void handleWiFiReconnection() {
  static unsigned long last_reconnect_attempt = 0;
  unsigned long current_time = millis();
  
  if (current_time - last_reconnect_attempt > WIFI_RECONNECT_INTERVAL) { // Try every 30 seconds
    Serial.println("Attempting WiFi reconnection...");
    WiFi.reconnect();
    last_reconnect_attempt = current_time;
  }
}

void handleMQTT() {
  if (!mqtt_client.connected()) {
    if (millis() - last_mqtt_attempt > MQTT_RETRY_INTERVAL) {
      Serial.println("üîç DEBUG: MQTT disconnected, calling mqttReconnect() from handleMQTT()");
      mqttReconnect();
      last_mqtt_attempt = millis();
    }
  } else {
    mqtt_client.loop();
  }
}

void testMQTTBrokerConnectivity() {
  Serial.println("=== Testing MQTT Broker Connectivity ===");
  Serial.println("Broker: " + mqtt_broker_ip + ":" + String(mqtt_broker_port));
  
  // Create a temporary WiFi client to test connectivity
  WiFiClient testClient;
  
  Serial.println("Attempting TCP connection to broker...");
  if (testClient.connect(mqtt_broker_ip.c_str(), mqtt_broker_port)) {
    Serial.println("‚úÖ TCP connection to broker successful");
    Serial.println("Broker is reachable on the network");
    testClient.stop();
  } else {
    Serial.println("‚ùå TCP connection to broker failed");
    Serial.println("Broker may be unreachable or port may be blocked");
    Serial.println("Check:");
    Serial.println("  - Broker IP address is correct");
    Serial.println("  - Broker is running and listening on port " + String(mqtt_broker_port));
    Serial.println("  - Network firewall allows connections to this port");
    Serial.println("  - WiFi network can reach the broker subnet");
  }
  Serial.println("===============================");
}

void mqttReconnect() {
  Serial.println("üîç DEBUG: mqttReconnect() called at " + String(millis()) + " ms");
  Serial.println("=== Attempting MQTT Connection ===");
  Serial.println("Broker: " + mqtt_broker_ip);
  Serial.println("Port: " + String(mqtt_broker_port));
  Serial.println("Client ID: " + String(MQTT_CLIENT_ID));
  Serial.println("WiFi Status: " + String(WiFi.status()));
  Serial.println("WiFi IP: " + WiFi.localIP().toString());
  
  if (mqtt_client.connect(MQTT_CLIENT_ID)) {
    Serial.println("‚úÖ MQTT connected successfully!");
    mqtt_connected = true;
    
    // Subscribe to control topics (not status topics to avoid feedback loops)
    String turnout_topic = mqtt_turnout_topic + "+";
    String signal_topic = mqtt_signal_topic + "+";
    String sensor_topic = mqtt_sensor_topic + "+";
    
    Serial.println("Subscribing to turnout topic: " + turnout_topic);
    mqtt_client.subscribe(turnout_topic.c_str());
    
    Serial.println("Subscribing to signal topic: " + signal_topic);
    mqtt_client.subscribe(signal_topic.c_str());
    
    Serial.println("Subscribing to sensor topic: " + sensor_topic);
    mqtt_client.subscribe(sensor_topic.c_str());
    
    Serial.println("Subscriptions completed");
    
    // Request retained messages for initial state sync
    Serial.println("Requesting retained messages for state synchronization...");
    delay(1000); // Give broker time to send retained messages
    
    // Process retained messages multiple times to ensure we get them all
    for (int i = 0; i < 10; i++) {
      mqtt_client.loop();
      delay(100);
    }
    
    Serial.println("=== Current States After MQTT Sync ===");
    Serial.println("Turnout 1: " + String(turnout_states[0] ? "THROWN" : "CLOSED"));
    Serial.println("Turnout 2: " + String(turnout_states[1] ? "THROWN" : "CLOSED"));
    Serial.println("Signal: " + String((signal_state == 0) ? "RED" : (signal_state == 1) ? "YELLOW" : "GREEN"));
    Serial.println("=====================================");
    
    // Skip initial status publish - we now sync from retained messages
    // The ESP32 state is now controlled by JMRI via retained messages
    Serial.println("Skipping initial status publish - using retained message states");
    
    Serial.println("=== MQTT Setup Complete ===");
  } else {
    Serial.printf("‚ùå MQTT connection failed, rc=%d\n", mqtt_client.state());
    Serial.println("Error codes:");
    Serial.println("  -4: MQTT_CONNECTION_TIMEOUT");
    Serial.println("  -3: MQTT_CONNECTION_LOST");
    Serial.println("  -2: MQTT_CONNECT_FAILED");
    Serial.println("  -1: MQTT_DISCONNECTED");
    Serial.println("   0: MQTT_CONNECTED");
    Serial.println("   1: MQTT_CONNECT_BAD_PROTOCOL");
    Serial.println("   2: MQTT_CONNECT_BAD_CLIENT_ID");
    Serial.println("   3: MQTT_CONNECT_UNAVAILABLE");
    Serial.println("   4: MQTT_CONNECT_BAD_CREDENTIALS");
    Serial.println("   5: MQTT_CONNECT_UNAUTHORIZED");
    mqtt_connected = false;
  }
}

// Track our own recent publications to prevent feedback loops
struct RecentPublication {
  String topic;
  String payload;
  unsigned long timestamp;
};

RecentPublication recent_pubs[10];  // Track last 10 publications
int recent_pub_index = 0;

void trackPublication(String topic, String payload) {
  recent_pubs[recent_pub_index].topic = topic;
  recent_pubs[recent_pub_index].payload = payload;
  recent_pubs[recent_pub_index].timestamp = millis();
  recent_pub_index = (recent_pub_index + 1) % 10;
}

bool isOurOwnMessage(String topic, String payload) {
  unsigned long now = millis();
  for (int i = 0; i < 10; i++) {
    if (recent_pubs[i].topic == topic && 
        recent_pubs[i].payload == payload && 
        (now - recent_pubs[i].timestamp) < 2000) {  // Within 2 seconds
      return true;
    }
  }
  return false;
}

void mqttCallback(char* topic, byte* payload, unsigned int length) {
  String topic_str = String(topic);
  String payload_str = "";
  
  for (int i = 0; i < length; i++) {
    payload_str += (char)payload[i];
  }
  
  Serial.println("=== MQTT Message Received ===");
  Serial.println("  Topic: " + topic_str);
  Serial.println("  Payload: " + payload_str);
  Serial.println("  Length: " + String(length) + " bytes");
  Serial.println("  From Broker: " + mqtt_broker_ip + ":" + String(mqtt_broker_port));
  Serial.println("  Timestamp: " + String(millis()) + " ms");
  Serial.println("  Is Retained: " + String(length > 0 ? "Unknown" : "Unknown")); // MQTT lib doesn't expose retain flag
  
  // Check if this is our own message to prevent feedback loops
  // BUT: Always process messages during first 30 seconds (boot sync period)
  bool isBootSync = (millis() < 30000);
  if (!isBootSync && isOurOwnMessage(topic_str, payload_str)) {
    Serial.println("  üîÑ Ignoring our own message to prevent feedback loop");
    Serial.println("================================");
    return;
  }
  
  if (isBootSync) {
    Serial.println("  üöÄ Processing message during boot sync period");
  }
  
  // Ignore $SYS topics
  if (topic_str.startsWith("$SYS")) {
    Serial.println("  ‚ÑπÔ∏è Ignoring $SYS topic");
    Serial.println("================================");
    return;
  }
  
  Serial.println("================================");
  
  // Handle turnout control - JMRI sends simple text commands
  if (topic_str.indexOf("/turnout/") > 0) {
    Serial.println("üéØ Processing turnout control message");
    handleTurnoutControl(topic_str, payload_str);
  }
  
  // Handle signal control - JMRI sends simple text commands
  if (topic_str.indexOf("/signal/") > 0) {
    Serial.println("üéØ Processing signal control message");
    handleSignalControl(topic_str, payload_str);
  }
  
  // Handle sensor truth verification - respond with actual state if different
  if (topic_str.indexOf("/sensor/") > 0) {
    Serial.println("üéØ Processing sensor verification message");
    handleSensorVerification(topic_str, payload_str);
  }
}

void handleTurnoutControl(String topic, String payload) {
  // Extract turnout number from topic (e.g., "track/turnout/1" -> turnout 1)
  int turnout_num = 0;
  
  // Find the last number in the topic
  int lastSlash = topic.lastIndexOf('/');
  if (lastSlash > 0) {
    String turnout_str = topic.substring(lastSlash + 1);
    turnout_num = turnout_str.toInt() - 1;  // Convert to 0-based index
  }
  
  // Validate turnout number
  if (turnout_num < 0 || turnout_num > 1) {
    Serial.println("‚ùå Error: Invalid turnout number: " + String(turnout_num + 1));
    Serial.println("=====================");
    return;
  }
  
  Serial.println("=== Turnout Control ===");
  Serial.println("Turnout: " + String(turnout_num + 1));
  Serial.println("Topic: " + topic);
  Serial.println("Payload: " + payload);
  Serial.println("Current state: " + String(turnout_states[turnout_num] ? "THROWN" : "CLOSED"));
  
  bool state_changed = false;
  
  if (payload == "THROWN") {
    Serial.println("üéØ Requested position: THROWN");
    
    if (turnout_states[turnout_num] != true) {  // Only change if state is different
      state_changed = true;
    
    if (turnout_num == 0) {
        digitalWrite(TURNOUT_PIN_1, HIGH);
        turnout_states[0] = true;
        Serial.println("‚úÖ Turnout 1 pin " + String(TURNOUT_PIN_1) + " set to HIGH");
    } else if (turnout_num == 1) {
        digitalWrite(TURNOUT_PIN_2, HIGH);
        turnout_states[1] = true;
        Serial.println("‚úÖ Turnout 2 pin " + String(TURNOUT_PIN_2) + " set to HIGH");
      }
      
      Serial.println("‚úÖ Turnout " + String(turnout_num + 1) + " moved to THROWN");
    } else {
      Serial.println("‚ÑπÔ∏è Turnout " + String(turnout_num + 1) + " already in THROWN position");
    }
    
  } else if (payload == "CLOSED") {
    Serial.println("üéØ Requested position: CLOSED");
    
    if (turnout_states[turnout_num] != false) {  // Only change if state is different
      state_changed = true;
      
      if (turnout_num == 0) {
        digitalWrite(TURNOUT_PIN_1, LOW);
        turnout_states[0] = false;
        Serial.println("‚úÖ Turnout 1 pin " + String(TURNOUT_PIN_1) + " set to LOW");
      } else if (turnout_num == 1) {
        digitalWrite(TURNOUT_PIN_2, LOW);
        turnout_states[1] = false;
        Serial.println("‚úÖ Turnout 2 pin " + String(TURNOUT_PIN_2) + " set to LOW");
      }
      
      Serial.println("‚úÖ Turnout " + String(turnout_num + 1) + " moved to CLOSED");
    } else {
      Serial.println("‚ÑπÔ∏è Turnout " + String(turnout_num + 1) + " already in CLOSED position");
    }
    
  } else {
    Serial.println("‚ùå Unknown position specified in turnout control message: " + payload);
    Serial.println("=====================");
    return;
  }
  
  // Don't publish when state changes due to MQTT commands
  // JMRI already knows it sent the command, no need to echo back
  if (state_changed) {
    Serial.println("üîÑ State changed due to MQTT command, but not publishing back to JMRI");
    Serial.println("‚ÑπÔ∏è JMRI already knows it sent this command - no echo needed");
  } else {
    Serial.println("‚ÑπÔ∏è No state change, already in requested state");
  }
  
  Serial.println("=====================");
}

void handleSignalControl(String topic, String payload) {
  Serial.println("=== Signal Control ===");
  Serial.println("Topic: " + topic);
  Serial.println("Payload: " + payload);
  
  bool state_changed = false;
  
  if (payload == "RED") {
    Serial.println("Requested aspect: RED");
    Serial.println("Current aspect: " + String(signal_state == 0 ? "RED" : signal_state == 1 ? "YELLOW" : "GREEN"));
    
    if (signal_state != 0) {
      state_changed = true;
      signal_state = 0;
      digitalWrite(SIGNAL_PIN_RED, HIGH);
      digitalWrite(SIGNAL_PIN_YELLOW, LOW);
      digitalWrite(SIGNAL_PIN_GREEN, LOW);
      Serial.println("Signal pin " + String(SIGNAL_PIN_RED) + " set to HIGH (RED)");
      Serial.println("Signal pin " + String(SIGNAL_PIN_YELLOW) + " set to LOW");
      Serial.println("Signal pin " + String(SIGNAL_PIN_GREEN) + " set to LOW");
      Serial.println("‚úÖ Signal changed to RED");
    } else {
      Serial.println("‚ÑπÔ∏è Signal already in RED state");
    }
    
  } else if (payload == "YELLOW") {
    Serial.println("Requested aspect: YELLOW");
    Serial.println("Current aspect: " + String(signal_state == 0 ? "RED" : signal_state == 1 ? "YELLOW" : "GREEN"));
    
    if (signal_state != 1) {
      state_changed = true;
      signal_state = 1;
      digitalWrite(SIGNAL_PIN_RED, LOW);
      digitalWrite(SIGNAL_PIN_YELLOW, HIGH);
      digitalWrite(SIGNAL_PIN_GREEN, LOW);
      Serial.println("Signal pin " + String(SIGNAL_PIN_RED) + " set to LOW");
      Serial.println("Signal pin " + String(SIGNAL_PIN_YELLOW) + " set to HIGH (YELLOW)");
      Serial.println("Signal pin " + String(SIGNAL_PIN_GREEN) + " set to LOW");
      Serial.println("‚úÖ Signal changed to YELLOW");
    } else {
      Serial.println("‚ÑπÔ∏è Signal already in YELLOW state");
    }
    
  } else if (payload == "GREEN") {
    Serial.println("Requested aspect: GREEN");
    Serial.println("Current aspect: " + String(signal_state == 0 ? "RED" : signal_state == 1 ? "YELLOW" : "GREEN"));
    
    if (signal_state != 2) {
      state_changed = true;
      signal_state = 2;
      digitalWrite(SIGNAL_PIN_RED, LOW);
      digitalWrite(SIGNAL_PIN_YELLOW, LOW);
      digitalWrite(SIGNAL_PIN_GREEN, HIGH);
      Serial.println("Signal pin " + String(SIGNAL_PIN_RED) + " set to LOW");
      Serial.println("Signal pin " + String(SIGNAL_PIN_YELLOW) + " set to LOW");
      Serial.println("Signal pin " + String(SIGNAL_PIN_GREEN) + " set to HIGH (GREEN)");
      Serial.println("‚úÖ Signal changed to GREEN");
    } else {
      Serial.println("‚ÑπÔ∏è Signal already in GREEN state");
    }
    
  } else {
    Serial.println("‚ùå Unknown aspect specified in signal control message: " + payload);
    Serial.println("===================");
    return;
  }
  
  // Don't publish when state changes due to MQTT commands
  // JMRI already knows it sent the command, no need to echo back
  if (state_changed) {
    Serial.println("üîÑ State changed due to MQTT command, but not publishing back to JMRI");
    Serial.println("‚ÑπÔ∏è JMRI already knows it sent this command - no echo needed");
  } else {
    Serial.println("‚ÑπÔ∏è No state change, already in requested state");
  }
  
  Serial.println("===================");
}

void handleSensorVerification(String topic, String payload) {
  // Extract sensor number from topic (e.g., "trains/track/sensor/1" -> sensor 1)
  int sensor_num = 0;
  
  // Find the last number in the topic
  int lastSlash = topic.lastIndexOf('/');
  if (lastSlash > 0) {
    String sensor_str = topic.substring(lastSlash + 1);
    sensor_num = sensor_str.toInt();
  }
  
  // Validate sensor number
  if (sensor_num < 1 || sensor_num > 4) {
    Serial.println("‚ùå Error: Invalid sensor number: " + String(sensor_num));
    Serial.println("=====================");
    return;
  }
  
  String actual_state = sensor_states[sensor_num - 1] ? "ACTIVE" : "INACTIVE";
  
  Serial.println("=== Sensor Verification ===");
  Serial.println("Sensor: " + String(sensor_num));
  Serial.println("Topic: " + topic);
  Serial.println("JMRI expects: " + payload);
  Serial.println("Actual physical state: " + actual_state);
  
  // Only publish if JMRI's expectation differs from reality
  if (payload != actual_state) {
    Serial.println("‚ö†Ô∏è MISMATCH: JMRI expects '" + payload + "' but sensor is actually '" + actual_state + "'");
    Serial.println("üì§ Publishing correct sensor state to update JMRI...");
    publishSensorStatus(sensor_num);
  } else {
    Serial.println("‚úÖ JMRI state matches actual sensor state - no publish needed");
  }
  
  Serial.println("============================");
}

void handleSensors() {
  // Read sensor states
  sensor_states[0] = !digitalRead(SENSOR_PIN_1); // Inverted due to pull-up
  sensor_states[1] = !digitalRead(SENSOR_PIN_2);
  sensor_states[2] = !digitalRead(SENSOR_PIN_3);
  sensor_states[3] = !digitalRead(SENSOR_PIN_4);
  
  // Check for changes and publish updates
  for (int i = 0; i < 4; i++) {
    if (sensor_states[i] != last_sensor_states[i]) {
      Serial.println("=== Sensor State Change ===");
      Serial.println("Sensor " + String(i + 1) + " changed from " + 
                    (last_sensor_states[i] ? "ACTIVE" : "INACTIVE") + 
                    " to " + (sensor_states[i] ? "ACTIVE" : "INACTIVE"));
      Serial.println("Pin: " + String(i == 0 ? SENSOR_PIN_1 : i == 1 ? SENSOR_PIN_2 : i == 2 ? SENSOR_PIN_3 : SENSOR_PIN_4));
      Serial.println("==========================");
      
      publishSensorStatus(i + 1);
      last_sensor_states[i] = sensor_states[i];
    }
  }
}

void publishSensorStatus(int sensor_num) {
  if (!mqtt_connected) return;
  
  // Publish to same topic as commands - filtering prevents feedback loops
  String state = sensor_states[sensor_num - 1] ? "ACTIVE" : "INACTIVE";
  String topic = mqtt_sensor_topic + String(sensor_num);
  
  // Track this publication to prevent feedback loops
  trackPublication(topic, state);
  
  mqtt_client.publish(topic.c_str(), state.c_str(), true); // Retained message
  
  Serial.println("Published sensor " + String(sensor_num) + " status: " + state + " to topic: " + topic);
}

void publishTurnoutStatus(int turnout_num) {
  if (!mqtt_connected) return;
  
  // Publish to same topic as commands - filtering prevents feedback loops
  String position = turnout_states[turnout_num - 1] ? "THROWN" : "CLOSED";
  String topic = mqtt_turnout_topic + String(turnout_num);
  
  // Debug: show the source of this publication
  Serial.println("üîç DEBUG: Publishing turnout " + String(turnout_num) + " status");
  Serial.println("   Internal state: " + String(turnout_states[turnout_num - 1] ? "true (THROWN)" : "false (CLOSED)"));
  Serial.println("   Pin state: " + String(digitalRead(turnout_num == 1 ? TURNOUT_PIN_1 : TURNOUT_PIN_2) ? "HIGH (THROWN)" : "LOW (CLOSED)"));
  
  // Track this publication to prevent feedback loops
  trackPublication(topic, position);
  
  mqtt_client.publish(topic.c_str(), position.c_str(), true); // Retained message
  
  Serial.println("Published turnout " + String(turnout_num) + " status: " + position + " to topic: " + topic);
}

void publishSignalStatus() {
  if (!mqtt_connected) return;
  
  // Publish to same topic as commands - filtering prevents feedback loops
  String aspect = (signal_state == 0) ? "RED" : (signal_state == 1) ? "YELLOW" : "GREEN";
  String topic = mqtt_signal_topic + "1";
  
  // Track this publication to prevent feedback loops
  trackPublication(topic, aspect);
  
  mqtt_client.publish(topic.c_str(), aspect.c_str(), true); // Retained message
  
  Serial.println("Published signal status: " + aspect + " to topic: " + topic);
}

void publishInitialStatus() {
  if (!mqtt_connected) return;
  
  Serial.println("=== Publishing Initial Status for All Devices to JMRI ===");
  Serial.println("üîç DEBUG: publishInitialStatus() called");
  
  // Publish individual sensor statuses
  for (int i = 1; i <= 4; i++) {
    publishSensorStatus(i);
    delay(100);  // Small delay between publishes
  }
  
  // Publish individual turnout statuses
  for (int i = 1; i <= 2; i++) {
    Serial.println("üîç DEBUG: publishTurnoutStatus() called from publishInitialStatus()");
    publishTurnoutStatus(i);
    delay(100);  // Small delay between publishes
  }
  
  // Publish signal status
  publishSignalStatus();
  
  Serial.println("=== Initial Device States Published to JMRI ===");
}

// Removed publishAllDeviceStatus() - only publish when states actually change

// Removed publishStatus() and updateStatus() functions
// MQTT status is now only published when device states actually change

// Web server handlers
void handleRoot() {
  String html = "<!DOCTYPE html><html><head>";
  html += "<title>ESP32 JMRI Client</title>";
  html += "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">";
  html += "<style>";
  
  // CSS Variables for theming
  html += ":root{";
  html += "--bg-primary:#ffffff;--bg-secondary:#f8f9fa;--bg-tertiary:#f5f5f5;";
  html += "--text-primary:#333333;--text-secondary:#666666;--text-muted:#999999;";
  html += "--border-color:#dee2e6;--shadow:0 2px 10px rgba(0,0,0,0.1);";
  html += "--accent-primary:#007bff;--accent-hover:#0056b3;";
  html += "--success:#28a745;--danger:#dc3545;--warning:#ffc107;--info:#17a2b8;";
  html += "}";
  
  // Dark mode variables
  html += "[data-theme='dark']{";
  html += "--bg-primary:#1a1a1a;--bg-secondary:#2d2d2d;--bg-tertiary:#333333;";
  html += "--text-primary:#ffffff;--text-secondary:#cccccc;--text-muted:#999999;";
  html += "--border-color:#444444;--shadow:0 2px 10px rgba(0,0,0,0.3);";
  html += "--accent-primary:#0d6efd;--accent-hover:#0b5ed7;";
  html += "}";
  
  // Base styles
  html += "*{box-sizing:border-box;}";
  html += "body{font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;margin:0;padding:0;";
  html += "background-color:var(--bg-tertiary);color:var(--text-primary);transition:all 0.3s ease;}";
  
  // Header styles
  html += ".header{background:var(--bg-primary);border-bottom:2px solid var(--border-color);";
  html += "padding:20px;box-shadow:var(--shadow);}";
  html += ".header-content{max-width:1200px;margin:0 auto;display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;}";
  html += ".device-info h1{margin:0;color:var(--text-primary);font-size:1.8em;}";
  html += ".device-status{text-align:right;font-size:0.9em;color:var(--text-secondary);}";
  html += ".device-status div{margin:2px 0;}";
  html += ".status-badge{display:inline-block;padding:2px 8px;border-radius:12px;font-size:0.8em;margin-left:5px;}";
  html += ".status-connected{background:#d4edda;color:#155724;}";
  html += ".status-disconnected{background:#f8d7da;color:#721c24;}";
  
  // Theme toggle
  html += ".theme-toggle{background:var(--accent-primary);color:white;border:none;padding:8px 16px;";
  html += "border-radius:20px;cursor:pointer;font-size:0.9em;transition:all 0.3s;}";
  html += ".theme-toggle:hover{background:var(--accent-hover);}";
  
  // Container
  html += ".container{max-width:1200px;margin:0 auto;padding:20px;}";
  
  // Tab navigation
  html += ".tab-nav{display:flex;background:var(--bg-primary);border-radius:8px;overflow:hidden;";
  html += "box-shadow:var(--shadow);margin-bottom:20px;}";
  html += ".tab-btn{flex:1;padding:15px 20px;background:var(--bg-secondary);border:none;";
  html += "color:var(--text-secondary);cursor:pointer;font-size:1em;transition:all 0.3s;";
  html += "border-right:1px solid var(--border-color);}";
  html += ".tab-btn:last-child{border-right:none;}";
  html += ".tab-btn.active{background:var(--accent-primary);color:white;}";
  html += ".tab-btn:hover:not(.active){background:var(--bg-tertiary);}";
  
  // Tab content
  html += ".tab-content{display:none;background:var(--bg-primary);padding:20px;";
  html += "border-radius:8px;box-shadow:var(--shadow);}";
  html += ".tab-content.active{display:block;}";
  
  // Sections and forms
  html += ".section{margin:20px 0;}";
  html += ".form-group{margin-bottom:15px;}";
  html += "label{display:block;margin-bottom:5px;font-weight:600;color:var(--text-primary);}";
  html += "input[type=text],input[type=password]{width:100%;padding:10px;";
  html += "border:2px solid var(--border-color);border-radius:6px;background:var(--bg-secondary);";
  html += "color:var(--text-primary);font-size:1em;transition:border-color 0.3s;}";
  html += "input:focus{outline:none;border-color:var(--accent-primary);}";
  html += "button{background:var(--accent-primary);color:white;padding:10px 20px;";
  html += "border:none;border-radius:6px;cursor:pointer;font-size:1em;transition:all 0.3s;}";
  html += "button:hover{background:var(--accent-hover);transform:translateY(-1px);}";
  
  // Device table
  html += ".device-table{width:100%;border-collapse:collapse;margin-top:10px;";
  html += "background:var(--bg-primary);border-radius:8px;overflow:hidden;box-shadow:var(--shadow);}";
  html += ".device-table th,.device-table td{padding:12px;text-align:left;";
  html += "border-bottom:1px solid var(--border-color);}";
  html += ".device-table th{background:var(--bg-secondary);font-weight:600;color:var(--text-primary);}";
  html += ".device-table tr:hover{background:var(--bg-secondary);}";
  html += ".control-btn{padding:6px 12px;margin:2px;border:none;border-radius:4px;";
  html += "cursor:pointer;font-size:0.9em;transition:all 0.3s;}";
  html += ".btn-active{background:#28a745;color:white;font-weight:bold;box-shadow:0 2px 4px rgba(40,167,69,0.3);}";
  html += ".btn-inactive{background:#dc3545;color:white;}";
  html += ".btn-red{background:#dc3545;color:white;opacity:0.5;}";
  html += ".btn-red-active{background:#dc3545;color:white;opacity:1.0;font-weight:bold;}";
  html += ".btn-yellow{background:#ffc107;color:white;opacity:0.5;}";
  html += ".btn-yellow-active{background:#ffc107;color:white;opacity:1.0;font-weight:bold;}";
  html += ".btn-green{background:#28a745;color:white;opacity:0.5;}";
  html += ".btn-green-active{background:#28a745;color:white;opacity:1.0;font-weight:bold;}";
  
  // Status display
  html += ".status-display{background:var(--bg-secondary);border-radius:8px;padding:20px;";
  html += "border:1px solid var(--border-color);}";
  html += ".status-json{font-family:'Courier New',monospace;font-size:0.9em;";
  html += "white-space:pre-wrap;word-wrap:break-word;background:var(--bg-tertiary);";
  html += "padding:15px;border-radius:6px;max-height:400px;overflow-y:auto;";
  html += "border:1px solid var(--border-color);}";
  
  // Utility classes
  html += ".text-center{text-align:center;}";
  html += ".mb-3{margin-bottom:1rem;}";
  html += ".mt-3{margin-top:1rem;}";
  html += "@media (max-width:768px){";
  html += ".header-content{flex-direction:column;text-align:center;}";
  html += ".device-status{text-align:center;margin-top:10px;}";
  html += ".tab-nav{flex-direction:column;}";
  html += "}";
  
  html += "</style>";
  html += "</head><body>";
  
  // Header with device info
  html += "<div class=\"header\">";
  html += "<div class=\"header-content\">";
  html += "<div class=\"device-info\">";
  html += "<h1>ESP32 JMRI Client</h1>";
  html += "<p style=\"margin:5px 0 0 0;color:var(--text-secondary);font-size:0.9em;\">Client ID: " + String(MQTT_CLIENT_ID) + "</p>";
  html += "</div>";
  html += "<div class=\"device-status\">";
  html += "<div>IP: " + WiFi.localIP().toString();
  if (WiFi.status() == WL_CONNECTED) {
    html += "<span class=\"status-badge status-connected\">WiFi Connected</span>";
  } else {
    html += "<span class=\"status-badge status-disconnected\">WiFi Disconnected</span>";
  }
  html += "</div>";
  html += "<div>MQTT: " + mqtt_broker_ip + ":" + String(mqtt_broker_port);
  if (mqtt_client.connected()) {
    html += "<span class=\"status-badge status-connected\">Connected</span>";
  } else {
    html += "<span class=\"status-badge status-disconnected\">Disconnected</span>";
  }
  html += "</div>";
  html += "<button class=\"theme-toggle\" onclick=\"toggleTheme()\">Light Mode</button>";
  html += "</div>";
  html += "</div>";
  
  html += "<div class=\"container\">";
  
  // Tab navigation
  html += "<div class=\"tab-nav\">";
  html += "<button class=\"tab-btn active\" onclick=\"showTab('status')\">Device Status</button>";
  html += "<button class=\"tab-btn\" onclick=\"showTab('setup')\">Setup</button>";
  html += "<button class=\"tab-btn\" onclick=\"showTab('firmware')\">Firmware</button>";
  html += "</div>";
  
  // ===== STATUS TAB =====
  html += "<div id=\"status-tab\" class=\"tab-content active\">";
  
  // Device Status Table (Server-side rendered) - moved to top
  html += "<div class=\"section\">";
  html += "<h2>Device Control Panel</h2>";
  html += "<table class=\"device-table\">";
  html += "<tr><th>Type</th><th>Number</th><th>State</th><th>Control</th></tr>";
  
  // Add sensors (read-only)
  for (int i = 0; i < 4; i++) {
    html += "<tr><td>Sensor</td><td>" + String(i + 1) + "</td>";
    html += "<td>" + String(sensor_states[i] ? "ACTIVE" : "INACTIVE") + "</td>";
    html += "<td><em>Read-only</em></td></tr>";
  }
  
  // Add turnouts (with controls)
  for (int i = 0; i < 2; i++) {
    html += "<tr><td>Turnout</td><td>" + String(i + 1) + "</td>";
    html += "<td>" + String(turnout_states[i] ? "THROWN" : "CLOSED") + "</td>";
    html += "<td>";
    html += "<form style='display:inline;' method='post' action='/control'>";
    html += "<input type='hidden' name='type' value='turnout'>";
    html += "<input type='hidden' name='number' value='" + String(i + 1) + "'>";
    html += "<input type='hidden' name='action' value='THROWN'>";
    html += "<button type='submit' class='control-btn " + String(turnout_states[i] ? "btn-active" : "btn-inactive") + "'>THROWN</button>";
    html += "</form> ";
    html += "<form style='display:inline;' method='post' action='/control'>";
    html += "<input type='hidden' name='type' value='turnout'>";
    html += "<input type='hidden' name='number' value='" + String(i + 1) + "'>";
    html += "<input type='hidden' name='action' value='CLOSED'>";
    html += "<button type='submit' class='control-btn " + String(!turnout_states[i] ? "btn-active" : "btn-inactive") + "'>CLOSED</button>";
    html += "</form>";
    html += "</td></tr>";
  }
  
  // Add signal (with controls)
  String signal_aspect = (signal_state == 0) ? "RED" : (signal_state == 1) ? "YELLOW" : "GREEN";
  html += "<tr><td>Signal</td><td>1</td>";
  html += "<td>" + signal_aspect + "</td>";
  html += "<td>";
  html += "<form style='display:inline;' method='post' action='/control'>";
  html += "<input type='hidden' name='type' value='signal'>";
  html += "<input type='hidden' name='number' value='1'>";
  html += "<input type='hidden' name='action' value='RED'>";
  html += "<button type='submit' class='control-btn " + String(signal_state == 0 ? "btn-red-active" : "btn-red") + "'>RED</button>";
  html += "</form> ";
  html += "<form style='display:inline;' method='post' action='/control'>";
  html += "<input type='hidden' name='type' value='signal'>";
  html += "<input type='hidden' name='number' value='1'>";
  html += "<input type='hidden' name='action' value='YELLOW'>";
  html += "<button type='submit' class='control-btn " + String(signal_state == 1 ? "btn-yellow-active" : "btn-yellow") + "'>YELLOW</button>";
  html += "</form> ";
  html += "<form style='display:inline;' method='post' action='/control'>";
  html += "<input type='hidden' name='type' value='signal'>";
  html += "<input type='hidden' name='number' value='1'>";
  html += "<input type='hidden' name='action' value='GREEN'>";
  html += "<button type='submit' class='control-btn " + String(signal_state == 2 ? "btn-green-active" : "btn-green") + "'>GREEN</button>";
  html += "</form>";
  html += "</td></tr>";
  
  html += "</table>";
  html += "</div>";
  
  // Status Information Section
  html += "<div class=\"section\">";
  html += "<h2>System Status</h2>";
  html += "<div class=\"status-display\">";
  html += "<div id=\"status\"></div>";
  html += "<div class=\"button-group mt-3\">";
  html += "<button onclick=\"checkStatus()\">Refresh Status JSON</button>";
  html += "</div>";
  html += "</div>";
  html += "</div>";
  
  html += "</div>"; // End Status Tab
  
  // ===== SETUP TAB =====
  html += "<div id=\"setup-tab\" class=\"tab-content\">";
  
  // WiFi Configuration Section
  html += "<div class=\"section\">";
  html += "<h2>WiFi Configuration</h2>";
  html += "<form id=\"wifiForm\">";
  html += "<div class=\"form-group\">";
  html += "<label for=\"ssid\">WiFi SSID:</label>";
  html += "<input type=\"text\" id=\"ssid\" name=\"ssid\" value=\"" + wifi_ssid + "\" required>";
  html += "</div>";
  html += "<div class=\"form-group\">";
  html += "<label for=\"password\">WiFi Password:</label>";
  html += "<input type=\"password\" id=\"password\" name=\"password\" value=\"" + wifi_password + "\" required>";
  html += "</div>";
  html += "<button type=\"submit\">Update WiFi</button>";
  html += "</form>";
  html += "</div>";
  
  // MQTT Configuration Section
  html += "<div class=\"section\">";
  html += "<h2>MQTT Configuration</h2>";
  html += "<form id=\"mqttForm\">";
  html += "<div class=\"form-group\">";
  html += "<label for=\"mqtt_broker\">MQTT Broker IP:</label>";
  html += "<input type=\"text\" id=\"mqtt_broker\" name=\"mqtt_broker\" value=\"" + mqtt_broker_ip + "\" required>";
  html += "</div>";
  html += "<div class=\"form-group\">";
  html += "<label for=\"mqtt_port\">MQTT Port:</label>";
  html += "<input type=\"text\" id=\"mqtt_port\" name=\"mqtt_port\" value=\"" + String(mqtt_broker_port) + "\" required>";
  html += "</div>";
  html += "<div class=\"form-group\">";
  html += "<label for=\"mqtt_client_id\">Client ID:</label>";
  html += "<input type=\"text\" id=\"mqtt_client_id\" name=\"mqtt_client_id\" value=\"" + String(MQTT_CLIENT_ID) + "\" required>";
  html += "</div>";
  html += "<div class=\"form-group\">";
  html += "<label for=\"mqtt_channel_name\">Channel Name:</label>";
  html += "<input type=\"text\" id=\"mqtt_channel_name\" name=\"mqtt_channel_name\" value=\"" + mqtt_channel_name + "\" required>";
  html += "</div>";
  html += "<div class=\"form-group\">";
  html += "<label for=\"mqtt_topic_prefix\">Topic Prefix:</label>";
  html += "<input type=\"text\" id=\"mqtt_topic_prefix\" name=\"mqtt_topic_prefix\" value=\"" + String(MQTT_TOPIC_PREFIX) + "\" required>";
  html += "</div>";
  html += "<button type=\"submit\">Update MQTT</button>";
  html += "</form>";
  html += "</div>";
  
  html += "</div>"; // End Setup Tab
  
  // ===== FIRMWARE TAB =====
  html += "<div id=\"firmware-tab\" class=\"tab-content\">";
  
  html += "<div class=\"section\">";
  html += "<h2>Firmware Management</h2>";
  html += "<p style=\"color:var(--text-secondary);margin-bottom:20px;\">Current Version: " + String(FIRMWARE_VERSION) + "</p>";
  
  // Firmware Upload Section
  html += "<div class=\"section\">";
  html += "<h3>Upload New Firmware</h3>";
  html += "<div class=\"upload-form\">";
  html += "<input type=\"file\" id=\"firmware\" accept=\".bin\" onchange=\"validateFile(this)\" style=\"width:100%;padding:10px;margin:10px 0;border:2px dashed var(--border-color);border-radius:4px;background:var(--bg-secondary);color:var(--text-primary);\">";
  html += "<button onclick=\"uploadFirmware()\" id=\"uploadBtn\" disabled style=\"width:100%;margin:10px 0;\">Upload Firmware</button>";
  html += "</div>";
  html += "<div class=\"progress\" style=\"width:100%;background:var(--bg-tertiary);border-radius:4px;margin:10px 0;height:20px;overflow:hidden;\">";
  html += "<div class=\"progress-bar\" id=\"progressBar\" style=\"height:100%;background:var(--accent-primary);border-radius:4px;width:0%;transition:width 0.3s;\"></div>";
  html += "</div>";
  html += "<div id=\"uploadStatus\"></div>";
  html += "</div>";
  
  // Device Control Section
  html += "<div class=\"section\">";
  html += "<h3>Device Control</h3>";
  html += "<div class=\"button-group\">";
  html += "<button onclick=\"restartDevice()\" style=\"background:var(--warning);\">Restart Device</button>";
  html += "</div>";
  html += "</div>";
  
  html += "</div>"; // End Firmware Tab
  
  html += "</div>"; // End Container
  
  html += "<script>";
  
  // Theme toggle function
  html += "function toggleTheme() {";
  html += "    const body = document.body;";
  html += "    const isDark = body.getAttribute('data-theme') === 'dark';";
  html += "    body.setAttribute('data-theme', isDark ? 'light' : 'dark');";
  html += "    const btn = document.querySelector('.theme-toggle');";
  html += "    btn.textContent = isDark ? 'Dark Mode' : 'Light Mode';";
  html += "    localStorage.setItem('theme', isDark ? 'light' : 'dark');";
  html += "}";
  
  // Tab switching function
  html += "function showTab(tabName) {";
  html += "    document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));";
  html += "    document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));";
  html += "    document.getElementById(tabName + '-tab').classList.add('active');";
  html += "    event.target.classList.add('active');";
  html += "}";
  
  // Initialize theme from localStorage (default to dark)
  html += "const savedTheme = localStorage.getItem('theme') || 'dark';";
  html += "document.body.setAttribute('data-theme', savedTheme);";
  html += "document.querySelector('.theme-toggle').textContent = savedTheme === 'dark' ? 'Light Mode' : 'Dark Mode';";
  
  // Form handlers
  html += "document.getElementById('wifiForm').onsubmit = function(e) {";
  html += "    e.preventDefault();";
  html += "    const formData = new FormData();";
  html += "    formData.append('ssid', document.getElementById('ssid').value);";
  html += "    formData.append('password', document.getElementById('password').value);";
  html += "    fetch('/configure', { method: 'POST', body: formData })";
  html += "    .then(response => response.text())";
  html += "    .then(data => {";
  html += "        document.getElementById('status').innerHTML = '<div class=\"status success\">' + data + '</div>';";
  html += "    })";
  html += "    .catch(error => {";
  html += "        document.getElementById('status').innerHTML = '<div class=\"status error\">Error: ' + error + '</div>';";
  html += "    });";
  html += "};";
  
  html += "document.getElementById('mqttForm').onsubmit = function(e) {";
  html += "    e.preventDefault();";
  html += "    const formData = new FormData();";
  html += "    formData.append('mqtt_broker', document.getElementById('mqtt_broker').value);";
  html += "    formData.append('mqtt_port', document.getElementById('mqtt_port').value);";
  html += "    formData.append('mqtt_client_id', document.getElementById('mqtt_client_id').value);";
  html += "    formData.append('mqtt_channel_name', document.getElementById('mqtt_channel_name').value);";
  html += "    formData.append('mqtt_topic_prefix', document.getElementById('mqtt_topic_prefix').value);";
  html += "    fetch('/configure_mqtt', { method: 'POST', body: formData })";
  html += "    .then(response => response.text())";
  html += "    .then(data => {";
  html += "        document.getElementById('status').innerHTML = '<div class=\"status success\">' + data + '</div>';";
  html += "    })";
  html += "    .catch(error => {";
  html += "        document.getElementById('status').innerHTML = '<div class=\"status error\">Error: ' + error + '</div>';";
  html += "    });";
  html += "};";
  
  // Status check function
  html += "function checkStatus() {";
  html += "    fetch('/status')";
  html += "    .then(response => response.json())";
  html += "    .then(data => {";
  html += "        const prettyJson = JSON.stringify(data, null, 2);";
  html += "        document.getElementById('status').innerHTML = '<div class=\"status success\"><h3>Device Status JSON</h3><pre class=\"status-json\">' + prettyJson + '</pre></div>';";
  html += "    })";
  html += "    .catch(error => {";
  html += "        document.getElementById('status').innerHTML = '<div class=\"status error\">Error: ' + error + '</div>';";
  html += "    });";
  html += "}";
  
  // Auto-refresh functionality
  html += "let lastHash = '';";
  html += "function checkChanges() {";
  html += "    fetch('/status').then(r => r.json()).then(d => {";
  html += "        let h = '';";
  html += "        if(d.sensor_states) d.sensor_states.forEach(s => h += s.state);";
  html += "        if(d.turnout_states) d.turnout_states.forEach(t => h += t.position);";
  html += "        if(d.signal_state) h += d.signal_state.aspect;";
  html += "        if(lastHash && lastHash !== h) location.reload();";
  html += "        lastHash = h;";
  html += "    }).catch(() => {});";
  html += "}";
  html += "setInterval(checkChanges, 3000);";
  html += "setTimeout(checkChanges, 1000);";
  
  // Firmware upload functions
  html += "function validateFile(input) {";
  html += "    const file = input.files[0];";
  html += "    const uploadBtn = document.getElementById('uploadBtn');";
  html += "    const statusDiv = document.getElementById('uploadStatus');";
  html += "    if (file && file.name.endsWith('.bin')) {";
  html += "        uploadBtn.disabled = false;";
  html += "        statusDiv.innerHTML = '<div style=\"color:var(--success);padding:10px;border-radius:4px;background:var(--bg-secondary);\">File selected: ' + file.name + ' (' + (file.size/1024).toFixed(1) + ' KB)</div>';";
  html += "    } else {";
  html += "        uploadBtn.disabled = true;";
  html += "        statusDiv.innerHTML = '<div style=\"color:var(--danger);padding:10px;border-radius:4px;background:var(--bg-secondary);\">Please select a .bin file</div>';";
  html += "    }";
  html += "}";
  
  html += "function uploadFirmware() {";
  html += "    const fileInput = document.getElementById('firmware');";
  html += "    const file = fileInput.files[0];";
  html += "    const uploadBtn = document.getElementById('uploadBtn');";
  html += "    const progressBar = document.getElementById('progressBar');";
  html += "    const statusDiv = document.getElementById('uploadStatus');";
  html += "    if (!file) return;";
  html += "    uploadBtn.disabled = true;";
  html += "    progressBar.style.width = '0%';";
  html += "    statusDiv.innerHTML = '<div style=\"color:var(--info);padding:10px;border-radius:4px;background:var(--bg-secondary);\">Preparing upload...</div>';";
  html += "    const formData = new FormData();";
  html += "    formData.append('firmware', file);";
  html += "    const xhr = new XMLHttpRequest();";
  html += "    xhr.upload.addEventListener('progress', function(e) {";
  html += "        if (e.lengthComputable) {";
  html += "            const percentComplete = (e.loaded / e.total) * 100;";
  html += "            progressBar.style.width = percentComplete + '%';";
  html += "            statusDiv.innerHTML = '<div style=\"color:var(--info);padding:10px;border-radius:4px;background:var(--bg-secondary);\">Uploading: ' + Math.round(percentComplete) + '%</div>';";
  html += "        }";
  html += "    });";
  html += "    xhr.addEventListener('load', function() {";
  html += "        if (xhr.status === 200) {";
  html += "            statusDiv.innerHTML = '<div style=\"color:var(--success);padding:10px;border-radius:4px;background:var(--bg-secondary);\">Upload completed! Device will restart in 5 seconds...</div>';";
  html += "            progressBar.style.width = '100%';";
  html += "            setTimeout(() => location.reload(), 5000);";
  html += "        } else {";
  html += "            statusDiv.innerHTML = '<div style=\"color:var(--danger);padding:10px;border-radius:4px;background:var(--bg-secondary);\">Upload failed: ' + xhr.responseText + '</div>';";
  html += "            uploadBtn.disabled = false;";
  html += "        }";
  html += "    });";
  html += "    xhr.addEventListener('error', function() {";
  html += "        statusDiv.innerHTML = '<div style=\"color:var(--danger);padding:10px;border-radius:4px;background:var(--bg-secondary);\">Upload failed: Network error</div>';";
  html += "        uploadBtn.disabled = false;";
  html += "    });";
  html += "    xhr.open('POST', '/doUpdate');";
  html += "    xhr.send(formData);";
  html += "}";
  
  html += "function restartDevice() {";
  html += "    if (confirm('Are you sure you want to restart the device?')) {";
  html += "        fetch('/restart', { method: 'POST' })";
  html += "        .then(() => {";
  html += "            alert('Device is restarting... Please wait a moment and refresh the page.');";
  html += "            setTimeout(() => location.reload(), 10000);";
  html += "        })";
  html += "        .catch(error => alert('Restart request failed: ' + error));";
  html += "    }";
  html += "}";
  
  html += "</script>";
  html += "</body></html>";
  
  web_server.send(200, "text/html", html);
}

void handleWiFiConfig() {
  if (web_server.hasArg("ssid") && web_server.hasArg("password")) {
    String new_ssid = web_server.arg("ssid");
    String new_password = web_server.arg("password");
    
    // Save to preferences
    preferences.putString("wifi_ssid", new_ssid);
    preferences.putString("wifi_password", new_password);
    
    wifi_ssid = new_ssid;
    wifi_password = new_password;
    wifi_configured = true;
    
    // Restart WiFi connection
    WiFi.disconnect();
    delay(1000);
    WiFi.begin(wifi_ssid.c_str(), wifi_password.c_str());
    
    web_server.send(200, "text/plain", "WiFi configuration saved. Device will connect to the new network.");
  } else {
    web_server.send(400, "text/plain", "Missing SSID or password");
  }
}

void handleMQTTConfig() {
  if (web_server.hasArg("mqtt_broker") && web_server.hasArg("mqtt_port") && web_server.hasArg("mqtt_client_id") && web_server.hasArg("mqtt_channel_name") && web_server.hasArg("mqtt_topic_prefix")) {
    String new_broker = web_server.arg("mqtt_broker");
    int new_port = web_server.arg("mqtt_port").toInt();
    String new_client_id = web_server.arg("mqtt_client_id");
    String new_channel_name = web_server.arg("mqtt_channel_name");
    String new_topic_prefix = web_server.arg("mqtt_topic_prefix");

    Serial.println("=== MQTT Configuration Update ===");
    Serial.println("New Broker: " + new_broker);
    Serial.println("New Port: " + String(new_port));
    Serial.println("New Client ID: " + new_client_id);
    Serial.println("New Channel Name: " + new_channel_name);
    Serial.println("New Topic Prefix: " + new_topic_prefix);

    // Save to preferences
    preferences.putString("mqtt_broker", new_broker);
    preferences.putInt("mqtt_port", new_port);
    preferences.putString("mqtt_client_id", new_client_id);
    preferences.putString("mqtt_channel_name", new_channel_name);
    preferences.putString("mqtt_topic_prefix", new_topic_prefix);

    // Update MQTT client settings
    mqtt_client.setServer(new_broker.c_str(), new_port);
    
    // Update our stored broker info
    mqtt_broker_ip = new_broker;
    mqtt_broker_port = new_port;
    mqtt_channel_name = new_channel_name;
    
    // Update topic strings with channel name prefix
    String channel_prefix = mqtt_channel_name;
    if (!channel_prefix.startsWith("/")) {
      channel_prefix = "/" + channel_prefix;
    }
    mqtt_base_topic = channel_prefix + "/" + String(new_topic_prefix) + "/";
    mqtt_sensor_topic = mqtt_base_topic + "sensor/";
    mqtt_turnout_topic = mqtt_base_topic + "turnout/";
    mqtt_signal_topic = mqtt_base_topic + "signal/";
    mqtt_light_topic = mqtt_base_topic + "light/";
    mqtt_status_topic = mqtt_base_topic + "status/";

    Serial.println("Updated topic strings:");
    Serial.println("  Base: " + mqtt_base_topic);
    Serial.println("  Sensors: " + mqtt_sensor_topic);
    Serial.println("  Turnouts: " + mqtt_turnout_topic);
    Serial.println("  Signals: " + mqtt_signal_topic);
    Serial.println("  Status: " + mqtt_status_topic);

    // Disconnect current MQTT connection
    Serial.println("Disconnecting current MQTT connection...");
    mqtt_client.disconnect();
    mqtt_connected = false;
    delay(1000);
    
    // Try to reconnect with new settings
    Serial.println("Attempting to reconnect with new MQTT settings...");
    if (mqtt_client.connect(new_client_id.c_str())) {
      Serial.println("‚úÖ MQTT reconnected with new configuration successfully!");
      mqtt_connected = true;
      
      // Resubscribe to control topics
      String turnout_topic = mqtt_turnout_topic + "+";
      String signal_topic = mqtt_signal_topic + "+";
      String sensor_topic = mqtt_sensor_topic + "+";
      
      Serial.println("Resubscribing to turnout topic: " + turnout_topic);
      mqtt_client.subscribe(turnout_topic.c_str());
      
      Serial.println("Resubscribing to signal topic: " + signal_topic);
      mqtt_client.subscribe(signal_topic.c_str());
      
      Serial.println("Resubscribing to sensor topic: " + sensor_topic);
      mqtt_client.subscribe(sensor_topic.c_str());
      
      // Skip republishing status on config changes - JMRI already knows current states
      Serial.println("Skipping status republish (no state changes)");
      
      Serial.println("=== MQTT Reconfiguration Complete ===");
    } else {
      Serial.println("‚ùå Failed to reconnect to MQTT with new configuration");
      Serial.printf("Error code: %d\n", mqtt_client.state());
      mqtt_connected = false;
    }

    web_server.send(200, "text/plain", "MQTT configuration saved. Device will reconnect to MQTT broker.");
  } else {
    web_server.send(400, "text/plain", "Missing MQTT configuration parameters (broker, port, client_id, channel_name, or topic_prefix)");
  }
}

void handleStatus() {
  DynamicJsonDocument doc(512);
  doc["device"] = DEVICE_NAME;
  doc["version"] = FIRMWARE_VERSION;
  doc["wifi_connected"] = (WiFi.status() == WL_CONNECTED);
  doc["wifi_ssid"] = wifi_ssid;
  doc["ip_address"] = WiFi.localIP().toString();
  doc["mqtt_connected"] = mqtt_connected;
  
  // Add MQTT configuration info
  doc["mqtt_broker"] = preferences.getString("mqtt_broker", MQTT_BROKER);
  doc["mqtt_port"] = preferences.getInt("mqtt_port", MQTT_PORT);
  doc["mqtt_client_id"] = preferences.getString("mqtt_client_id", MQTT_CLIENT_ID);
  doc["mqtt_channel_name"] = preferences.getString("mqtt_channel_name", MQTT_CHANNEL_NAME);
  doc["mqtt_topic_prefix"] = preferences.getString("mqtt_topic_prefix", MQTT_TOPIC_PREFIX);
  
  doc["uptime"] = millis();
  
  // Add current device states
  JsonArray sensor_states_array = doc.createNestedArray("sensor_states");
  for (int i = 0; i < 4; i++) {
    JsonObject sensor = sensor_states_array.createNestedObject();
    sensor["number"] = i + 1;
    sensor["state"] = sensor_states[i] ? "ACTIVE" : "INACTIVE";
  }
  
  JsonArray turnout_states_array = doc.createNestedArray("turnout_states");
  for (int i = 0; i < 2; i++) {
    JsonObject turnout = turnout_states_array.createNestedObject();
    turnout["number"] = i + 1;
    turnout["position"] = turnout_states[i] ? "THROWN" : "CLOSED";
  }
  
  JsonObject signal = doc.createNestedObject("signal_state");
  signal["number"] = 1;
  signal["aspect"] = (signal_state == 0) ? "RED" : (signal_state == 1) ? "YELLOW" : "GREEN";
  
  String json_string;
  serializeJsonPretty(doc, json_string);  // Use pretty formatting
  
  web_server.send(200, "application/json", json_string);
}

void handleDeviceControl() {
  // Check for required parameters
  if (!web_server.hasArg("type") || !web_server.hasArg("number") || !web_server.hasArg("action")) {
    web_server.send(400, "text/plain", "Missing required parameters");
    return;
  }

  String type = web_server.arg("type");
  int number = web_server.arg("number").toInt();
  String action = web_server.arg("action");

  if (type == "turnout") {
    if (number >= 1 && number <= 2) {
      bool new_state = (action == "THROWN");
      if (number == 1) {
        digitalWrite(TURNOUT_PIN_1, new_state ? HIGH : LOW);
        turnout_states[0] = new_state;
      } else {
        digitalWrite(TURNOUT_PIN_2, new_state ? HIGH : LOW);
        turnout_states[1] = new_state;
      }
      publishTurnoutStatus(number);
    }
  } else if (type == "signal" && number == 1) {
    int new_state = (action == "RED") ? 0 : (action == "YELLOW") ? 1 : 2;
    signal_state = new_state;
    digitalWrite(SIGNAL_PIN_RED, (new_state == 0) ? HIGH : LOW);
    digitalWrite(SIGNAL_PIN_YELLOW, (new_state == 1) ? HIGH : LOW);
    digitalWrite(SIGNAL_PIN_GREEN, (new_state == 2) ? HIGH : LOW);
    publishSignalStatus();
  }
  
  // Redirect back to main page
  web_server.sendHeader("Location", "/");
  web_server.send(302, "text/plain", "Redirecting...");
}

void handleRestart() {
  web_server.send(200, "text/plain", "Device restarting...");
  delay(1000);
  ESP.restart();
}

void handleUpdatePage() {
  String html = "<!DOCTYPE html><html><head>";
  html += "<title>Firmware Update</title>";
  html += "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">";
  html += "<style>";
  html += "body{font-family:Arial,sans-serif;margin:20px;background-color:#f5f5f5;}";
  html += ".container{max-width:600px;margin:0 auto;background:white;padding:20px;border-radius:8px;box-shadow:0 2px 10px rgba(0,0,0,0.1);}";
  html += "h1{color:#333;text-align:center;}";
  html += ".upload-form{margin:20px 0;}";
  html += "input[type=file]{width:100%;padding:10px;margin:10px 0;border:2px dashed #ddd;border-radius:4px;}";
  html += "button{background-color:#4CAF50;color:white;padding:12px 24px;border:none;border-radius:4px;cursor:pointer;font-size:16px;width:100%;margin:10px 0;}";
  html += "button:hover{background-color:#45a049;}";
  html += "button:disabled{background-color:#cccccc;cursor:not-allowed;}";
  html += ".progress{width:100%;background-color:#f0f0f0;border-radius:4px;margin:10px 0;}";
  html += ".progress-bar{height:20px;background-color:#4CAF50;border-radius:4px;width:0%;transition:width 0.3s;}";
  html += ".status{text-align:center;margin:10px 0;padding:10px;border-radius:4px;}";
  html += ".success{background-color:#d4edda;color:#155724;border:1px solid #c3e6cb;}";
  html += ".error{background-color:#f8d7da;color:#721c24;border:1px solid #f5c6cb;}";
  html += ".info{background-color:#d1ecf1;color:#0c5460;border:1px solid #bee5eb;}";
  html += "</style>";
  html += "</head><body>";
  html += "<div class=\"container\">";
  html += "<h1>Firmware Update</h1>";
  html += "<div class=\"upload-form\">";
  html += "<input type=\"file\" id=\"firmware\" accept=\".bin\" onchange=\"validateFile(this)\">";
  html += "<button onclick=\"uploadFirmware()\" id=\"uploadBtn\" disabled>Upload Firmware</button>";
  html += "</div>";
  html += "<div class=\"progress\">";
  html += "<div class=\"progress-bar\" id=\"progressBar\"></div>";
  html += "</div>";
  html += "<div id=\"status\"></div>";
  html += "<div style=\"text-align:center;margin-top:20px;\">";
  html += "<a href=\"/\" style=\"color:#4CAF50;text-decoration:none;\">‚Üê Back to Main</a>";
  html += "</div>";
  html += "</div>";
  html += "<script>";
  html += "function validateFile(input) {";
  html += "    const file = input.files[0];";
  html += "    const uploadBtn = document.getElementById('uploadBtn');";
  html += "    if (file && file.name.endsWith('.bin')) {";
  html += "        uploadBtn.disabled = false;";
  html += "        document.getElementById('status').innerHTML = '<div class=\"status info\">File selected: ' + file.name + ' (' + (file.size / 1024).toFixed(1) + ' KB)</div>';";
  html += "    } else {";
  html += "        uploadBtn.disabled = true;";
  html += "        document.getElementById('status').innerHTML = '<div class=\"status error\">Please select a valid .bin file</div>';";
  html += "    }";
  html += "}";
  html += "function uploadFirmware() {";
  html += "    const fileInput = document.getElementById('firmware');";
  html += "    const file = fileInput.files[0];";
  html += "    if (!file) return;";
  html += "    ";
  html += "    const uploadBtn = document.getElementById('uploadBtn');";
  html += "    const statusDiv = document.getElementById('status');";
  html += "    const progressBar = document.getElementById('progressBar');";
  html += "    ";
  html += "    uploadBtn.disabled = true;";
  html += "    statusDiv.innerHTML = '<div class=\"status info\">Starting upload...</div>';";
      html += "    progressBar.style.width = '0%';";
    html += "    ";
    html += "    const formData = new FormData();";
  html += "    formData.append('firmware', file);";
  html += "    ";
  html += "    const xhr = new XMLHttpRequest();";
  html += "    ";
  html += "    xhr.upload.addEventListener('progress', function(e) {";
  html += "        if (e.lengthComputable) {";
  html += "            const percentComplete = (e.loaded / e.total) * 100;";
  html += "            progressBar.style.width = percentComplete + '%';";
  html += "            statusDiv.innerHTML = '<div class=\"status info\">Uploading: ' + Math.round(percentComplete) + '%</div>';";
  html += "        }";
  html += "    });";
  html += "    ";
  html += "    xhr.addEventListener('load', function() {";
  html += "        if (xhr.status === 200) {";
  html += "            statusDiv.innerHTML = '<div class=\"status success\">Upload completed! Device will restart in 5 seconds...</div>';";
  html += "            progressBar.style.width = '100%';";
  html += "            setTimeout(() => {";
  html += "                window.location.href = '/';";
  html += "            }, 5000);";
  html += "        } else {";
  html += "            statusDiv.innerHTML = '<div class=\"status error\">Upload failed: ' + xhr.responseText + '</div>';";
  html += "            uploadBtn.disabled = false;";
  html += "        }";
  html += "    });";
  html += "    ";
  html += "    xhr.addEventListener('error', function() {";
  html += "        statusDiv.innerHTML = '<div class=\"status error\">Upload failed: Network error</div>';";
  html += "        uploadBtn.disabled = false;";
  html += "    });";
  html += "    ";
  html += "    xhr.open('POST', '/do_update');";
  html += "    xhr.send(formData);";
  html += "}";
  html += "</script>";
  html += "</body></html>";
  
  web_server.send(200, "text/html", html);
}

void handleDoUpdate() {
  web_server.sendHeader("Connection", "close");
  
  if (Update.hasError()) {
    String error_msg = "Update failed: " + String(Update.errorString());
    Serial.println(error_msg);
    web_server.send(500, "text/plain", error_msg);
  } else {
    Serial.println("Update successful, restarting device...");
    web_server.send(200, "text/plain", "Update successful! Device will restart in 3 seconds...");
    delay(3000);
    ESP.restart();
  }
}

void handleUpdateBody() {
  HTTPUpload& upload = web_server.upload();
  
  if (upload.status == UPLOAD_FILE_START) {
    Serial.println("=== OTA Update Started ===");
    Serial.println("File name: " + upload.filename);
    
    // Check if we have enough free space
    size_t freeSpace = ESP.getFreeSketchSpace();
    Serial.println("Free sketch space: " + String(freeSpace) + " bytes");
    
    if (freeSpace < 100000) {  // Less than 100KB free
      Serial.println("‚ùå Error: Insufficient free space for update");
      return;
    }
    
    // Start the update process
    if (!Update.begin(freeSpace - 0x1000)) {
      Serial.println("‚ùå Error: Update.begin() failed");
      Serial.println("Update error: " + String(Update.getError()));
      return;
    }
    
    Serial.println("‚úÖ Update started successfully");
    Serial.println("Expected size: " + String(Update.size()) + " bytes");
    
  } else if (upload.status == UPLOAD_FILE_WRITE) {
    if (upload.buf == nullptr) {
      Serial.println("‚ùå Error: Upload buffer is null");
      return;
    }
    
    if (Update.write(upload.buf, upload.currentSize) != upload.currentSize) {
      Serial.println("‚ùå Error: Update.write() failed");
      Serial.println("Update error: " + String(Update.getError()));
      return;
    }
    
    // Calculate progress
    size_t progress = (Update.progress() * 100) / Update.size();
    Serial.println("üì§ Chunk written: " + String(upload.currentSize) + " bytes");
    Serial.println("üìä Progress: " + String(progress) + "%");
    
  } else if (upload.status == UPLOAD_FILE_END) {
    if (Update.end()) {
      Serial.println("‚úÖ Update completed successfully!");
      Serial.println("Final size: " + String(Update.size()) + " bytes");
      
      // Verify the update
  if (Update.hasError()) {
        Serial.println("‚ùå Update verification failed");
        Serial.println("Error: " + String(Update.getError()));
    return;
  }
  
      Serial.println("üîÑ Restarting device in 3 seconds...");
      delay(3000);
      ESP.restart();
      
    } else {
      Serial.println("‚ùå Error: Update.end() failed");
      Serial.println("Update error: " + String(Update.getError()));
    }
  }
}
