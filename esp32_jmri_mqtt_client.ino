/*
 * ESP32 JMRI MQTT Client
 * 
 * This project provides an ESP32-based MQTT client for interfacing with JMRI
 * for model railroad control. Features include:
 * - Sensor feedback detection
 * - Turnout control
 * - Signal control
 * - OTA updates
 * - WiFi configuration via web interface
 * - MQTT communication with JMRI
 * 
 * Author: Generated by AI Assistant
 * Date: 2024
 */

#include "config.h"
#include <WiFi.h>
#include <PubSubClient.h>
#include <ArduinoJson.h>
#include <WebServer.h>
#include <Update.h>
#include <SPIFFS.h>
#include <Preferences.h>
#include <ArduinoOTA.h>

// WiFi configuration
const char* default_ssid = DEFAULT_SSID;
const char* default_password = DEFAULT_PASSWORD;
String wifi_ssid = "";
String wifi_password = "";

// MQTT topics
String mqtt_base_topic = String(MQTT_TOPIC_PREFIX) + "/" + WiFi.macAddress();
String mqtt_sensor_topic = mqtt_base_topic + "/sensors";
String mqtt_turnout_topic = mqtt_base_topic + "/turnouts";
String mqtt_signal_topic = mqtt_base_topic + "/signals";
String mqtt_status_topic = mqtt_base_topic + "/status";

// Global objects
WiFiClient espClient;
PubSubClient mqtt_client(espClient);
WebServer web_server(80);
Preferences preferences;

// MQTT broker info storage
String mqtt_broker_ip = "";
int mqtt_broker_port = 0;

// State variables
bool wifi_configured = false;
bool mqtt_connected = false;
unsigned long last_mqtt_attempt = 0;
unsigned long last_status_update = 0;
unsigned long last_periodic_status = 0;  // For periodic status publishing

// Sensor states
bool sensor_states[4] = {false, false, false, false};
bool last_sensor_states[4] = {false, false, false, false};

// Turnout states
bool turnout_states[2] = {false, false};

// Signal states
int signal_state = 0; // 0=red, 1=yellow, 2=green

void displaySystemInfo() {
  Serial.println("=== System Information ===");
  Serial.println("Device: " + String(DEVICE_NAME));
  Serial.println("Firmware Version: " + String(FIRMWARE_VERSION));
  Serial.println("Free Sketch Space: " + String(ESP.getFreeSketchSpace()) + " bytes");
  Serial.println("Free Heap: " + String(ESP.getFreeHeap()) + " bytes");
  Serial.println("Flash Chip Size: " + String(ESP.getFlashChipSize()) + " bytes");
  Serial.println("Max OTA Size: " + String(ESP.getFreeSketchSpace() - 0x1000) + " bytes");
  Serial.println("SDK Version: " + String(ESP.getSdkVersion()));
  Serial.println("CPU Frequency: " + String(ESP.getCpuFreqMHz()) + " MHz");
  Serial.println("===============================");
}

void setup() {
  Serial.begin(SERIAL_BAUD_RATE);
  Serial.println("\n\n=== ESP32 JMRI MQTT Client ===");
  Serial.println("Firmware Version: " + String(FIRMWARE_VERSION));
  
  // Display system information
  displaySystemInfo();
  
  // Initialize pins
  initializePins();
  
  // Initialize SPIFFS
  if (!SPIFFS.begin(true)) {
    Serial.println("SPIFFS initialization failed");
  }
  
  // Initialize preferences
  preferences.begin("jmri_client", false);
  
  // Load saved WiFi credentials
  loadWiFiCredentials();
  
  // Load saved MQTT credentials
  loadMQTTCredentials();
  
  // Setup WiFi
  setupWiFi();
  
  // Wait for WiFi to stabilize
  if (WiFi.status() == WL_CONNECTED) {
    delay(2000);  // Give WiFi time to stabilize
    Serial.println("WiFi connected, attempting MQTT connection...");
  }
  
  // Setup MQTT
  setupMQTT();
  
  // Attempt initial MQTT connection if WiFi is available
  if (WiFi.status() == WL_CONNECTED) {
    mqttReconnect();
  }
  
  // Setup web server for configuration
  setupWebServer();
  
  // Setup OTA
  setupOTA();
  
  Serial.println("Setup complete!");
}

void loop() {
  // Feed the watchdog to prevent resets
  yield();
  
  // Handle WiFi
  if (WiFi.status() != WL_CONNECTED) {
    handleWiFiReconnection();
  }
  
  // Handle MQTT
  if (WiFi.status() == WL_CONNECTED) {
    handleMQTT();
  }
  
  // Handle sensors
  handleSensors();
  
  // Handle web server
  web_server.handleClient();
  
  // Handle OTA
  ArduinoOTA.handle();
  
  // Update status
  if (millis() - last_status_update > STATUS_UPDATE_INTERVAL) {
    updateStatus();
    last_status_update = millis();
  }
  
  // Periodic status publishing for all devices
  if (millis() - last_periodic_status > PERIODIC_STATUS_INTERVAL) {
    publishAllDeviceStatus();
    last_periodic_status = millis();
    
    // Also report connection status
    Serial.println("=== Connection Status Report ===");
    Serial.println("WiFi Status: " + String(WiFi.status() == WL_CONNECTED ? "Connected" : "Disconnected"));
    if (WiFi.status() == WL_CONNECTED) {
      Serial.println("SSID: " + WiFi.SSID());
      Serial.println("IP: " + WiFi.localIP().toString());
      Serial.println("RSSI: " + String(WiFi.RSSI()) + " dBm");
    }
    Serial.println("MQTT Status: " + String(mqtt_connected ? "Connected" : "Disconnected"));
    if (mqtt_connected) {
      Serial.println("Broker: " + mqtt_broker_ip + ":" + String(mqtt_broker_port));
    }
    Serial.println("===============================");
  }
  
  delay(10);
}

void initializePins() {
  // Sensor pins (input with pull-up)
  pinMode(SENSOR_PIN_1, INPUT_PULLUP);
  pinMode(SENSOR_PIN_2, INPUT_PULLUP);
  pinMode(SENSOR_PIN_3, INPUT_PULLUP);
  pinMode(SENSOR_PIN_4, INPUT_PULLUP);
  
  // Turnout pins (output)
  pinMode(TURNOUT_PIN_1, OUTPUT);
  pinMode(TURNOUT_PIN_2, OUTPUT);
  digitalWrite(TURNOUT_PIN_1, LOW);
  digitalWrite(TURNOUT_PIN_2, LOW);
  
  // Signal pins (output)
  pinMode(SIGNAL_PIN_RED, OUTPUT);
  pinMode(SIGNAL_PIN_YELLOW, OUTPUT);
  pinMode(SIGNAL_PIN_GREEN, OUTPUT);
  digitalWrite(SIGNAL_PIN_RED, HIGH);   // Start with red
  digitalWrite(SIGNAL_PIN_YELLOW, LOW);
  digitalWrite(SIGNAL_PIN_GREEN, LOW);
  
  // Status LED
  pinMode(STATUS_LED, OUTPUT);
  digitalWrite(STATUS_LED, LOW);
}

void loadWiFiCredentials() {
  wifi_ssid = preferences.getString("wifi_ssid", "");
  wifi_password = preferences.getString("wifi_password", "");
  wifi_configured = (wifi_ssid.length() > 0);
  
  if (wifi_configured) {
    Serial.println("Loaded saved WiFi credentials for: " + wifi_ssid);
  } else {
    Serial.println("No saved WiFi credentials found");
  }
}

void loadMQTTCredentials() {
  // Load MQTT settings from preferences if they exist
  String broker = preferences.getString("mqtt_broker", "");
  int port = preferences.getInt("mqtt_port", 0);
  String client_id = preferences.getString("mqtt_client_id", "");
  String topic_prefix = preferences.getString("mqtt_topic_prefix", "");
  
  if (broker.length() > 0 && port > 0 && client_id.length() > 0 && topic_prefix.length() > 0) {
    Serial.println("Loaded saved MQTT credentials for broker: " + broker + ":" + String(port));
    // Update MQTT client settings
    mqtt_client.setServer(broker.c_str(), port);
    
    // Update our stored broker info
    mqtt_broker_ip = broker;
    mqtt_broker_port = port;
    
    // Update topic strings
    mqtt_base_topic = String(topic_prefix) + "/" + WiFi.macAddress();
    mqtt_sensor_topic = mqtt_base_topic + "/sensors";
    mqtt_turnout_topic = mqtt_base_topic + "/turnouts";
    mqtt_signal_topic = mqtt_base_topic + "/signals";
    mqtt_status_topic = mqtt_base_topic + "/status";
  } else {
    Serial.println("No saved MQTT credentials found, using defaults from config.h");
  }
}

void setupWiFi() {
  if (wifi_configured) {
    // Try to connect to saved network
    Serial.println("=== WiFi Setup ===");
    Serial.println("Attempting to connect to saved WiFi network: " + wifi_ssid);
    Serial.println("WiFi mode: Station");
    
    WiFi.mode(WIFI_STA);
    WiFi.begin(wifi_ssid.c_str(), wifi_password.c_str());
    
    int attempts = 0;
    while (WiFi.status() != WL_CONNECTED && attempts < WIFI_MAX_ATTEMPTS) {
      delay(500);
      Serial.print(".");
      attempts++;
    }
    
    if (WiFi.status() == WL_CONNECTED) {
      Serial.println("\n‚úÖ WiFi connected successfully!");
      Serial.println("SSID: " + WiFi.SSID());
      Serial.println("IP address: " + WiFi.localIP().toString());
      Serial.println("Gateway: " + WiFi.gatewayIP().toString());
      Serial.println("DNS: " + WiFi.dnsIP().toString());
      Serial.println("RSSI: " + String(WiFi.RSSI()) + " dBm");
      Serial.println("Channel: " + String(WiFi.channel()));
      digitalWrite(STATUS_LED, HIGH);
      Serial.println("=== WiFi Setup Complete ===");
    } else {
      Serial.println("\n‚ùå Failed to connect to saved WiFi");
      Serial.println("WiFi status: " + String(WiFi.status()));
      wifi_configured = false;
    }
  }
  
  if (!wifi_configured) {
    // Start configuration mode
    Serial.println("=== Starting WiFi Configuration Mode ===");
    WiFi.mode(WIFI_AP);
    WiFi.softAP(default_ssid, default_password);
    Serial.println("AP SSID: " + String(default_ssid));
    Serial.println("AP Password: " + String(default_password));
    Serial.println("AP IP address: " + WiFi.softAPIP().toString());
    Serial.println("Connect to '" + String(default_ssid) + "' network with password '" + String(default_password) + "'");
    Serial.println("Then navigate to http://" + WiFi.softAPIP().toString() + " to configure");
    Serial.println("=== WiFi Configuration Mode Active ===");
  }
}

void setupMQTT() {
  // Load MQTT settings from preferences if they exist, otherwise use defaults from config.h
  String broker = preferences.getString("mqtt_broker", MQTT_BROKER);
  int port = preferences.getInt("mqtt_port", MQTT_PORT);
  String client_id = preferences.getString("mqtt_client_id", MQTT_CLIENT_ID);
  String topic_prefix = preferences.getString("mqtt_topic_prefix", MQTT_TOPIC_PREFIX);
  
  // Store broker info for debugging
  mqtt_broker_ip = broker;
  mqtt_broker_port = port;
  
  // Update MQTT client settings
  mqtt_client.setServer(broker.c_str(), port);
  mqtt_client.setCallback(mqttCallback);
  mqtt_client.setKeepAlive(60);
  mqtt_client.setSocketTimeout(30);
  
  // Update topic strings with loaded values
  mqtt_base_topic = String(topic_prefix) + "/" + WiFi.macAddress();
  mqtt_sensor_topic = mqtt_base_topic + "/sensors";
  mqtt_turnout_topic = mqtt_base_topic + "/turnouts";
  mqtt_signal_topic = mqtt_base_topic + "/signals";
  mqtt_status_topic = mqtt_base_topic + "/status";
}

void setupWebServer() {
  // Configuration page
  web_server.on("/", HTTP_GET, handleRoot);
  web_server.on("/configure", HTTP_POST, handleWiFiConfig);
  web_server.on("/configure_mqtt", HTTP_POST, handleMQTTConfig); // New handler for MQTT config
  web_server.on("/status", HTTP_GET, handleStatus);
  web_server.on("/restart", HTTP_POST, handleRestart);
  
  // Test endpoint for debugging
  web_server.on("/test", HTTP_GET, []() {
    web_server.send(200, "text/plain", "Web server is working! Firmware version: " + String(FIRMWARE_VERSION));
  });
  
  // OTA update page
  web_server.on("/update", HTTP_GET, handleUpdatePage);
  web_server.on("/doUpdate", HTTP_POST, handleDoUpdate, handleUpdateBody);
  
  web_server.begin();
  Serial.println("Web server started");
}

void setupOTA() {
  Serial.println("Setting up OTA...");
  
  ArduinoOTA.setHostname(DEVICE_NAME);
  ArduinoOTA.setPassword("admin");
  
  // Set OTA port (default is 3232)
  ArduinoOTA.setPort(3232);
  
  ArduinoOTA.onStart([]() {
    Serial.println("=== OTA Update Started ===");
    Serial.println("Disabling watchdog during update...");
    digitalWrite(STATUS_LED, LOW);
  });
  
  ArduinoOTA.onProgress([](unsigned int progress, unsigned int total) {
    Serial.printf("OTA Progress: %u%%\n", (progress / (total / 100)));
    // Feed watchdog during progress
    yield();
  });
  
  ArduinoOTA.onEnd([]() {
    Serial.println("=== OTA Update Completed ===");
    Serial.println("Update successful, restarting...");
    digitalWrite(STATUS_LED, HIGH);
  });
  
  ArduinoOTA.onError([](ota_error_t error) {
    Serial.printf("=== OTA Error: %u ===\n", error);
    Serial.println("Error details:");
    switch (error) {
      case OTA_AUTH_ERROR:
        Serial.println("Auth Failed");
        break;
      case OTA_BEGIN_ERROR:
        Serial.println("Begin Failed");
        break;
      case OTA_CONNECT_ERROR:
        Serial.println("Connect Failed");
        break;
      case OTA_RECEIVE_ERROR:
        Serial.println("Receive Failed");
        break;
      case OTA_END_ERROR:
        Serial.println("End Failed");
        break;
      default:
        Serial.println("Unknown Error");
        break;
    }
    digitalWrite(STATUS_LED, LOW);
  });
  
  ArduinoOTA.begin();
  Serial.println("OTA ready on port 3232");
  Serial.println("You can also use Arduino IDE or other OTA tools to update");
}

void handleWiFiReconnection() {
  static unsigned long last_reconnect_attempt = 0;
  unsigned long current_time = millis();
  
  if (current_time - last_reconnect_attempt > WIFI_RECONNECT_INTERVAL) { // Try every 30 seconds
    Serial.println("Attempting WiFi reconnection...");
    WiFi.reconnect();
    last_reconnect_attempt = current_time;
  }
}

void handleMQTT() {
  if (!mqtt_client.connected()) {
    if (millis() - last_mqtt_attempt > MQTT_RETRY_INTERVAL) {
      mqttReconnect();
      last_mqtt_attempt = millis();
    }
  } else {
    mqtt_client.loop();
  }
}

void mqttReconnect() {
  Serial.println("=== Attempting MQTT Connection ===");
  Serial.println("Broker: " + mqtt_broker_ip);
  Serial.println("Port: " + String(mqtt_broker_port));
  Serial.println("Client ID: " + String(MQTT_CLIENT_ID));
  Serial.println("WiFi Status: " + String(WiFi.status()));
  Serial.println("WiFi IP: " + WiFi.localIP().toString());
  
  if (mqtt_client.connect(MQTT_CLIENT_ID)) {
    Serial.println("‚úÖ MQTT connected successfully!");
    mqtt_connected = true;
    
    // Subscribe to control topics
    String turnout_topic = mqtt_turnout_topic + "/+/control";
    String signal_topic = mqtt_signal_topic + "/+/control";
    
    Serial.println("Subscribing to turnout topic: " + turnout_topic);
    mqtt_client.subscribe(turnout_topic.c_str());
    
    Serial.println("Subscribing to signal topic: " + signal_topic);
    mqtt_client.subscribe(signal_topic.c_str());
    
    Serial.println("Subscriptions completed");
    
    // Publish initial status
    Serial.println("Publishing initial status...");
    publishInitialStatus();
    
    Serial.println("=== MQTT Setup Complete ===");
  } else {
    Serial.printf("‚ùå MQTT connection failed, rc=%d\n", mqtt_client.state());
    Serial.println("Error codes:");
    Serial.println("  -4: MQTT_CONNECTION_TIMEOUT");
    Serial.println("  -3: MQTT_CONNECTION_LOST");
    Serial.println("  -2: MQTT_CONNECT_FAILED");
    Serial.println("  -1: MQTT_DISCONNECTED");
    Serial.println("   0: MQTT_CONNECTED");
    Serial.println("   1: MQTT_CONNECT_BAD_PROTOCOL");
    Serial.println("   2: MQTT_CONNECT_BAD_CLIENT_ID");
    Serial.println("   3: MQTT_CONNECT_UNAVAILABLE");
    Serial.println("   4: MQTT_CONNECT_BAD_CREDENTIALS");
    Serial.println("   5: MQTT_CONNECT_UNAUTHORIZED");
    mqtt_connected = false;
  }
}

void mqttCallback(char* topic, byte* payload, unsigned int length) {
  String topic_str = String(topic);
  String payload_str = "";
  
  for (int i = 0; i < length; i++) {
    payload_str += (char)payload[i];
  }
  
  Serial.println("=== MQTT Message Received ===");
  Serial.println("  Topic: " + topic_str);
  Serial.println("  Payload: " + payload_str);
  Serial.println("  Length: " + String(length) + " bytes");
  Serial.println("  From Broker: " + mqtt_broker_ip + ":" + String(mqtt_broker_port));
  Serial.println("================================");
  
  // Parse JSON payload
  DynamicJsonDocument doc(256);
  DeserializationError error = deserializeJson(doc, payload_str);
  
  if (error) {
    Serial.println("JSON parsing failed: " + String(error.c_str()));
    return;
  }
  
  Serial.println("JSON parsed successfully");
  
  // Handle turnout control
  if (topic_str.indexOf("/turnouts/") > 0) {
    Serial.println("Processing turnout control message");
    handleTurnoutControl(topic_str, doc);
  }
  
  // Handle signal control
  if (topic_str.indexOf("/signals/") > 0) {
    Serial.println("Processing signal control message");
    handleSignalControl(topic_str, doc);
  }
}

void handleTurnoutControl(String topic, JsonDocument& doc) {
  // Extract turnout number from topic
  int turnout_num = 0;
  if (topic.indexOf("/turnouts/1/") > 0) turnout_num = 0;
  else if (topic.indexOf("/turnouts/2/") > 0) turnout_num = 1;
  
  Serial.println("=== Turnout Control ===");
  Serial.println("Turnout: " + String(turnout_num + 1));
  Serial.println("Topic: " + topic);
  
  if (doc.containsKey("position")) {
    String position = doc["position"].as<String>();
    bool new_state = (position == "thrown" || position == "true");
    
    Serial.println("Requested position: " + position + " (state: " + (new_state ? "thrown" : "normal") + ")");
    Serial.println("Current state: " + String(turnout_states[turnout_num] ? "thrown" : "normal"));
    
    if (turnout_num == 0) {
      digitalWrite(TURNOUT_PIN_1, new_state ? HIGH : LOW);
      turnout_states[0] = new_state;
      Serial.println("Turnout 1 pin " + String(TURNOUT_PIN_1) + " set to " + (new_state ? "HIGH" : "LOW"));
    } else if (turnout_num == 1) {
      digitalWrite(TURNOUT_PIN_2, new_state ? HIGH : LOW);
      turnout_states[1] = new_state;
      Serial.println("Turnout 2 pin " + String(TURNOUT_PIN_2) + " set to " + (new_state ? "HIGH" : "LOW"));
    }
    
    Serial.println("Turnout " + String(turnout_num + 1) + " moved to " + (new_state ? "thrown" : "normal"));
    
    // Publish status update
    publishTurnoutStatus(turnout_num + 1);
  } else {
    Serial.println("‚ùå No position specified in turnout control message");
  }
  Serial.println("=====================");
}

void handleSignalControl(String topic, JsonDocument& doc) {
  Serial.println("=== Signal Control ===");
  Serial.println("Topic: " + topic);
  
  if (doc.containsKey("aspect")) {
    String aspect = doc["aspect"].as<String>();
    int old_state = signal_state;
    
    Serial.println("Requested aspect: " + aspect);
    Serial.println("Current aspect: " + String(old_state == 0 ? "red" : old_state == 1 ? "yellow" : "green"));
    
    if (aspect == "red") {
      signal_state = 0;
      digitalWrite(SIGNAL_PIN_RED, HIGH);
      digitalWrite(SIGNAL_PIN_YELLOW, LOW);
      digitalWrite(SIGNAL_PIN_GREEN, LOW);
      Serial.println("Signal pin " + String(SIGNAL_PIN_RED) + " set to HIGH (RED)");
      Serial.println("Signal pin " + String(SIGNAL_PIN_YELLOW) + " set to LOW");
      Serial.println("Signal pin " + String(SIGNAL_PIN_GREEN) + " set to LOW");
    } else if (aspect == "yellow") {
      signal_state = 1;
      digitalWrite(SIGNAL_PIN_RED, LOW);
      digitalWrite(SIGNAL_PIN_YELLOW, HIGH);
      digitalWrite(SIGNAL_PIN_GREEN, LOW);
      Serial.println("Signal pin " + String(SIGNAL_PIN_RED) + " set to LOW");
      Serial.println("Signal pin " + String(SIGNAL_PIN_YELLOW) + " set to HIGH (YELLOW)");
      Serial.println("Signal pin " + String(SIGNAL_PIN_GREEN) + " set to LOW");
    } else if (aspect == "green") {
      signal_state = 2;
      digitalWrite(SIGNAL_PIN_RED, LOW);
      digitalWrite(SIGNAL_PIN_YELLOW, LOW);
      digitalWrite(SIGNAL_PIN_GREEN, HIGH);
      Serial.println("Signal pin " + String(SIGNAL_PIN_RED) + " set to LOW");
      Serial.println("Signal pin " + String(SIGNAL_PIN_YELLOW) + " set to LOW");
      Serial.println("Signal pin " + String(SIGNAL_PIN_GREEN) + " set to HIGH (GREEN)");
    }
    
    Serial.println("Signal changed from " + String(old_state == 0 ? "red" : old_state == 1 ? "yellow" : "green") + 
                  " to " + aspect);
    
    // Publish status update
    publishSignalStatus();
  } else {
    Serial.println("‚ùå No aspect specified in signal control message");
  }
  Serial.println("===================");
}

void handleSensors() {
  // Read sensor states
  sensor_states[0] = !digitalRead(SENSOR_PIN_1); // Inverted due to pull-up
  sensor_states[1] = !digitalRead(SENSOR_PIN_2);
  sensor_states[2] = !digitalRead(SENSOR_PIN_3);
  sensor_states[3] = !digitalRead(SENSOR_PIN_4);
  
  // Check for changes and publish updates
  for (int i = 0; i < 4; i++) {
    if (sensor_states[i] != last_sensor_states[i]) {
      Serial.println("=== Sensor State Change ===");
      Serial.println("Sensor " + String(i + 1) + " changed from " + 
                    (last_sensor_states[i] ? "occupied" : "clear") + 
                    " to " + (sensor_states[i] ? "occupied" : "clear"));
      Serial.println("Pin: " + String(i == 0 ? SENSOR_PIN_1 : i == 1 ? SENSOR_PIN_2 : i == 2 ? SENSOR_PIN_3 : SENSOR_PIN_4));
      Serial.println("==========================");
      
      publishSensorStatus(i + 1);
      last_sensor_states[i] = sensor_states[i];
    }
  }
}

void publishSensorStatus(int sensor_num) {
  if (!mqtt_connected) return;
  
  DynamicJsonDocument doc(128);
  doc["sensor"] = sensor_num;
  doc["state"] = sensor_states[sensor_num - 1] ? "occupied" : "clear";
  doc["timestamp"] = millis();
  
  String json_string;
  serializeJson(doc, json_string);
  
  String topic = mqtt_sensor_topic + "/" + String(sensor_num) + "/status";
  mqtt_client.publish(topic.c_str(), json_string.c_str());
  
  Serial.println("Published sensor " + String(sensor_num) + " status: " + json_string);
}

void publishTurnoutStatus(int turnout_num) {
  if (!mqtt_connected) return;
  
  DynamicJsonDocument doc(128);
  doc["turnout"] = turnout_num;
  doc["position"] = turnout_states[turnout_num - 1] ? "thrown" : "normal";
  doc["timestamp"] = millis();
  
  String json_string;
  serializeJson(doc, json_string);
  
  String topic = mqtt_turnout_topic + "/" + String(turnout_num) + "/status";
  mqtt_client.publish(topic.c_str(), json_string.c_str());
  
  Serial.println("Published turnout " + String(turnout_num) + " status: " + json_string);
}

void publishSignalStatus() {
  if (!mqtt_connected) return;
  
  DynamicJsonDocument doc(128);
  doc["signal"] = 1;
  doc["aspect"] = (signal_state == 0) ? "red" : (signal_state == 1) ? "yellow" : "green";
  doc["timestamp"] = millis();
  
  String json_string;
  serializeJson(doc, json_string);
  
  String topic = mqtt_signal_topic + "/1/status";
  mqtt_client.publish(topic.c_str(), json_string.c_str());
  
  Serial.println("Published signal status: " + json_string);
}

void publishInitialStatus() {
  if (!mqtt_connected) return;
  
  Serial.println("=== Publishing Initial Status for All Devices ===");
  
  // Publish individual sensor statuses
  for (int i = 1; i <= 4; i++) {
    publishSensorStatus(i);
    delay(100);  // Small delay between publishes
  }
  
  // Publish individual turnout statuses
  for (int i = 1; i <= 2; i++) {
    publishTurnoutStatus(i);
    delay(100);  // Small delay between publishes
  }
  
  // Publish signal status
  publishSignalStatus();
  
  // Publish overall device status
  publishStatus();
  
  Serial.println("=== Initial Status Published for All Devices ===");
}

void publishAllDeviceStatus() {
  if (!mqtt_connected) return;
  
  Serial.println("=== Publishing All Device Status ===");
  
  // Publish individual sensor statuses
  for (int i = 1; i <= 4; i++) {
    publishSensorStatus(i);
    delay(100);  // Small delay between publishes
  }
  
  // Publish individual turnout statuses
  for (int i = 1; i <= 2; i++) {
    publishTurnoutStatus(i);
    delay(100);  // Small delay between publishes
  }
  
  // Publish signal status
  publishSignalStatus();
  
  // Publish overall device status
  publishStatus();
  
  Serial.println("=== All Device Status Published ===");
}

void publishStatus() {
  if (!mqtt_connected) return;
  
  Serial.println("=== Publishing Device Status ===");
  
  DynamicJsonDocument doc(512);
  doc["device"] = DEVICE_NAME;
  doc["version"] = FIRMWARE_VERSION;
  doc["ip"] = WiFi.localIP().toString();
  doc["rssi"] = WiFi.RSSI();
  doc["uptime"] = millis();
  
  // Add sensor states
  JsonArray sensors = doc.createNestedArray("sensors");
  for (int i = 0; i < 4; i++) {
    JsonObject sensor = sensors.createNestedObject();
    sensor["id"] = i + 1;
    sensor["state"] = sensor_states[i] ? "occupied" : "clear";
  }
  
  // Add turnout states
  JsonArray turnouts = doc.createNestedArray("turnouts");
  for (int i = 0; i < 2; i++) {
    JsonObject turnout = turnouts.createNestedObject();
    turnout["id"] = i + 1;
    turnout["position"] = turnout_states[i] ? "thrown" : "normal";
  }
  
  // Add signal state
  JsonObject signal = doc.createNestedObject("signal");
  signal["id"] = 1;
  signal["aspect"] = (signal_state == 0) ? "red" : (signal_state == 1) ? "yellow" : "green";
  
  String json_string;
  serializeJson(doc, json_string);
  
  Serial.println("Device: " + String(DEVICE_NAME));
  Serial.println("Version: " + String(FIRMWARE_VERSION));
  Serial.println("IP: " + WiFi.localIP().toString());
  Serial.println("RSSI: " + String(WiFi.RSSI()) + " dBm");
  Serial.println("Uptime: " + String(millis()) + " ms");
  Serial.println("Sensors: " + String(sensor_states[0] ? "O" : "C") + " " + 
                String(sensor_states[1] ? "O" : "C") + " " + 
                String(sensor_states[2] ? "O" : "C") + " " + 
                String(sensor_states[3] ? "O" : "C") + " (O=Occupied, C=Clear)");
  Serial.println("Turnouts: " + String(turnout_states[0] ? "T" : "N") + " " + 
                String(turnout_states[1] ? "T" : "N") + " (T=Thrown, N=Normal)");
  Serial.println("Signal: " + String(signal_state == 0 ? "RED" : signal_state == 1 ? "YELLOW" : "GREEN"));
  
  mqtt_client.publish(mqtt_status_topic.c_str(), json_string.c_str());
  
  Serial.println("Status published to topic: " + mqtt_status_topic);
  Serial.println("JSON: " + json_string);
  Serial.println("===============================");
}

void updateStatus() {
  if (mqtt_connected) {
    publishStatus();
  }
}

// Web server handlers
void handleRoot() {
  // Load current MQTT settings for form pre-population
  String current_broker = preferences.getString("mqtt_broker", MQTT_BROKER);
  int current_port = preferences.getInt("mqtt_port", MQTT_PORT);
  String current_client_id = preferences.getString("mqtt_client_id", MQTT_CLIENT_ID);
  String current_topic_prefix = preferences.getString("mqtt_topic_prefix", MQTT_TOPIC_PREFIX);
  
  // Get system information for debugging
  size_t freeSketchSpace = ESP.getFreeSketchSpace();
  size_t freeHeap = ESP.getFreeHeap();
  uint32_t flashChipSize = ESP.getFlashChipSize();
  String sdkVersion = ESP.getSdkVersion();
  
  String html = "<!DOCTYPE html>";
  html += "<html>";
  html += "<head>";
  html += "    <title>ESP32 JMRI Client Configuration</title>";
  html += "    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">";
  html += "    <style>";
  html += "        body { font-family: Arial, sans-serif; margin: 20px; }";
  html += "        .container { max-width: 600px; margin: 0 auto; }";
  html += "        .form-group { margin-bottom: 15px; }";
  html += "        label { display: block; margin-bottom: 5px; font-weight: bold; }";
  html += "        input[type=\"text\"], input[type=\"password\"] { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; }";
  html += "        button { background-color: #4CAF50; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; }";
  html += "        button:hover { background-color: #45a049; }";
  html += "        .status { margin-top: 20px; padding: 10px; border-radius: 4px; }";
  html += "        .success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }";
  html += "        .error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }";
  html += "        h3 { margin-top: 30px; margin-bottom: 15px; color: #333; border-bottom: 2px solid #4CAF50; padding-bottom: 5px; }";
  html += "    </style>";
  html += "</head>";
  html += "<body>";
  html += "    <div class=\"container\">";
  html += "        <h1>ESP32 JMRI Client Configuration</h1>";
  html += "        ";
  html += "        <form id=\"wifiForm\">";
  html += "            <div class=\"form-group\">";
  html += "                <label for=\"ssid\">WiFi SSID:</label>";
  html += "                <input type=\"text\" id=\"ssid\" name=\"ssid\" value=\"" + wifi_ssid + "\" required>";
  html += "            </div>";
  html += "            ";
  html += "            <div class=\"form-group\">";
  html += "                <label for=\"password\">WiFi Password:</label>";
  html += "                <input type=\"password\" id=\"password\" name=\"password\" value=\"" + wifi_password + "\" required>";
  html += "            </div>";
  html += "            ";
  html += "            <button type=\"submit\">Save WiFi Configuration</button>";
  html += "        </form>";
  html += "        ";
  html += "        <h3>MQTT Configuration</h3>";
  html += "        <form id=\"mqttForm\">";
  html += "            <div class=\"form-group\">";
  html += "                <label for=\"mqtt_broker\">MQTT Broker IP:</label>";
  html += "                <input type=\"text\" id=\"mqtt_broker\" name=\"mqtt_broker\" value=\"" + current_broker + "\" required>";
  html += "            </div>";
  html += "            ";
  html += "            <div class=\"form-group\">";
  html += "                <label for=\"mqtt_port\">MQTT Port:</label>";
  html += "                <input type=\"number\" id=\"mqtt_port\" name=\"mqtt_port\" value=\"" + String(current_port) + "\" min=\"1\" max=\"65535\" required>";
  html += "            </div>";
  html += "            ";
  html += "            <div class=\"form-group\">";
  html += "                <label for=\"mqtt_client_id\">MQTT Client ID:</label>";
  html += "                <input type=\"text\" id=\"mqtt_client_id\" name=\"mqtt_client_id\" value=\"" + current_client_id + "\" required>";
  html += "            </div>";
  html += "            ";
  html += "            <div class=\"form-group\">";
  html += "                <label for=\"mqtt_topic_prefix\">MQTT Topic Prefix:</label>";
  html += "                <input type=\"text\" id=\"mqtt_topic_prefix\" name=\"mqtt_topic_prefix\" value=\"" + current_topic_prefix + "\" required>";
  html += "            </div>";
  html += "            ";
  html += "            <button type=\"submit\">Save MQTT Configuration</button>";
  html += "        </form>";
  html += "        ";
  html += "        <div class=\"form-group\">";
  html += "            <button onclick=\"checkStatus()\">Check Status</button>";
  html += "            <button onclick=\"restart()\">Restart Device</button>";
  html += "        </div>";
  html += "        ";
  html += "        <div id=\"status\"></div>";
  html += "        ";
  html += "        <div class=\"form-group\">";
  html += "            <h3>OTA Update</h3>";
  html += "            <form id=\"updateForm\" enctype=\"multipart/form-data\">";
  html += "                <input type=\"file\" id=\"firmware\" name=\"firmware\" accept=\".bin\" required>";
  html += "                <button type=\"submit\">Upload Firmware</button>";
  html += "            </form>";
  html += "            <div id=\"progressBar\" style=\"width: 0%; height: 20px; background-color: #4CAF50; transition: width 0.3s; margin-top: 10px; display: none;\"></div>";
  html += "        </div>";
  html += "    </div>";
  html += "    ";
  html += "    <script>";
  html += "        document.getElementById('wifiForm').onsubmit = function(e) {";
  html += "            e.preventDefault();";
  html += "            ";
  html += "            const formData = new FormData();";
  html += "            formData.append('ssid', document.getElementById('ssid').value);";
  html += "            formData.append('password', document.getElementById('password').value);";
  html += "            ";
  html += "            fetch('/configure', {";
  html += "                method: 'POST',";
  html += "                body: formData";
  html += "            })";
  html += "            .then(response => response.text())";
  html += "            .then(data => {";
  html += "                document.getElementById('status').innerHTML = '<div class=\"status success\">' + data + '</div>';";
  html += "            })";
  html += "            .catch(error => {";
  html += "                document.getElementById('status').innerHTML = '<div class=\"status error\">Error: ' + error + '</div>';";
  html += "            });";
  html += "        };";
  html += "        ";
  html += "        document.getElementById('mqttForm').onsubmit = function(e) {";
  html += "            e.preventDefault();";
  html += "            ";
  html += "            const formData = new FormData();";
  html += "            formData.append('mqtt_broker', document.getElementById('mqtt_broker').value);";
  html += "            formData.append('mqtt_port', document.getElementById('mqtt_port').value);";
  html += "            formData.append('mqtt_client_id', document.getElementById('mqtt_client_id').value);";
  html += "            formData.append('mqtt_topic_prefix', document.getElementById('mqtt_topic_prefix').value);";
  html += "            ";
  html += "            fetch('/configure_mqtt', {";
  html += "                method: 'POST',";
  html += "                body: formData";
  html += "            })";
  html += "            .then(response => response.text())";
  html += "            .then(data => {";
  html += "                document.getElementById('status').innerHTML = '<div class=\"status success\">' + data + '</div>';";
  html += "            })";
  html += "            .catch(error => {";
  html += "                document.getElementById('status').innerHTML = '<div class=\"status error\">Error: ' + error + '</div>';";
  html += "            });";
  html += "        };";
  html += "        ";
  html += "        function checkStatus() {";
  html += "            fetch('/status')";
  html += "            .then(response => response.json())";
  html += "            .then(data => {";
  html += "                document.getElementById('status').innerHTML = '<div class=\"status success\"><pre>' + JSON.stringify(data, null, 2) + '</pre></div>';";
  html += "            })";
  html += "            .catch(error => {";
  html += "                document.getElementById('status').innerHTML = '<div class=\"status error\">Error: ' + error + '</div>';";
  html += "            });";
  html += "        }";
  html += "        ";
  html += "        function restart() {";
  html += "            if (confirm('Are you sure you want to restart the device?')) {";
  html += "                fetch('/restart', { method: 'POST' })";
  html += "                .then(() => {";
  html += "                    document.getElementById('status').innerHTML = '<div class=\"status success\">Device restarting...</div>';";
  html += "            });";
  html += "            }";
  html += "        }";
  html += "        ";
  html += "        document.getElementById('updateForm').onsubmit = function(e) {";
  html += "            e.preventDefault();";
  html += "            ";
  html += "            const file = document.getElementById('firmware').files[0];";
  html += "            if (!file) {";
  html += "                alert('Please select a file');";
  html += "                return;";
  html += "            }";
  html += "            ";
  html += "            const formData = new FormData();";
  html += "            formData.append('firmware', file);";
  html += "            ";
  html += "            const xhr = new XMLHttpRequest();";
  html += "            ";
  html += "            xhr.upload.onprogress = function(e) {";
  html += "                if (e.lengthComputable) {";
  html += "                    const percentComplete = (e.loaded / e.total) * 100;";
  html += "                    document.getElementById('progressBar').style.width = percentComplete + '%';";
  html += "                    document.getElementById('progressBar').textContent = percentComplete + '%';";
  html += "                }";
  html += "            };";
  html += "            ";
  html += "            xhr.onload = function() {";
  html += "                if (xhr.status === 200) {";
  html += "                    document.getElementById('status').innerHTML = '<div style=\"color: green;\">Update successful! Device will restart.</div>';";
  html += "                } else {";
  html += "                    document.getElementById('status').innerHTML = '<div style=\"color: red;\">Update failed: ' + xhr.responseText + '</div>';";
  html += "                }";
  html += "            };";
  html += "            ";
  html += "            xhr.onerror = function() {";
  html += "                document.getElementById('status').innerHTML = '<div style=\"color: red;\">Update failed: Network error</div>';";
  html += "            };";
  html += "            ";
  html += "            xhr.open('POST', '/doUpdate');";
  html += "            xhr.send(formData);";
  html += "        };";
  html += "    </script>";
  html += "</body>";
  html += "</html>";
  
  web_server.send(200, "text/html", html);
}

void handleWiFiConfig() {
  if (web_server.hasArg("ssid") && web_server.hasArg("password")) {
    String new_ssid = web_server.arg("ssid");
    String new_password = web_server.arg("password");
    
    // Save to preferences
    preferences.putString("wifi_ssid", new_ssid);
    preferences.putString("wifi_password", new_password);
    
    wifi_ssid = new_ssid;
    wifi_password = new_password;
    wifi_configured = true;
    
    // Restart WiFi connection
    WiFi.disconnect();
    delay(1000);
    WiFi.begin(wifi_ssid.c_str(), wifi_password.c_str());
    
    web_server.send(200, "text/plain", "WiFi configuration saved. Device will connect to the new network.");
  } else {
    web_server.send(400, "text/plain", "Missing SSID or password");
  }
}

void handleMQTTConfig() {
  if (web_server.hasArg("mqtt_broker") && web_server.hasArg("mqtt_port") && web_server.hasArg("mqtt_client_id") && web_server.hasArg("mqtt_topic_prefix")) {
    String new_broker = web_server.arg("mqtt_broker");
    int new_port = web_server.arg("mqtt_port").toInt();
    String new_client_id = web_server.arg("mqtt_client_id");
    String new_topic_prefix = web_server.arg("mqtt_topic_prefix");

    Serial.println("=== MQTT Configuration Update ===");
    Serial.println("New Broker: " + new_broker);
    Serial.println("New Port: " + String(new_port));
    Serial.println("New Client ID: " + new_client_id);
    Serial.println("New Topic Prefix: " + new_topic_prefix);

    // Save to preferences
    preferences.putString("mqtt_broker", new_broker);
    preferences.putInt("mqtt_port", new_port);
    preferences.putString("mqtt_client_id", new_client_id);
    preferences.putString("mqtt_topic_prefix", new_topic_prefix);

    // Update MQTT client settings
    mqtt_client.setServer(new_broker.c_str(), new_port);
    
    // Update our stored broker info
    mqtt_broker_ip = new_broker;
    mqtt_broker_port = new_port;
    
    // Update topic strings
    mqtt_base_topic = String(new_topic_prefix) + "/" + WiFi.macAddress();
    mqtt_sensor_topic = mqtt_base_topic + "/sensors";
    mqtt_turnout_topic = mqtt_base_topic + "/turnouts";
    mqtt_signal_topic = mqtt_base_topic + "/signals";
    mqtt_status_topic = mqtt_base_topic + "/status";

    Serial.println("Updated topic strings:");
    Serial.println("  Base: " + mqtt_base_topic);
    Serial.println("  Sensors: " + mqtt_sensor_topic);
    Serial.println("  Turnouts: " + mqtt_turnout_topic);
    Serial.println("  Signals: " + mqtt_signal_topic);
    Serial.println("  Status: " + mqtt_status_topic);

    // Disconnect current MQTT connection
    Serial.println("Disconnecting current MQTT connection...");
    mqtt_client.disconnect();
    mqtt_connected = false;
    delay(1000);
    
    // Try to reconnect with new settings
    Serial.println("Attempting to reconnect with new MQTT settings...");
    if (mqtt_client.connect(new_client_id.c_str())) {
      Serial.println("‚úÖ MQTT reconnected with new configuration successfully!");
      mqtt_connected = true;
      
      // Resubscribe to control topics
      String turnout_topic = mqtt_turnout_topic + "/+/control";
      String signal_topic = mqtt_signal_topic + "/+/control";
      
      Serial.println("Resubscribing to turnout topic: " + turnout_topic);
      mqtt_client.subscribe(turnout_topic.c_str());
      
      Serial.println("Resubscribing to signal topic: " + signal_topic);
      mqtt_client.subscribe(signal_topic.c_str());
      
      // Publish updated status
      Serial.println("Publishing updated status...");
      publishInitialStatus();
      
      Serial.println("=== MQTT Reconfiguration Complete ===");
    } else {
      Serial.println("‚ùå Failed to reconnect to MQTT with new configuration");
      Serial.printf("Error code: %d\n", mqtt_client.state());
      mqtt_connected = false;
    }

    web_server.send(200, "text/plain", "MQTT configuration saved. Device will reconnect to MQTT broker.");
  } else {
    web_server.send(400, "text/plain", "Missing MQTT configuration parameters");
  }
}

void handleStatus() {
  DynamicJsonDocument doc(512);
  doc["device"] = DEVICE_NAME;
  doc["version"] = FIRMWARE_VERSION;
  doc["wifi_connected"] = (WiFi.status() == WL_CONNECTED);
  doc["wifi_ssid"] = wifi_ssid;
  doc["ip_address"] = WiFi.localIP().toString();
  doc["mqtt_connected"] = mqtt_connected;
  
  // Add MQTT configuration info
  doc["mqtt_broker"] = preferences.getString("mqtt_broker", MQTT_BROKER);
  doc["mqtt_port"] = preferences.getInt("mqtt_port", MQTT_PORT);
  doc["mqtt_client_id"] = preferences.getString("mqtt_client_id", MQTT_CLIENT_ID);
  doc["mqtt_topic_prefix"] = preferences.getString("mqtt_topic_prefix", MQTT_TOPIC_PREFIX);
  
  doc["uptime"] = millis();
  
  String json_string;
  serializeJson(doc, json_string);
  
  web_server.send(200, "application/json", json_string);
}

void handleRestart() {
  web_server.send(200, "text/plain", "Device restarting...");
  delay(1000);
  ESP.restart();
}

void handleUpdatePage() {
  String html = "<!DOCTYPE html>";
  html += "<html>";
  html += "<head>";
  html += "    <title>OTA Update</title>";
  html += "    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">";
  html += "    <style>";
  html += "        body { font-family: Arial, sans-serif; margin: 20px; }";
  html += "        .container { max-width: 600px; margin: 0 auto; }";
  html += "        .form-group { margin-bottom: 15px; }";
  html += "        input[type=\"file\"] { margin-bottom: 10px; }";
  html += "        button { background-color: #4CAF50; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; }";
  html += "        .progress { width: 100%; background-color: #f0f0f0; border-radius: 4px; margin: 10px 0; }";
  html += "        .progress-bar { height: 20px; background-color: #4CAF50; border-radius: 4px; width: 0%; transition: width 0.3s; }";
  html += "    </style>";
  html += "</head>";
  html += "<body>";
  html += "    <div class=\"container\">";
  html += "        <h1>OTA Firmware Update</h1>";
  html += "        <form id=\"updateForm\" enctype=\"multipart/form-data\">";
  html += "            <div class=\"form-group\">";
  html += "                <label for=\"firmware\">Select firmware file (.bin):</label>";
  html += "                <input type=\"file\" id=\"firmware\" name=\"firmware\" accept=\".bin\" required>";
  html += "            </div>";
  html += "            <button type=\"submit\">Upload Firmware</button>";
  html += "        </form>";
  html += "        ";
  html += "        <div class=\"progress\">";
  html += "            <div class=\"progress-bar\" id=\"progressBar\"></div>";
  html += "        </div>";
  html += "        ";
  html += "        <div id=\"status\"></div>";
  html += "    </div>";
  html += "    ";
  html += "    <script>";
  html += "        document.getElementById('updateForm').onsubmit = function(e) {";
  html += "            e.preventDefault();";
  html += "            ";
  html += "            const file = document.getElementById('firmware').files[0];";
  html += "            if (!file) {";
  html += "                alert('Please select a file');";
  html += "                return;";
  html += "            }";
  html += "            ";
  html += "            const formData = new FormData();";
  html += "            formData.append('firmware', file);";
  html += "            ";
  html += "            const xhr = new XMLHttpRequest();";
  html += "            ";
  html += "            xhr.upload.onprogress = function(e) {";
  html += "                if (e.lengthComputable) {";
  html += "                    const percentComplete = (e.loaded / e.total) * 100;";
  html += "                    document.getElementById('progressBar').style.width = percentComplete + '%';";
  html += "                    document.getElementById('progressBar').textContent = percentComplete + '%';";
  html += "                }";
  html += "            };";
  html += "            ";
  html += "            xhr.onload = function() {";
  html += "                if (xhr.status === 200) {";
  html += "                    document.getElementById('status').innerHTML = '<div style=\"color: green;\">Update successful! Device will restart.</div>';";
  html += "                } else {";
  html += "                    document.getElementById('status').innerHTML = '<div style=\"color: red;\">Update failed: ' + xhr.responseText + '</div>';";
  html += "                }";
  html += "            };";
  html += "            ";
  html += "            xhr.onerror = function() {";
  html += "                document.getElementById('status').innerHTML = '<div style=\"color: red;\">Update failed: Network error</div>';";
  html += "            };";
  html += "            ";
  html += "            xhr.open('POST', '/doUpdate');";
  html += "            xhr.send(formData);";
  html += "        };";
  html += "    </script>";
  html += "</body>";
  html += "</html>";
  
  web_server.send(200, "text/html", html);
}

void handleDoUpdate() {
  web_server.sendHeader("Connection", "close");
  
  if (Update.hasError()) {
    String error_msg = "Update failed: " + String(Update.errorString());
    Serial.println(error_msg);
    web_server.send(500, "text/plain", error_msg);
  } else {
    Serial.println("Update successful, restarting device...");
    web_server.send(200, "text/plain", "Update successful! Device will restart in 3 seconds...");
    delay(3000);
    ESP.restart();
  }
}

void handleUpdateBody() {
  static size_t totalSize = 0;
  static size_t currentSize = 0;
  
  // Get the firmware file from the request
  HTTPUpload& upload = web_server.upload();
  
  // Feed watchdog at the start of each upload event
  yield();
  
  Serial.printf("OTA Upload Status: %d, Size: %u/%u\n", 
               upload.status, upload.currentSize, upload.totalSize);
  
  if (upload.status == UPLOAD_FILE_START) {
    Serial.println("=== OTA Update Started ===");
    Serial.println("File name: " + upload.filename);
    Serial.println("File size: " + String(upload.totalSize));
    
    // Validate file size
    if (upload.totalSize == 0) {
      Serial.println("‚ùå Error: File size is 0 - invalid upload");
      web_server.send(400, "text/plain", "Error: Invalid file size (0 bytes)");
      return;
    }
    
    // Print system information for debugging
    Serial.println("System Info:");
    Serial.println("  Free Sketch Space: " + String(ESP.getFreeSketchSpace()) + " bytes");
    Serial.println("  Free Heap: " + String(ESP.getFreeHeap()) + " bytes");
    Serial.println("  Flash Chip Size: " + String(ESP.getFlashChipSize()) + " bytes");
    Serial.println("  Max OTA Size: " + String(ESP.getFreeSketchSpace() - 0x1000) + " bytes");
    
    // Check if we have enough space
    if (upload.totalSize > (ESP.getFreeSketchSpace() - 0x1000)) {
      String error_msg = "Not enough space to begin OTA. Need: " + String(upload.totalSize) + 
                        " bytes, Available: " + String(ESP.getFreeSketchSpace() - 0x1000) + " bytes";
      Serial.println("‚ùå " + error_msg);
      web_server.send(400, "text/plain", error_msg);
      return;
    }
    
    // Begin the update
    if (!Update.begin(upload.totalSize)) {
      String error_msg = "Update begin failed: " + String(Update.errorString());
      Serial.println("‚ùå " + error_msg);
      web_server.send(400, "text/plain", error_msg);
      return;
    }
    
    totalSize = upload.totalSize;
    currentSize = 0;
    
    Serial.println("‚úÖ Update begin successful, total size: " + String(totalSize));
    
  } else if (upload.status == UPLOAD_FILE_WRITE) {
    // Validate that we have data to write
    if (upload.currentSize == 0) {
      Serial.println("‚ö†Ô∏è Warning: Received 0 bytes in write chunk");
      return; // Skip this chunk but don't fail
    }
    
    // Write the received data
    if (Update.write(upload.buf, upload.currentSize)) {
      currentSize += upload.currentSize;
      Serial.printf("üì§ Progress: %u%% (%u/%u bytes)\n", 
                   (currentSize * 100) / totalSize, currentSize, totalSize);
      
      // Feed the watchdog to prevent reset
      yield();
      
      // Add a small delay to prevent overwhelming the system
      delay(1);
      
    } else {
      String error_msg = "Update write failed: " + String(Update.errorString());
      Serial.println("‚ùå " + error_msg);
      Serial.println("Current size: " + String(currentSize) + "/" + String(totalSize));
      Serial.println("Chunk size: " + String(upload.currentSize));
      Serial.println("Buffer address: " + String((uint32_t)upload.buf));
      
      // Don't send response here as it might interfere with the upload
      // Just log the error and continue
    }
    
  } else if (upload.status == UPLOAD_FILE_END) {
    // Finalize the update
    Serial.println("=== Upload Complete ===");
    Serial.println("Final size: " + String(currentSize) + "/" + String(totalSize));
    
    if (currentSize != totalSize) {
      Serial.printf("‚ö†Ô∏è Warning: Size mismatch. Expected: %u, Received: %u\n", totalSize, currentSize);
    }
    
    if (Update.end()) {
      Serial.println("‚úÖ Update end successful");
      
      // Verify the update
      if (Update.hasError()) {
        String error_msg = "Update verification failed: " + String(Update.errorString());
        Serial.println("‚ùå " + error_msg);
        web_server.send(500, "text/plain", error_msg);
        return;
      }
      
      Serial.println("‚úÖ Update verified successfully!");
      Serial.println("Device will restart in 3 seconds...");
      web_server.send(200, "text/plain", "Update completed successfully! Device will restart in 3 seconds...");
      
      // Restart after a delay to allow response to be sent
      delay(3000);
      ESP.restart();
      
    } else {
      String error_msg = "Update end failed: " + String(Update.errorString());
      Serial.println("‚ùå " + error_msg);
      web_server.send(500, "text/plain", error_msg);
      return;
    }
  }
}
