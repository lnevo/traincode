/*
 * ESP32 JMRI MQTT Client
 * 
 * This project provides an ESP32-based MQTT client for interfacing with JMRI
 * for model railroad control. Features include:
 * - Sensor feedback detection
 * - Turnout control
 * - Signal control
 * - OTA updates
 * - WiFi configuration via web interface
 * - MQTT communication with JMRI
 * 
 * Author: Generated by AI Assistant
 * Date: 2024
 */

#include "config.h"
#include <WiFi.h>
#include <PubSubClient.h>
#include <ArduinoJson.h>
#include <WebServer.h>
#include <Update.h>
#include <SPIFFS.h>
#include <Preferences.h>
#include <ArduinoOTA.h>

// WiFi configuration
const char* default_ssid = DEFAULT_SSID;
const char* default_password = DEFAULT_PASSWORD;
String wifi_ssid = "";
String wifi_password = "";

// MQTT topics - Updated to match JMRI format
String mqtt_base_topic = String(MQTT_TOPIC_PREFIX) + "/";
String mqtt_sensor_topic = mqtt_base_topic + "sensor/";
String mqtt_turnout_topic = mqtt_base_topic + "turnout/";
String mqtt_signal_topic = mqtt_base_topic + "signal/";
String mqtt_light_topic = mqtt_base_topic + "light/";
String mqtt_status_topic = mqtt_base_topic + "status/";

// Global objects
WiFiClient espClient;
PubSubClient mqtt_client(espClient);
WebServer web_server(80);
Preferences preferences;

// MQTT broker info storage
String mqtt_broker_ip = "";
int mqtt_broker_port = 0;

// State variables
bool wifi_configured = false;
bool mqtt_connected = false;
unsigned long last_mqtt_attempt = 0;
unsigned long last_status_update = 0;
unsigned long last_periodic_status = 0;  // For periodic status publishing

// Sensor states
bool sensor_states[4] = {false, false, false, false};
bool last_sensor_states[4] = {false, false, false, false};

// Turnout states
bool turnout_states[2] = {false, false};

// Signal states
int signal_state = 0; // 0=red, 1=yellow, 2=green

void displaySystemInfo() {
  Serial.println("=== System Information ===");
  Serial.println("Device: " + String(DEVICE_NAME));
  Serial.println("Firmware Version: " + String(FIRMWARE_VERSION));
  Serial.println("Free Sketch Space: " + String(ESP.getFreeSketchSpace()) + " bytes");
  Serial.println("Free Heap: " + String(ESP.getFreeHeap()) + " bytes");
  Serial.println("Flash Chip Size: " + String(ESP.getFlashChipSize()) + " bytes");
  Serial.println("Max OTA Size: " + String(ESP.getFreeSketchSpace() - 0x1000) + " bytes");
  Serial.println("SDK Version: " + String(ESP.getSdkVersion()));
  Serial.println("CPU Frequency: " + String(ESP.getCpuFreqMHz()) + " MHz");
  Serial.println("===============================");
}

void setup() {
  Serial.begin(SERIAL_BAUD_RATE);
  Serial.println("\n\n=== ESP32 JMRI MQTT Client ===");
  Serial.println("Firmware Version: " + String(FIRMWARE_VERSION));
  
  // Display system information
  displaySystemInfo();
  
  // Initialize pins
  initializePins();
  
  // Initialize SPIFFS
  if (!SPIFFS.begin(true)) {
    Serial.println("SPIFFS initialization failed");
  }
  
  // Initialize preferences
  preferences.begin("jmri_client", false);
  
  // Load saved WiFi credentials
  loadWiFiCredentials();
  
  // Load saved MQTT credentials
  loadMQTTCredentials();
  
  // Setup WiFi
  setupWiFi();
  
  // Wait for WiFi to stabilize
  if (WiFi.status() == WL_CONNECTED) {
    delay(2000);  // Give WiFi time to stabilize
    Serial.println("WiFi connected, attempting MQTT connection...");
    
    // Now setup MQTT with the loaded credentials
    setupMQTT();
    
    // Test broker connectivity before attempting connection
    testMQTTBrokerConnectivity();
    
    // Attempt initial MQTT connection
    Serial.println("Attempting initial MQTT connection...");
    mqttReconnect();
  } else {
    // If WiFi didn't connect, still setup MQTT for when it does connect
    setupMQTT();
  }
  
  // Setup web server for configuration
  setupWebServer();
  
  // Setup OTA
  setupOTA();
  
  Serial.println("Setup complete!");
}

void loop() {
  // Feed the watchdog to prevent resets
  yield();
  
  // Handle WiFi
  if (WiFi.status() != WL_CONNECTED) {
    handleWiFiReconnection();
  }
  
  // Handle MQTT
  if (WiFi.status() == WL_CONNECTED) {
    handleMQTT();
  }
  
  // Handle sensors
  handleSensors();
  
  // Handle web server
  web_server.handleClient();
  
  // Handle OTA
  ArduinoOTA.handle();
  
  // Update status
  if (millis() - last_status_update > STATUS_UPDATE_INTERVAL) {
    updateStatus();
    last_status_update = millis();
  }
  
  // Periodic status publishing for all devices
  if (millis() - last_periodic_status > PERIODIC_STATUS_INTERVAL) {
    publishAllDeviceStatus();
    last_periodic_status = millis();
    
    // Also report connection status
    Serial.println("=== Connection Status Report ===");
    Serial.println("WiFi Status: " + String(WiFi.status() == WL_CONNECTED ? "Connected" : "Disconnected"));
    if (WiFi.status() == WL_CONNECTED) {
      Serial.println("SSID: " + WiFi.SSID());
      Serial.println("IP: " + WiFi.localIP().toString());
      Serial.println("RSSI: " + String(WiFi.RSSI()) + " dBm");
    }
    Serial.println("MQTT Status: " + String(mqtt_connected ? "Connected" : "Disconnected"));
    if (mqtt_connected) {
      Serial.println("Broker: " + mqtt_broker_ip + ":" + String(mqtt_broker_port));
    }
    Serial.println("===============================");
  }
  
  delay(10);
}

void initializePins() {
  // Sensor pins (input with pull-up)
  pinMode(SENSOR_PIN_1, INPUT_PULLUP);
  pinMode(SENSOR_PIN_2, INPUT_PULLUP);
  pinMode(SENSOR_PIN_3, INPUT_PULLUP);
  pinMode(SENSOR_PIN_4, INPUT_PULLUP);
  
  // Turnout pins (output)
  pinMode(TURNOUT_PIN_1, OUTPUT);
  pinMode(TURNOUT_PIN_2, OUTPUT);
  digitalWrite(TURNOUT_PIN_1, LOW);
  digitalWrite(TURNOUT_PIN_2, LOW);
  
  // Signal pins (output)
  pinMode(SIGNAL_PIN_RED, OUTPUT);
  pinMode(SIGNAL_PIN_YELLOW, OUTPUT);
  pinMode(SIGNAL_PIN_GREEN, OUTPUT);
  digitalWrite(SIGNAL_PIN_RED, HIGH);   // Start with red
  digitalWrite(SIGNAL_PIN_YELLOW, LOW);
  digitalWrite(SIGNAL_PIN_GREEN, LOW);
  
  // Status LED
  pinMode(STATUS_LED, OUTPUT);
  digitalWrite(STATUS_LED, LOW);
}

void loadWiFiCredentials() {
  wifi_ssid = preferences.getString("wifi_ssid", "");
  wifi_password = preferences.getString("wifi_password", "");
  wifi_configured = (wifi_ssid.length() > 0);
  
  if (wifi_configured) {
    Serial.println("Loaded saved WiFi credentials for: " + wifi_ssid);
  } else {
    Serial.println("No saved WiFi credentials found");
  }
}

void loadMQTTCredentials() {
  Serial.println("=== Loading MQTT Credentials ===");
  
  // Load MQTT settings from preferences if they exist
  String broker = preferences.getString("mqtt_broker", "");
  int port = preferences.getInt("mqtt_port", 0);
  String client_id = preferences.getString("mqtt_client_id", "");
  String topic_prefix = preferences.getString("mqtt_topic_prefix", "");
  
  Serial.println("From preferences:");
  Serial.println("  Broker: " + (broker.length() > 0 ? broker : "NOT SET"));
  Serial.println("  Port: " + (port > 0 ? String(port) : "NOT SET"));
  Serial.println("  Client ID: " + (client_id.length() > 0 ? client_id : "NOT SET"));
  Serial.println("  Topic Prefix: " + (topic_prefix.length() > 0 ? topic_prefix : "NOT SET"));
  
  if (broker.length() > 0 && port > 0 && client_id.length() > 0 && topic_prefix.length() > 0) {
    Serial.println("‚úÖ Loaded saved MQTT credentials for broker: " + broker + ":" + String(port));
    // Update MQTT client settings
    mqtt_broker_ip = broker;
    mqtt_broker_port = port;
    
    // Update topic strings
    mqtt_base_topic = String(topic_prefix) + "/";
    mqtt_sensor_topic = mqtt_base_topic + "sensor/";
    mqtt_turnout_topic = mqtt_base_topic + "turnout/";
    mqtt_signal_topic = mqtt_base_topic + "signal/";
    mqtt_light_topic = mqtt_base_topic + "light/";
    mqtt_status_topic = mqtt_base_topic + "status/";
    
    Serial.println("Updated topic strings:");
    Serial.println("  Base: " + mqtt_base_topic);
    Serial.println("  Sensors: " + mqtt_sensor_topic);
    Serial.println("  Turnouts: " + mqtt_turnout_topic);
    Serial.println("  Signals: " + mqtt_signal_topic);
    Serial.println("  Status: " + mqtt_status_topic);
  } else {
    Serial.println("‚ö†Ô∏è No saved MQTT credentials found, will use defaults from config.h");
    Serial.println("Default values from config.h:");
    Serial.println("  Broker: " + String(MQTT_BROKER));
    Serial.println("  Port: " + String(MQTT_PORT));
    Serial.println("  Client ID: " + String(MQTT_CLIENT_ID));
    Serial.println("  Topic Prefix: " + String(MQTT_TOPIC_PREFIX));
  }
  
  Serial.println("===============================");
}

void setupWiFi() {
  if (wifi_configured) {
    // Try to connect to saved network
    Serial.println("=== WiFi Setup ===");
    Serial.println("Attempting to connect to saved WiFi network: " + wifi_ssid);
    Serial.println("WiFi mode: Station");
    
    WiFi.mode(WIFI_STA);
    WiFi.begin(wifi_ssid.c_str(), wifi_password.c_str());
    
    int attempts = 0;
    while (WiFi.status() != WL_CONNECTED && attempts < WIFI_MAX_ATTEMPTS) {
      delay(500);
      Serial.print(".");
      attempts++;
    }
    
    if (WiFi.status() == WL_CONNECTED) {
      Serial.println("\n‚úÖ WiFi connected successfully!");
      Serial.println("SSID: " + WiFi.SSID());
      Serial.println("IP address: " + WiFi.localIP().toString());
      Serial.println("Gateway: " + WiFi.gatewayIP().toString());
      Serial.println("DNS: " + WiFi.dnsIP().toString());
      Serial.println("RSSI: " + String(WiFi.RSSI()) + " dBm");
      Serial.println("Channel: " + String(WiFi.channel()));
      digitalWrite(STATUS_LED, HIGH);
      Serial.println("=== WiFi Setup Complete ===");
    } else {
      Serial.println("\n‚ùå Failed to connect to saved WiFi");
      Serial.println("WiFi status: " + String(WiFi.status()));
      wifi_configured = false;
    }
  }
  
  if (!wifi_configured) {
    // Start configuration mode
    Serial.println("=== Starting WiFi Configuration Mode ===");
    WiFi.mode(WIFI_AP);
    WiFi.softAP(default_ssid, default_password);
    Serial.println("AP SSID: " + String(default_ssid));
    Serial.println("AP Password: " + String(default_password));
    Serial.println("AP IP address: " + WiFi.softAPIP().toString());
    Serial.println("Connect to '" + String(default_ssid) + "' network with password '" + String(default_password) + "'");
    Serial.println("Then navigate to http://" + WiFi.softAPIP().toString() + " to configure");
    Serial.println("=== WiFi Configuration Mode Active ===");
  }
}

void setupMQTT() {
  Serial.println("=== Setting up MQTT ===");
  
  // Check if we have loaded credentials from preferences
  if (mqtt_broker_ip.length() > 0 && mqtt_broker_port > 0) {
    Serial.println("Using loaded credentials from preferences:");
    Serial.println("  Broker: " + mqtt_broker_ip);
    Serial.println("  Port: " + String(mqtt_broker_port));
    Serial.println("  Client ID: " + String(MQTT_CLIENT_ID));
    Serial.println("  Topic Prefix: " + String(MQTT_TOPIC_PREFIX));
  } else {
    Serial.println("No credentials loaded, using defaults from config.h:");
    Serial.println("  Broker: " + String(MQTT_BROKER));
    Serial.println("  Port: " + String(MQTT_PORT));
    Serial.println("  Client ID: " + String(MQTT_CLIENT_ID));
    Serial.println("  Topic Prefix: " + String(MQTT_TOPIC_PREFIX));
    
    // Set default values if none were loaded
    mqtt_broker_ip = String(MQTT_BROKER);
    mqtt_broker_port = MQTT_PORT;
  }
  
  // Update MQTT client settings
  mqtt_client.setServer(mqtt_broker_ip.c_str(), mqtt_broker_port);
  mqtt_client.setCallback(mqttCallback);
  mqtt_client.setKeepAlive(60);
  mqtt_client.setSocketTimeout(30);
  
  // Update topic strings with current values
  mqtt_base_topic = String(MQTT_TOPIC_PREFIX) + "/";
  mqtt_sensor_topic = mqtt_base_topic + "sensor/";
  mqtt_turnout_topic = mqtt_base_topic + "turnout/";
  mqtt_signal_topic = mqtt_base_topic + "signal/";
  mqtt_light_topic = mqtt_base_topic + "light/";
  mqtt_status_topic = mqtt_base_topic + "status/";
  
  Serial.println("Final MQTT configuration:");
  Serial.println("  Broker: " + mqtt_broker_ip + ":" + String(mqtt_broker_port));
  Serial.println("  Base Topic: " + mqtt_base_topic);
  Serial.println("  Sensor Topic: " + mqtt_sensor_topic);
  Serial.println("  Turnout Topic: " + mqtt_turnout_topic);
  Serial.println("  Signal Topic: " + mqtt_signal_topic);
  Serial.println("  Status Topic: " + mqtt_status_topic);
  Serial.println("===============================");
}

void setupWebServer() {
  // Configuration page
  web_server.on("/", HTTP_GET, handleRoot);
  web_server.on("/configure", HTTP_POST, handleWiFiConfig);
  web_server.on("/configure_mqtt", HTTP_POST, handleMQTTConfig); // New handler for MQTT config
  web_server.on("/status", HTTP_GET, handleStatus);
  web_server.on("/restart", HTTP_POST, handleRestart);
  
  // Test endpoint for debugging
  web_server.on("/test", HTTP_GET, []() {
    web_server.send(200, "text/plain", "Web server is working! Firmware version: " + String(FIRMWARE_VERSION));
  });
  
  // OTA update page
  web_server.on("/update", HTTP_GET, handleUpdatePage);
  web_server.on("/doUpdate", HTTP_POST, handleDoUpdate, handleUpdateBody);
  
  web_server.begin();
  Serial.println("Web server started");
}

void setupOTA() {
  Serial.println("Setting up OTA...");
  
  ArduinoOTA.setHostname(DEVICE_NAME);
  ArduinoOTA.setPassword("admin");
  
  // Set OTA port (default is 3232)
  ArduinoOTA.setPort(3232);
  
  ArduinoOTA.onStart([]() {
    Serial.println("=== OTA Update Started ===");
    Serial.println("Disabling watchdog during update...");
    digitalWrite(STATUS_LED, LOW);
  });
  
  ArduinoOTA.onProgress([](unsigned int progress, unsigned int total) {
    Serial.printf("OTA Progress: %u%%\n", (progress / (total / 100)));
    // Feed watchdog during progress
    yield();
  });
  
  ArduinoOTA.onEnd([]() {
    Serial.println("=== OTA Update Completed ===");
    Serial.println("Update successful, restarting...");
    digitalWrite(STATUS_LED, HIGH);
  });
  
  ArduinoOTA.onError([](ota_error_t error) {
    Serial.printf("=== OTA Error: %u ===\n", error);
    Serial.println("Error details:");
    switch (error) {
      case OTA_AUTH_ERROR:
        Serial.println("Auth Failed");
        break;
      case OTA_BEGIN_ERROR:
        Serial.println("Begin Failed");
        break;
      case OTA_CONNECT_ERROR:
        Serial.println("Connect Failed");
        break;
      case OTA_RECEIVE_ERROR:
        Serial.println("Receive Failed");
        break;
      case OTA_END_ERROR:
        Serial.println("End Failed");
        break;
      default:
        Serial.println("Unknown Error");
        break;
    }
    digitalWrite(STATUS_LED, LOW);
  });
  
  ArduinoOTA.begin();
  Serial.println("OTA ready on port 3232");
  Serial.println("You can also use Arduino IDE or other OTA tools to update");
}

void handleWiFiReconnection() {
  static unsigned long last_reconnect_attempt = 0;
  unsigned long current_time = millis();
  
  if (current_time - last_reconnect_attempt > WIFI_RECONNECT_INTERVAL) { // Try every 30 seconds
    Serial.println("Attempting WiFi reconnection...");
    WiFi.reconnect();
    last_reconnect_attempt = current_time;
  }
}

void handleMQTT() {
  if (!mqtt_client.connected()) {
    if (millis() - last_mqtt_attempt > MQTT_RETRY_INTERVAL) {
      mqttReconnect();
      last_mqtt_attempt = millis();
    }
  } else {
    mqtt_client.loop();
  }
}

void testMQTTBrokerConnectivity() {
  Serial.println("=== Testing MQTT Broker Connectivity ===");
  Serial.println("Broker: " + mqtt_broker_ip + ":" + String(mqtt_broker_port));
  
  // Create a temporary WiFi client to test connectivity
  WiFiClient testClient;
  
  Serial.println("Attempting TCP connection to broker...");
  if (testClient.connect(mqtt_broker_ip.c_str(), mqtt_broker_port)) {
    Serial.println("‚úÖ TCP connection to broker successful");
    Serial.println("Broker is reachable on the network");
    testClient.stop();
  } else {
    Serial.println("‚ùå TCP connection to broker failed");
    Serial.println("Broker may be unreachable or port may be blocked");
    Serial.println("Check:");
    Serial.println("  - Broker IP address is correct");
    Serial.println("  - Broker is running and listening on port " + String(mqtt_broker_port));
    Serial.println("  - Network firewall allows connections to this port");
    Serial.println("  - WiFi network can reach the broker subnet");
  }
  Serial.println("===============================");
}

void mqttReconnect() {
  Serial.println("=== Attempting MQTT Connection ===");
  Serial.println("Broker: " + mqtt_broker_ip);
  Serial.println("Port: " + String(mqtt_broker_port));
  Serial.println("Client ID: " + String(MQTT_CLIENT_ID));
  Serial.println("WiFi Status: " + String(WiFi.status()));
  Serial.println("WiFi IP: " + WiFi.localIP().toString());
  
  if (mqtt_client.connect(MQTT_CLIENT_ID)) {
    Serial.println("‚úÖ MQTT connected successfully!");
    mqtt_connected = true;
    
    // Subscribe to control topics
    String turnout_topic = mqtt_turnout_topic + "+";
    String signal_topic = mqtt_signal_topic + "+";
    
    Serial.println("Subscribing to turnout topic: " + turnout_topic);
    mqtt_client.subscribe(turnout_topic.c_str());
    
    Serial.println("Subscribing to signal topic: " + signal_topic);
    mqtt_client.subscribe(signal_topic.c_str());
    
    Serial.println("Subscriptions completed");
    
    // Publish initial status
    Serial.println("Publishing initial status...");
    publishInitialStatus();
    
    Serial.println("=== MQTT Setup Complete ===");
  } else {
    Serial.printf("‚ùå MQTT connection failed, rc=%d\n", mqtt_client.state());
    Serial.println("Error codes:");
    Serial.println("  -4: MQTT_CONNECTION_TIMEOUT");
    Serial.println("  -3: MQTT_CONNECTION_LOST");
    Serial.println("  -2: MQTT_CONNECT_FAILED");
    Serial.println("  -1: MQTT_DISCONNECTED");
    Serial.println("   0: MQTT_CONNECTED");
    Serial.println("   1: MQTT_CONNECT_BAD_PROTOCOL");
    Serial.println("   2: MQTT_CONNECT_BAD_CLIENT_ID");
    Serial.println("   3: MQTT_CONNECT_UNAVAILABLE");
    Serial.println("   4: MQTT_CONNECT_BAD_CREDENTIALS");
    Serial.println("   5: MQTT_CONNECT_UNAUTHORIZED");
    mqtt_connected = false;
  }
}

void mqttCallback(char* topic, byte* payload, unsigned int length) {
  String topic_str = String(topic);
  String payload_str = "";
  
  for (int i = 0; i < length; i++) {
    payload_str += (char)payload[i];
  }
  
  Serial.println("=== MQTT Message Received ===");
  Serial.println("  Topic: " + topic_str);
  Serial.println("  Payload: " + payload_str);
  Serial.println("  Length: " + String(length) + " bytes");
  Serial.println("  From Broker: " + mqtt_broker_ip + ":" + String(mqtt_broker_port));
  Serial.println("  Timestamp: " + String(millis()) + " ms");
  Serial.println("================================");
  
  // Handle turnout control - JMRI sends simple text commands
  if (topic_str.indexOf("/turnout/") > 0) {
    Serial.println("üéØ Processing turnout control message");
    handleTurnoutControl(topic_str, payload_str);
  }
  
  // Handle signal control - JMRI sends simple text commands
  if (topic_str.indexOf("/signal/") > 0) {
    Serial.println("üéØ Processing signal control message");
    handleSignalControl(topic_str, payload_str);
  }
}

void handleTurnoutControl(String topic, String payload) {
  // Extract turnout number from topic (e.g., "track/turnout/1" -> turnout 1)
  int turnout_num = 0;
  
  // Find the last number in the topic
  int lastSlash = topic.lastIndexOf('/');
  if (lastSlash > 0) {
    String turnout_str = topic.substring(lastSlash + 1);
    turnout_num = turnout_str.toInt() - 1;  // Convert to 0-based index
  }
  
  // Validate turnout number
  if (turnout_num < 0 || turnout_num > 1) {
    Serial.println("‚ùå Error: Invalid turnout number: " + String(turnout_num + 1));
    Serial.println("=====================");
    return;
  }
  
  Serial.println("=== Turnout Control ===");
  Serial.println("Turnout: " + String(turnout_num + 1));
  Serial.println("Topic: " + topic);
  Serial.println("Payload: " + payload);
  Serial.println("Current state: " + String(turnout_states[turnout_num] ? "THROWN" : "CLOSED"));
  
  bool state_changed = false;
  
  if (payload == "THROWN") {
    Serial.println("üéØ Requested position: THROWN");
    
    if (turnout_states[turnout_num] != true) {  // Only change if state is different
      state_changed = true;
      
      if (turnout_num == 0) {
        digitalWrite(TURNOUT_PIN_1, HIGH);
        turnout_states[0] = true;
        Serial.println("‚úÖ Turnout 1 pin " + String(TURNOUT_PIN_1) + " set to HIGH");
      } else if (turnout_num == 1) {
        digitalWrite(TURNOUT_PIN_2, HIGH);
        turnout_states[1] = true;
        Serial.println("‚úÖ Turnout 2 pin " + String(TURNOUT_PIN_2) + " set to HIGH");
      }
      
      Serial.println("‚úÖ Turnout " + String(turnout_num + 1) + " moved to THROWN");
    } else {
      Serial.println("‚ÑπÔ∏è Turnout " + String(turnout_num + 1) + " already in THROWN position");
    }
    
  } else if (payload == "CLOSED") {
    Serial.println("üéØ Requested position: CLOSED");
    
    if (turnout_states[turnout_num] != false) {  // Only change if state is different
      state_changed = true;
      
      if (turnout_num == 0) {
        digitalWrite(TURNOUT_PIN_1, LOW);
        turnout_states[0] = false;
        Serial.println("‚úÖ Turnout 1 pin " + String(TURNOUT_PIN_1) + " set to LOW");
      } else if (turnout_num == 1) {
        digitalWrite(TURNOUT_PIN_2, LOW);
        turnout_states[1] = false;
        Serial.println("‚úÖ Turnout 2 pin " + String(TURNOUT_PIN_2) + " set to LOW");
      }
      
      Serial.println("‚úÖ Turnout " + String(turnout_num + 1) + " moved to CLOSED");
    } else {
      Serial.println("‚ÑπÔ∏è Turnout " + String(turnout_num + 1) + " already in CLOSED position");
    }
    
  } else {
    Serial.println("‚ùå Unknown position specified in turnout control message: " + payload);
    Serial.println("=====================");
    return;
  }
  
  // Always publish status update after processing command
  Serial.println("üì§ Publishing status update...");
  publishTurnoutStatus(turnout_num + 1);
  
  if (state_changed) {
    Serial.println("üîÑ State changed, publishing to JMRI");
  } else {
    Serial.println("‚ÑπÔ∏è No state change, but still publishing status to JMRI");
  }
  
  Serial.println("=====================");
}

void handleSignalControl(String topic, String payload) {
  Serial.println("=== Signal Control ===");
  Serial.println("Topic: " + topic);
  Serial.println("Payload: " + payload);
  
  if (payload == "RED") {
    Serial.println("Requested aspect: RED");
    Serial.println("Current aspect: " + String(signal_state == 0 ? "red" : signal_state == 1 ? "yellow" : "green"));
    
    if (signal_state != 0) {
      signal_state = 0;
      digitalWrite(SIGNAL_PIN_RED, HIGH);
      digitalWrite(SIGNAL_PIN_YELLOW, LOW);
      digitalWrite(SIGNAL_PIN_GREEN, LOW);
      Serial.println("Signal pin " + String(SIGNAL_PIN_RED) + " set to HIGH (RED)");
      Serial.println("Signal pin " + String(SIGNAL_PIN_YELLOW) + " set to LOW");
      Serial.println("Signal pin " + String(SIGNAL_PIN_GREEN) + " set to LOW");
    }
    
    Serial.println("Signal changed from " + String(signal_state == 0 ? "red" : signal_state == 1 ? "yellow" : "green") + 
                  " to RED");
    
    // Publish status update
    publishSignalStatus();
  } else if (payload == "YELLOW") {
    Serial.println("Requested aspect: YELLOW");
    Serial.println("Current aspect: " + String(signal_state == 0 ? "red" : signal_state == 1 ? "yellow" : "green"));
    
    if (signal_state != 1) {
      signal_state = 1;
      digitalWrite(SIGNAL_PIN_RED, LOW);
      digitalWrite(SIGNAL_PIN_YELLOW, HIGH);
      digitalWrite(SIGNAL_PIN_GREEN, LOW);
      Serial.println("Signal pin " + String(SIGNAL_PIN_RED) + " set to LOW");
      Serial.println("Signal pin " + String(SIGNAL_PIN_YELLOW) + " set to HIGH (YELLOW)");
      Serial.println("Signal pin " + String(SIGNAL_PIN_GREEN) + " set to LOW");
    }
    
    Serial.println("Signal changed from " + String(signal_state == 0 ? "red" : signal_state == 1 ? "yellow" : "green") + 
                  " to YELLOW");
    
    // Publish status update
    publishSignalStatus();
  } else if (payload == "GREEN") {
    Serial.println("Requested aspect: GREEN");
    Serial.println("Current aspect: " + String(signal_state == 0 ? "red" : signal_state == 1 ? "yellow" : "green"));
    
    if (signal_state != 2) {
      signal_state = 2;
      digitalWrite(SIGNAL_PIN_RED, LOW);
      digitalWrite(SIGNAL_PIN_YELLOW, LOW);
      digitalWrite(SIGNAL_PIN_GREEN, HIGH);
      Serial.println("Signal pin " + String(SIGNAL_PIN_RED) + " set to LOW");
      Serial.println("Signal pin " + String(SIGNAL_PIN_YELLOW) + " set to LOW");
      Serial.println("Signal pin " + String(SIGNAL_PIN_GREEN) + " set to HIGH (GREEN)");
    }
    
    Serial.println("Signal changed from " + String(signal_state == 0 ? "red" : signal_state == 1 ? "yellow" : "green") + 
                  " to GREEN");
    
    // Publish status update
    publishSignalStatus();
  } else {
    Serial.println("‚ùå Unknown aspect specified in signal control message: " + payload);
  }
  Serial.println("===================");
}

void handleSensors() {
  // Read sensor states
  sensor_states[0] = !digitalRead(SENSOR_PIN_1); // Inverted due to pull-up
  sensor_states[1] = !digitalRead(SENSOR_PIN_2);
  sensor_states[2] = !digitalRead(SENSOR_PIN_3);
  sensor_states[3] = !digitalRead(SENSOR_PIN_4);
  
  // Check for changes and publish updates
  for (int i = 0; i < 4; i++) {
    if (sensor_states[i] != last_sensor_states[i]) {
      Serial.println("=== Sensor State Change ===");
      Serial.println("Sensor " + String(i + 1) + " changed from " + 
                    (last_sensor_states[i] ? "ACTIVE" : "INACTIVE") + 
                    " to " + (sensor_states[i] ? "ACTIVE" : "INACTIVE"));
      Serial.println("Pin: " + String(i == 0 ? SENSOR_PIN_1 : i == 1 ? SENSOR_PIN_2 : i == 2 ? SENSOR_PIN_3 : SENSOR_PIN_4));
      Serial.println("==========================");
      
      publishSensorStatus(i + 1);
      last_sensor_states[i] = sensor_states[i];
    }
  }
}

void publishSensorStatus(int sensor_num) {
  if (!mqtt_connected) return;
  
  // JMRI expects simple text messages, not JSON
  String state = sensor_states[sensor_num - 1] ? "ACTIVE" : "INACTIVE";
  String topic = mqtt_sensor_topic + String(sensor_num) + "/status";
  
  mqtt_client.publish(topic.c_str(), state.c_str());
  
  Serial.println("Published sensor " + String(sensor_num) + " status: " + state + " to topic: " + topic);
}

void publishTurnoutStatus(int turnout_num) {
  if (!mqtt_connected) return;
  
  // JMRI expects simple text messages, not JSON
  String position = turnout_states[turnout_num - 1] ? "THROWN" : "CLOSED";
  String topic = mqtt_turnout_topic + String(turnout_num) + "/status";
  
  mqtt_client.publish(topic.c_str(), position.c_str());
  
  Serial.println("Published turnout " + String(turnout_num) + " status: " + position + " to topic: " + topic);
}

void publishSignalStatus() {
  if (!mqtt_connected) return;
  
  // JMRI expects simple text messages, not JSON
  String aspect = (signal_state == 0) ? "RED" : (signal_state == 1) ? "YELLOW" : "GREEN";
  String topic = mqtt_signal_topic + "1/status";
  
  mqtt_client.publish(topic.c_str(), aspect.c_str());
  
  Serial.println("Published signal status: " + aspect + " to topic: " + topic);
}

void publishInitialStatus() {
  if (!mqtt_connected) return;
  
  Serial.println("=== Publishing Initial Status for All Devices to JMRI ===");
  
  // Publish individual sensor statuses
  for (int i = 1; i <= 4; i++) {
    publishSensorStatus(i);
    delay(100);  // Small delay between publishes
  }
  
  // Publish individual turnout statuses
  for (int i = 1; i <= 2; i++) {
    publishTurnoutStatus(i);
    delay(100);  // Small delay between publishes
  }
  
  // Publish signal status
  publishSignalStatus();
  
  // Publish overall device status
  publishStatus();
  
  Serial.println("=== Initial Status Published for All Devices to JMRI ===");
}

void publishAllDeviceStatus() {
  if (!mqtt_connected) return;
  
  Serial.println("=== Publishing All Device Status ===");
  
  // Publish individual sensor statuses
  for (int i = 1; i <= 4; i++) {
    publishSensorStatus(i);
    delay(100);  // Small delay between publishes
  }
  
  // Publish individual turnout statuses
  for (int i = 1; i <= 2; i++) {
    publishTurnoutStatus(i);
    delay(100);  // Small delay between publishes
  }
  
  // Publish signal status
  publishSignalStatus();
  
  // Publish overall device status
  publishStatus();
  
  Serial.println("=== All Device Status Published ===");
}

void publishStatus() {
  if (!mqtt_connected) return;
  
  Serial.println("=== Publishing Device Status ===");
  
  // JMRI expects simple text status, not JSON
  String status_msg = "Device: " + String(DEVICE_NAME) + 
                     ", Version: " + String(FIRMWARE_VERSION) + 
                     ", IP: " + WiFi.localIP().toString() + 
                     ", RSSI: " + String(WiFi.RSSI()) + " dBm" +
                     ", Uptime: " + String(millis()) + " ms";
  
  Serial.println("Device: " + String(DEVICE_NAME));
  Serial.println("Version: " + String(FIRMWARE_VERSION));
  Serial.println("IP: " + WiFi.localIP().toString());
  Serial.println("RSSI: " + String(WiFi.RSSI()) + " dBm");
  Serial.println("Uptime: " + String(millis()) + " ms");
  Serial.println("Sensors: " + String(sensor_states[0] ? "O" : "C") + " " + 
                String(sensor_states[1] ? "O" : "C") + " " + 
                String(sensor_states[2] ? "O" : "C") + " " + 
                String(sensor_states[3] ? "O" : "C") + " (O=Occupied, C=Clear)");
  Serial.println("Turnouts: " + String(turnout_states[0] ? "T" : "N") + " " + 
                String(turnout_states[1] ? "T" : "N") + " (T=Thrown, N=Normal)");
  Serial.println("Signal: " + String(signal_state == 0 ? "RED" : signal_state == 1 ? "YELLOW" : "GREEN"));
  
  mqtt_client.publish(mqtt_status_topic.c_str(), status_msg.c_str());
  
  Serial.println("Status published to topic: " + mqtt_status_topic);
  Serial.println("Message: " + status_msg);
  Serial.println("===============================");
}

void updateStatus() {
  if (mqtt_connected) {
    publishStatus();
  }
}

// Web server handlers
void handleRoot() {
  String html = "<!DOCTYPE html><html><head>";
  html += "<title>ESP32 JMRI Client</title>";
  html += "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">";
  html += "<style>";
  html += "body{font-family:Arial,sans-serif;margin:20px;background-color:#f5f5f5;}";
  html += ".container{max-width:800px;margin:0 auto;background:white;padding:20px;border-radius:8px;box-shadow:0 2px 10px rgba(0,0,0,0.1);}";
  html += "h1{color:#333;text-align:center;}";
  html += ".section{margin:20px 0;padding:20px;border:1px solid #ddd;border-radius:4px;}";
  html += ".form-group{margin-bottom:15px;}";
  html += "label{display:block;margin-bottom:5px;font-weight:bold;}";
  html += "input[type=text],input[type=password]{width:100%;padding:8px;border:1px solid #ddd;border-radius:4px;box-sizing:border-box;}";
  html += "button{background-color:#4CAF50;color:white;padding:10px 20px;border:none;border-radius:4px;cursor:pointer;margin:5px;}";
  html += "button:hover{background-color:#45a049;}";
  html += ".button-group{text-align:center;margin:20px 0;}";
  html += ".status{margin:10px 0;padding:10px;border-radius:4px;}";
  html += ".success{background-color:#d4edda;color:#155724;border:1px solid #c3e6cb;}";
  html += ".error{background-color:#f8d7da;color:#721c24;border:1px solid #f5c6cb;}";
  html += ".info{background-color:#d1ecf1;color:#0c5460;border:1px solid #bee5eb;}";
  html += "</style>";
  html += "</head><body>";
  html += "<div class=\"container\">";
  html += "<h1>ESP32 JMRI Client Configuration</h1>";
  html += "<div id=\"status\"></div>";
  
  // WiFi Configuration Section
  html += "<div class=\"section\">";
  html += "<h2>WiFi Configuration</h2>";
  html += "<form id=\"wifiForm\">";
  html += "<div class=\"form-group\">";
  html += "<label for=\"ssid\">WiFi SSID:</label>";
  html += "<input type=\"text\" id=\"ssid\" name=\"ssid\" value=\"" + wifi_ssid + "\" required>";
  html += "</div>";
  html += "<div class=\"form-group\">";
  html += "<label for=\"password\">WiFi Password:</label>";
  html += "<input type=\"password\" id=\"password\" name=\"password\" value=\"" + wifi_password + "\" required>";
  html += "</div>";
  html += "<button type=\"submit\">Update WiFi</button>";
  html += "</form>";
  html += "</div>";
  
  // MQTT Configuration Section
  html += "<div class=\"section\">";
  html += "<h2>MQTT Configuration</h2>";
  html += "<form id=\"mqttForm\">";
  html += "<div class=\"form-group\">";
  html += "<label for=\"mqtt_broker\">MQTT Broker IP:</label>";
  html += "<input type=\"text\" id=\"mqtt_broker\" name=\"mqtt_broker\" value=\"" + mqtt_broker_ip + "\" required>";
  html += "</div>";
  html += "<div class=\"form-group\">";
  html += "<label for=\"mqtt_port\">MQTT Port:</label>";
  html += "<input type=\"text\" id=\"mqtt_port\" name=\"mqtt_port\" value=\"" + String(mqtt_broker_port) + "\" required>";
  html += "</div>";
  html += "<div class=\"form-group\">";
  html += "<label for=\"mqtt_client_id\">Client ID:</label>";
  html += "<input type=\"text\" id=\"mqtt_client_id\" name=\"mqtt_client_id\" value=\"" + String(MQTT_CLIENT_ID) + "\" required>";
  html += "</div>";
  html += "<div class=\"form-group\">";
  html += "<label for=\"mqtt_topic_prefix\">Topic Prefix:</label>";
  html += "<input type=\"text\" id=\"mqtt_topic_prefix\" name=\"mqtt_topic_prefix\" value=\"" + String(MQTT_TOPIC_PREFIX) + "\" required>";
  html += "</div>";
  html += "<button type=\"submit\">Update MQTT</button>";
  html += "</form>";
  html += "</div>";
  
  // Action Buttons
  html += "<div class=\"button-group\">";
  html += "<button onclick=\"checkStatus()\">Check Status</button>";
  html += "<a href=\"/update\" style=\"text-decoration:none;\"><button type=\"button\" style=\"background-color:#2196F3;\">Firmware Update</button></a>";
  html += "</div>";
  
  html += "</div>";
  html += "<script>";
  html += "document.getElementById('wifiForm').onsubmit = function(e) {";
  html += "    e.preventDefault();";
  html += "    const formData = new FormData();";
  html += "    formData.append('ssid', document.getElementById('ssid').value);";
  html += "    formData.append('password', document.getElementById('password').value);";
  html += "    fetch('/configure', { method: 'POST', body: formData })";
  html += "    .then(response => response.text())";
  html += "    .then(data => {";
  html += "        document.getElementById('status').innerHTML = '<div class=\"status success\">' + data + '</div>';";
  html += "    })";
  html += "    .catch(error => {";
  html += "        document.getElementById('status').innerHTML = '<div class=\"status error\">Error: ' + error + '</div>';";
  html += "    });";
  html += "};";
  html += "document.getElementById('mqttForm').onsubmit = function(e) {";
  html += "    e.preventDefault();";
  html += "    const formData = new FormData();";
  html += "    formData.append('mqtt_broker', document.getElementById('mqtt_broker').value);";
  html += "    formData.append('mqtt_port', document.getElementById('mqtt_port').value);";
  html += "    formData.append('mqtt_client_id', document.getElementById('mqtt_client_id').value);";
  html += "    formData.append('mqtt_topic_prefix', document.getElementById('mqtt_topic_prefix').value);";
  html += "    fetch('/configure_mqtt', { method: 'POST', body: formData })";
  html += "    .then(response => response.text())";
  html += "    .then(data => {";
  html += "        document.getElementById('status').innerHTML = '<div class=\"status success\">' + data + '</div>';";
  html += "    })";
  html += "    .catch(error => {";
  html += "        document.getElementById('status').innerHTML = '<div class=\"status error\">Error: ' + error + '</div>';";
  html += "    });";
  html += "};";
  html += "function checkStatus() {";
  html += "    fetch('/status')";
  html += "    .then(response => response.text())";
  html += "    .then(data => {";
  html += "        document.getElementById('status').innerHTML = '<div class=\"status success\">' + data + '</div>';";
  html += "    })";
  html += "    .catch(error => {";
  html += "        document.getElementById('status').innerHTML = '<div class=\"status error\">Error: ' + error + '</div>';";
  html += "    });";
  html += "}";
  html += "</script>";
  html += "</body></html>";
  
  web_server.send(200, "text/html", html);
}

void handleWiFiConfig() {
  if (web_server.hasArg("ssid") && web_server.hasArg("password")) {
    String new_ssid = web_server.arg("ssid");
    String new_password = web_server.arg("password");
    
    // Save to preferences
    preferences.putString("wifi_ssid", new_ssid);
    preferences.putString("wifi_password", new_password);
    
    wifi_ssid = new_ssid;
    wifi_password = new_password;
    wifi_configured = true;
    
    // Restart WiFi connection
    WiFi.disconnect();
    delay(1000);
    WiFi.begin(wifi_ssid.c_str(), wifi_password.c_str());
    
    web_server.send(200, "text/plain", "WiFi configuration saved. Device will connect to the new network.");
  } else {
    web_server.send(400, "text/plain", "Missing SSID or password");
  }
}

void handleMQTTConfig() {
  if (web_server.hasArg("mqtt_broker") && web_server.hasArg("mqtt_port") && web_server.hasArg("mqtt_client_id") && web_server.hasArg("mqtt_topic_prefix")) {
    String new_broker = web_server.arg("mqtt_broker");
    int new_port = web_server.arg("mqtt_port").toInt();
    String new_client_id = web_server.arg("mqtt_client_id");
    String new_topic_prefix = web_server.arg("mqtt_topic_prefix");

    Serial.println("=== MQTT Configuration Update ===");
    Serial.println("New Broker: " + new_broker);
    Serial.println("New Port: " + String(new_port));
    Serial.println("New Client ID: " + new_client_id);
    Serial.println("New Topic Prefix: " + new_topic_prefix);

    // Save to preferences
    preferences.putString("mqtt_broker", new_broker);
    preferences.putInt("mqtt_port", new_port);
    preferences.putString("mqtt_client_id", new_client_id);
    preferences.putString("mqtt_topic_prefix", new_topic_prefix);

    // Update MQTT client settings
    mqtt_client.setServer(new_broker.c_str(), new_port);
    
    // Update our stored broker info
    mqtt_broker_ip = new_broker;
    mqtt_broker_port = new_port;
    
    // Update topic strings
    mqtt_base_topic = String(new_topic_prefix) + "/";
    mqtt_sensor_topic = mqtt_base_topic + "sensor/";
    mqtt_turnout_topic = mqtt_base_topic + "turnout/";
    mqtt_signal_topic = mqtt_base_topic + "signal/";
    mqtt_light_topic = mqtt_base_topic + "light/";
    mqtt_status_topic = mqtt_base_topic + "status/";

    Serial.println("Updated topic strings:");
    Serial.println("  Base: " + mqtt_base_topic);
    Serial.println("  Sensors: " + mqtt_sensor_topic);
    Serial.println("  Turnouts: " + mqtt_turnout_topic);
    Serial.println("  Signals: " + mqtt_signal_topic);
    Serial.println("  Status: " + mqtt_status_topic);

    // Disconnect current MQTT connection
    Serial.println("Disconnecting current MQTT connection...");
    mqtt_client.disconnect();
    mqtt_connected = false;
    delay(1000);
    
    // Try to reconnect with new settings
    Serial.println("Attempting to reconnect with new MQTT settings...");
    if (mqtt_client.connect(new_client_id.c_str())) {
      Serial.println("‚úÖ MQTT reconnected with new configuration successfully!");
      mqtt_connected = true;
      
      // Resubscribe to control topics
      String turnout_topic = mqtt_turnout_topic + "+";
      String signal_topic = mqtt_signal_topic + "+";
      
      Serial.println("Resubscribing to turnout topic: " + turnout_topic);
      mqtt_client.subscribe(turnout_topic.c_str());
      
      Serial.println("Resubscribing to signal topic: " + signal_topic);
      mqtt_client.subscribe(signal_topic.c_str());
      
      // Publish updated status
      Serial.println("Publishing updated status...");
      publishInitialStatus();
      
      Serial.println("=== MQTT Reconfiguration Complete ===");
    } else {
      Serial.println("‚ùå Failed to reconnect to MQTT with new configuration");
      Serial.printf("Error code: %d\n", mqtt_client.state());
      mqtt_connected = false;
    }

    web_server.send(200, "text/plain", "MQTT configuration saved. Device will reconnect to MQTT broker.");
  } else {
    web_server.send(400, "text/plain", "Missing MQTT configuration parameters");
  }
}

void handleStatus() {
  DynamicJsonDocument doc(512);
  doc["device"] = DEVICE_NAME;
  doc["version"] = FIRMWARE_VERSION;
  doc["wifi_connected"] = (WiFi.status() == WL_CONNECTED);
  doc["wifi_ssid"] = wifi_ssid;
  doc["ip_address"] = WiFi.localIP().toString();
  doc["mqtt_connected"] = mqtt_connected;
  
  // Add MQTT configuration info
  doc["mqtt_broker"] = preferences.getString("mqtt_broker", MQTT_BROKER);
  doc["mqtt_port"] = preferences.getInt("mqtt_port", MQTT_PORT);
  doc["mqtt_client_id"] = preferences.getString("mqtt_client_id", MQTT_CLIENT_ID);
  doc["mqtt_topic_prefix"] = preferences.getString("mqtt_topic_prefix", MQTT_TOPIC_PREFIX);
  
  doc["uptime"] = millis();
  
  String json_string;
  serializeJson(doc, json_string);
  
  web_server.send(200, "application/json", json_string);
}

void handleRestart() {
  web_server.send(200, "text/plain", "Device restarting...");
  delay(1000);
  ESP.restart();
}

void handleUpdatePage() {
  String html = "<!DOCTYPE html><html><head>";
  html += "<title>Firmware Update</title>";
  html += "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">";
  html += "<style>";
  html += "body{font-family:Arial,sans-serif;margin:20px;background-color:#f5f5f5;}";
  html += ".container{max-width:600px;margin:0 auto;background:white;padding:20px;border-radius:8px;box-shadow:0 2px 10px rgba(0,0,0,0.1);}";
  html += "h1{color:#333;text-align:center;}";
  html += ".upload-form{margin:20px 0;}";
  html += "input[type=file]{width:100%;padding:10px;margin:10px 0;border:2px dashed #ddd;border-radius:4px;}";
  html += "button{background-color:#4CAF50;color:white;padding:12px 24px;border:none;border-radius:4px;cursor:pointer;font-size:16px;width:100%;margin:10px 0;}";
  html += "button:hover{background-color:#45a049;}";
  html += "button:disabled{background-color:#cccccc;cursor:not-allowed;}";
  html += ".progress{width:100%;background-color:#f0f0f0;border-radius:4px;margin:10px 0;}";
  html += ".progress-bar{height:20px;background-color:#4CAF50;border-radius:4px;width:0%;transition:width 0.3s;}";
  html += ".status{text-align:center;margin:10px 0;padding:10px;border-radius:4px;}";
  html += ".success{background-color:#d4edda;color:#155724;border:1px solid #c3e6cb;}";
  html += ".error{background-color:#f8d7da;color:#721c24;border:1px solid #f5c6cb;}";
  html += ".info{background-color:#d1ecf1;color:#0c5460;border:1px solid #bee5eb;}";
  html += "</style>";
  html += "</head><body>";
  html += "<div class=\"container\">";
  html += "<h1>Firmware Update</h1>";
  html += "<div class=\"upload-form\">";
  html += "<input type=\"file\" id=\"firmware\" accept=\".bin\" onchange=\"validateFile(this)\">";
  html += "<button onclick=\"uploadFirmware()\" id=\"uploadBtn\" disabled>Upload Firmware</button>";
  html += "</div>";
  html += "<div class=\"progress\">";
  html += "<div class=\"progress-bar\" id=\"progressBar\"></div>";
  html += "</div>";
  html += "<div id=\"status\"></div>";
  html += "<div style=\"text-align:center;margin-top:20px;\">";
  html += "<a href=\"/\" style=\"color:#4CAF50;text-decoration:none;\">‚Üê Back to Main</a>";
  html += "</div>";
  html += "</div>";
  html += "<script>";
  html += "function validateFile(input) {";
  html += "    const file = input.files[0];";
  html += "    const uploadBtn = document.getElementById('uploadBtn');";
  html += "    if (file && file.name.endsWith('.bin')) {";
  html += "        uploadBtn.disabled = false;";
  html += "        document.getElementById('status').innerHTML = '<div class=\"status info\">File selected: ' + file.name + ' (' + (file.size / 1024).toFixed(1) + ' KB)</div>';";
  html += "    } else {";
  html += "        uploadBtn.disabled = true;";
  html += "        document.getElementById('status').innerHTML = '<div class=\"status error\">Please select a valid .bin file</div>';";
  html += "    }";
  html += "}";
  html += "function uploadFirmware() {";
  html += "    const fileInput = document.getElementById('firmware');";
  html += "    const file = fileInput.files[0];";
  html += "    if (!file) return;";
  html += "    ";
  html += "    const uploadBtn = document.getElementById('uploadBtn');";
  html += "    const statusDiv = document.getElementById('status');";
  html += "    const progressBar = document.getElementById('progressBar');";
  html += "    ";
  html += "    uploadBtn.disabled = true;";
  html += "    statusDiv.innerHTML = '<div class=\"status info\">Starting upload...</div>';";
      html += "    progressBar.style.width = '0%';";
    html += "    ";
    html += "    const formData = new FormData();";
  html += "    formData.append('firmware', file);";
  html += "    ";
  html += "    const xhr = new XMLHttpRequest();";
  html += "    ";
  html += "    xhr.upload.addEventListener('progress', function(e) {";
  html += "        if (e.lengthComputable) {";
  html += "            const percentComplete = (e.loaded / e.total) * 100;";
  html += "            progressBar.style.width = percentComplete + '%';";
  html += "            statusDiv.innerHTML = '<div class=\"status info\">Uploading: ' + Math.round(percentComplete) + '%</div>';";
  html += "        }";
  html += "    });";
  html += "    ";
  html += "    xhr.addEventListener('load', function() {";
  html += "        if (xhr.status === 200) {";
  html += "            statusDiv.innerHTML = '<div class=\"status success\">Upload completed! Device will restart in 5 seconds...</div>';";
  html += "            progressBar.style.width = '100%';";
  html += "            setTimeout(() => {";
  html += "                window.location.href = '/';";
  html += "            }, 5000);";
  html += "        } else {";
  html += "            statusDiv.innerHTML = '<div class=\"status error\">Upload failed: ' + xhr.responseText + '</div>';";
  html += "            uploadBtn.disabled = false;";
  html += "        }";
  html += "    });";
  html += "    ";
  html += "    xhr.addEventListener('error', function() {";
  html += "        statusDiv.innerHTML = '<div class=\"status error\">Upload failed: Network error</div>';";
  html += "        uploadBtn.disabled = false;";
  html += "    });";
  html += "    ";
  html += "    xhr.open('POST', '/do_update');";
  html += "    xhr.send(formData);";
  html += "}";
  html += "</script>";
  html += "</body></html>";
  
  web_server.send(200, "text/html", html);
}

void handleDoUpdate() {
  web_server.sendHeader("Connection", "close");
  
  if (Update.hasError()) {
    String error_msg = "Update failed: " + String(Update.errorString());
    Serial.println(error_msg);
    web_server.send(500, "text/plain", error_msg);
  } else {
    Serial.println("Update successful, restarting device...");
    web_server.send(200, "text/plain", "Update successful! Device will restart in 3 seconds...");
    delay(3000);
    ESP.restart();
  }
}

void handleUpdateBody() {
  HTTPUpload& upload = web_server.upload();
  
  if (upload.status == UPLOAD_FILE_START) {
    Serial.println("=== OTA Update Started ===");
    Serial.println("File name: " + upload.filename);
    
    // Check if we have enough free space
    size_t freeSpace = ESP.getFreeSketchSpace();
    Serial.println("Free sketch space: " + String(freeSpace) + " bytes");
    
    if (freeSpace < 100000) {  // Less than 100KB free
      Serial.println("‚ùå Error: Insufficient free space for update");
      return;
    }
    
    // Start the update process
    if (!Update.begin(freeSpace - 0x1000)) {
      Serial.println("‚ùå Error: Update.begin() failed");
      Serial.println("Update error: " + String(Update.getError()));
      return;
    }
    
    Serial.println("‚úÖ Update started successfully");
    Serial.println("Expected size: " + String(Update.size()) + " bytes");
    
  } else if (upload.status == UPLOAD_FILE_WRITE) {
    if (upload.buf == nullptr) {
      Serial.println("‚ùå Error: Upload buffer is null");
      return;
    }
    
    if (Update.write(upload.buf, upload.currentSize) != upload.currentSize) {
      Serial.println("‚ùå Error: Update.write() failed");
      Serial.println("Update error: " + String(Update.getError()));
      return;
    }
    
    // Calculate progress
    size_t progress = (Update.progress() * 100) / Update.size();
    Serial.println("üì§ Chunk written: " + String(upload.currentSize) + " bytes");
    Serial.println("üìä Progress: " + String(progress) + "%");
    
  } else if (upload.status == UPLOAD_FILE_END) {
    if (Update.end()) {
      Serial.println("‚úÖ Update completed successfully!");
      Serial.println("Final size: " + String(Update.size()) + " bytes");
      
      // Verify the update
      if (Update.hasError()) {
        Serial.println("‚ùå Update verification failed");
        Serial.println("Error: " + String(Update.getError()));
        return;
      }
      
      Serial.println("üîÑ Restarting device in 3 seconds...");
      delay(3000);
      ESP.restart();
      
    } else {
      Serial.println("‚ùå Error: Update.end() failed");
      Serial.println("Update error: " + String(Update.getError()));
    }
  }
}
