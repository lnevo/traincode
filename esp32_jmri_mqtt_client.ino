/*
 * ESP32 JMRI MQTT Client
 * 
 * This project provides an ESP32-based MQTT client for interfacing with JMRI
 * for model railroad control. Features include:
 * - Sensor feedback detection
 * - Turnout control
 * - Signal control
 * - OTA updates
 * - WiFi configuration via web interface
 * - MQTT communication with JMRI
 * 
 * Author: Generated by AI Assistant
 * Date: 2024
 */

#include "config.h"
#include <WiFi.h>
#include <esp_wifi.h>
#include <PubSubClient.h>
#include <ArduinoJson.h>
#include <WebServer.h>
#include <Update.h>
#include <SPIFFS.h>
#include <Preferences.h>
#include <ArduinoOTA.h>
#include <ESPmDNS.h>
#include "html_content.h"

// WiFi configuration
String default_ssid = "";  // Will be set in setup using MAC address
const char* default_password = DEFAULT_PASSWORD;
String wifi_ssid = "";
String wifi_password = "";

// Function to get unique SSID suffix from MAC address
String getUniqueId() {
  uint8_t mac[6];
  WiFi.softAPmacAddress(mac);  // Get AP MAC address specifically
  
  // Use last 4 digits of MAC
  char suffix[5];
  snprintf(suffix, sizeof(suffix), "%02X%02X", mac[4], mac[5]);
  Serial.printf("Using last 4 digits of AP MAC: %s\n", suffix);
  
  return String(suffix);
}

// MQTT topics - Updated to match JMRI format
String mqtt_base_topic = String(MQTT_TOPIC_PREFIX) + "/";
String mqtt_sensor_topic = mqtt_base_topic + "sensor/";
String mqtt_turnout_topic = mqtt_base_topic + "turnout/";
String mqtt_light_topic = mqtt_base_topic + "light/";  // Changed from signal to light
String mqtt_status_topic = mqtt_base_topic + "status/";

// Global objects
WiFiClient espClient;
PubSubClient mqtt_client(espClient);
WebServer web_server(80);
Preferences preferences;

// MQTT broker info storage
String mqtt_broker_ip = "";
String mqtt_broker_hostname = "";  // For mDNS hostname like "rpi-jmri.local"
int mqtt_broker_port = 0;
String mqtt_channel_name = "";

// Function to resolve mDNS hostname to IP
bool resolveMDNSHost(const char* hostname) {
  Serial.printf("Resolving mDNS hostname: %s\n", hostname);
  
  // Remove .local suffix if present
  String host = String(hostname);
  if (host.endsWith(".local")) {
    host = host.substring(0, host.length() - 6);
  }
  
  // Try to resolve hostname
  IPAddress ip = MDNS.queryHost(host.c_str(), 5000);
  if (ip.toString() != "0.0.0.0") {
    mqtt_broker_ip = ip.toString();
    Serial.printf("Resolved %s to IP: %s\n", hostname, mqtt_broker_ip.c_str());
    return true;
  }
  
  Serial.printf("Failed to resolve %s\n", hostname);
  return false;
}

// State variables
bool wifi_configured = false;
bool mqtt_connected = false;
unsigned long last_mqtt_attempt = 0;
// Removed periodic status publishing - only publish on state changes

// Sensor states
bool sensor_states[4] = {false, false, false, false};  // Changed from 3 to 4 sensors
bool last_sensor_states[4] = {false, false, false, false};

// Turnout states
bool turnout_states[2] = {false, false};  // false = CLOSED, true = THROWN
bool last_turnout_states[2] = {false, false};

// Global state variables for lights (6 individual lights)
bool light_states[6] = {false, false, false, false, false, false};  // 6 individual lights
bool last_light_states[6] = {false, false, false, false, false, false};

void displaySystemInfo() {
  Serial.println("=== System Information ===");
  Serial.println("Device: " + String(DEVICE_NAME));
  Serial.println("Firmware Version: " + String(FIRMWARE_VERSION));
  Serial.println("Free Sketch Space: " + String(ESP.getFreeSketchSpace()) + " bytes");
  Serial.println("Free Heap: " + String(ESP.getFreeHeap()) + " bytes");
  Serial.println("Flash Chip Size: " + String(ESP.getFlashChipSize()) + " bytes");
  Serial.println("Max OTA Size: " + String(ESP.getFreeSketchSpace() - 0x1000) + " bytes");
  Serial.println("SDK Version: " + String(ESP.getSdkVersion()));
  Serial.println("CPU Frequency: " + String(ESP.getCpuFreqMHz()) + " MHz");
  Serial.println("===============================");
}

void setup() {
  Serial.begin(SERIAL_BAUD_RATE);
  Serial.println("\n\n=== ESP32 JMRI MQTT Client ===");
  Serial.println("Firmware Version: " + String(FIRMWARE_VERSION));
  
  // Initialize WiFi early
  WiFi.mode(WIFI_MODE_APSTA);
  delay(100);  // Give WiFi time to initialize
  
  // Debug WiFi status
  Serial.println("=== WiFi Debug Info ===");
  Serial.print("WiFi Mode: ");
  switch(WiFi.getMode()) {
    case WIFI_MODE_NULL: Serial.println("NULL"); break;
    case WIFI_MODE_STA: Serial.println("STA"); break;
    case WIFI_MODE_AP: Serial.println("AP"); break;
    case WIFI_MODE_APSTA: Serial.println("AP+STA"); break;
    default: Serial.println("UNKNOWN"); break;
  }
  
  // Get and display raw MAC address
  uint8_t mac[6];
  WiFi.macAddress(mac);
  Serial.print("STA MAC Address: ");
  for (int i = 0; i < 6; i++) {
    Serial.printf("%02X", mac[i]);
    if (i < 5) Serial.print(":");
  }
  Serial.println();
  
  WiFi.softAPmacAddress(mac);
  Serial.print("AP MAC Address:  ");
  for (int i = 0; i < 6; i++) {
    Serial.printf("%02X", mac[i]);
    if (i < 5) Serial.print(":");
  }
  Serial.println();
  
  // Get unique ID and set SSID
  String uniqueId = getUniqueId();
  default_ssid = String(DEFAULT_SSID) + "_" + uniqueId;
  Serial.println("Device Unique ID: " + uniqueId);
  Serial.println("AP SSID will be: " + default_ssid);
  
  // Display system information
  displaySystemInfo();
  
  // Initialize pins
  setupPins();
  
  // Initialize SPIFFS
  if (!SPIFFS.begin(true)) {
    Serial.println("SPIFFS initialization failed");
  }
  
  // Initialize preferences
  preferences.begin("jmri_client", false);
  
  // Load saved WiFi credentials
  loadWiFiCredentials();
  
  // Load saved MQTT credentials
  loadMQTTCredentials();
  
  // Setup WiFi
  setupWiFi();
  
  // Wait for WiFi to stabilize
  if (WiFi.status() == WL_CONNECTED) {
    delay(2000);  // Give WiFi time to stabilize
    Serial.println("WiFi connected, attempting MQTT connection...");
    
    // Now setup MQTT with the loaded credentials
  setupMQTT();
    
    // Test broker connectivity before attempting connection
    testMQTTBrokerConnectivity();
    
    // Attempt initial MQTT connection
    Serial.println("Attempting initial MQTT connection...");
    mqttReconnect();
  } else {
    // If WiFi didn't connect, still setup MQTT for when it does connect
    setupMQTT();
  }
  
  // Setup web server for configuration
  setupWebServer();
  
  // Setup OTA
  setupOTA();
  
  Serial.println("Setup complete!");
}

void loop() {
  // Feed the watchdog to prevent resets
  yield();
  
  // Handle WiFi
  if (WiFi.status() != WL_CONNECTED) {
    handleWiFiReconnection();
  }
  
  // Handle MQTT
  if (WiFi.status() == WL_CONNECTED) {
    handleMQTT();
  }
  
  // Handle sensors
  handleSensors();
  
  // Handle web server
  web_server.handleClient();
  
  // Handle OTA
  ArduinoOTA.handle();
  
  // Only publish device status when states actually change
  // Removed periodic status publishing - JMRI only needs state change notifications
  
  // Connection status (keep minimal logging)
  static unsigned long last_connection_log = 0;
  if (millis() - last_connection_log > 60000) { // Log every minute
    if (WiFi.status() == WL_CONNECTED) {
      Serial.println("SSID: " + WiFi.SSID());
      Serial.println("IP: " + WiFi.localIP().toString());
      Serial.println("RSSI: " + String(WiFi.RSSI()) + " dBm");
    }
    Serial.println("MQTT Status: " + String(mqtt_connected ? "Connected" : "Disconnected"));
    if (mqtt_connected) {
      Serial.println("Broker: " + mqtt_broker_ip + ":" + String(mqtt_broker_port));
    }
    last_connection_log = millis();
  }
  
  delay(10);
}

void setupPins() {
  // Configure turnout pins as outputs
  pinMode(TURNOUT_PIN_1, OUTPUT);
  pinMode(TURNOUT_PIN_2, OUTPUT);
  
  // Configure individual light pins as outputs
  pinMode(LIGHT_PIN_1, OUTPUT);
  pinMode(LIGHT_PIN_2, OUTPUT);
  pinMode(LIGHT_PIN_3, OUTPUT);
  pinMode(LIGHT_PIN_4, OUTPUT);
  pinMode(LIGHT_PIN_5, OUTPUT);
  pinMode(LIGHT_PIN_6, OUTPUT);
  
  // Configure sensor pins as inputs with pull-up resistors
  pinMode(SENSOR_PIN_1, INPUT_PULLUP);
  pinMode(SENSOR_PIN_2, INPUT_PULLUP);
  pinMode(SENSOR_PIN_3, INPUT_PULLUP);
  pinMode(SENSOR_PIN_4, INPUT_PULLUP);
  
  // Configure status LED
  pinMode(STATUS_LED, OUTPUT);
  
  // Set initial states
  digitalWrite(TURNOUT_PIN_1, LOW);   // CLOSED
  digitalWrite(TURNOUT_PIN_2, LOW);   // CLOSED
  
  // Set all lights to OFF initially
  digitalWrite(LIGHT_PIN_1, LOW);
  digitalWrite(LIGHT_PIN_2, LOW);
  digitalWrite(LIGHT_PIN_3, LOW);
  digitalWrite(LIGHT_PIN_4, LOW);
  digitalWrite(LIGHT_PIN_5, LOW);
  digitalWrite(LIGHT_PIN_6, LOW);
  
  digitalWrite(STATUS_LED, HIGH);  // Status LED ON
  
  Serial.println("Pins configured for 2 turnouts, 6 individual lights, and 4 sensors");
}

void loadWiFiCredentials() {
  wifi_ssid = preferences.getString("wifi_ssid", "");
  wifi_password = preferences.getString("wifi_password", "");
  wifi_configured = (wifi_ssid.length() > 0);
  
  if (wifi_configured) {
    Serial.println("Loaded saved WiFi credentials for: " + wifi_ssid);
  } else {
    Serial.println("No saved WiFi credentials found");
  }
}

void loadMQTTCredentials() {
  Serial.println("=== Loading MQTT Credentials ===");
  
  // Load MQTT settings from preferences with defaults from config.h
  String broker = preferences.getString("mqtt_broker", MQTT_BROKER);
  int port = preferences.getInt("mqtt_port", MQTT_PORT);
  String client_id = preferences.getString("mqtt_client_id", MQTT_CLIENT_ID);
  String channel_name = preferences.getString("mqtt_channel_name", MQTT_CHANNEL_NAME);
  String topic_prefix = preferences.getString("mqtt_topic_prefix", MQTT_TOPIC_PREFIX);
  
  Serial.println("Loaded configuration:");
  Serial.println("  Broker: " + broker + (broker == MQTT_BROKER ? " (default)" : " (saved)"));
  Serial.println("  Port: " + String(port) + (port == MQTT_PORT ? " (default)" : " (saved)"));
  Serial.println("  Client ID: " + client_id + (client_id == MQTT_CLIENT_ID ? " (default)" : " (saved)"));
  Serial.println("  Channel Name: " + channel_name + (channel_name == MQTT_CHANNEL_NAME ? " (default)" : " (saved)"));
  Serial.println("  Topic Prefix: " + topic_prefix + (topic_prefix == MQTT_TOPIC_PREFIX ? " (default)" : " (saved)"));
  
  // Update MQTT client settings
  mqtt_broker_ip = broker;
  mqtt_broker_port = port;
  mqtt_channel_name = channel_name;
  
  // Update topic strings with channel name prefix
  String channel_prefix = mqtt_channel_name;
  if (!channel_prefix.startsWith("/")) {
    channel_prefix = "/" + channel_prefix;
  }
  mqtt_base_topic = channel_prefix + String(topic_prefix) + "/";
  mqtt_sensor_topic = mqtt_base_topic + "sensor/";
  mqtt_turnout_topic = mqtt_base_topic + "turnout/";
  mqtt_light_topic = mqtt_base_topic + "light/";
  mqtt_status_topic = mqtt_base_topic + "status/";
  
  Serial.println("Updated topic strings:");
  Serial.println("  Base: " + mqtt_base_topic);
  Serial.println("  Sensors: " + mqtt_sensor_topic);
  Serial.println("  Turnouts: " + mqtt_turnout_topic);
  Serial.println("  Signals: " + mqtt_light_topic); // Changed from signal to light
  Serial.println("  Status: " + mqtt_status_topic);
  
  Serial.println("===============================");
}

void setupWiFi() {
  if (wifi_configured) {
    // Try to connect to saved network
    Serial.println("=== WiFi Setup ===");
    Serial.println("Attempting to connect to saved WiFi network: " + wifi_ssid);
    Serial.println("WiFi mode: Station");
    
    WiFi.mode(WIFI_STA);
    WiFi.begin(wifi_ssid.c_str(), wifi_password.c_str());
    
    int attempts = 0;
    while (WiFi.status() != WL_CONNECTED && attempts < WIFI_MAX_ATTEMPTS) {
      delay(500);
      Serial.print(".");
      attempts++;
    }
    
    if (WiFi.status() == WL_CONNECTED) {
      Serial.println("\n‚úÖ WiFi connected successfully!");
      Serial.println("SSID: " + WiFi.SSID());
      Serial.println("IP address: " + WiFi.localIP().toString());
      Serial.println("Gateway: " + WiFi.gatewayIP().toString());
      Serial.println("DNS: " + WiFi.dnsIP().toString());
      Serial.println("RSSI: " + String(WiFi.RSSI()) + " dBm");
      Serial.println("Channel: " + String(WiFi.channel()));
      digitalWrite(STATUS_LED, HIGH);
      Serial.println("=== WiFi Setup Complete ===");
    } else {
      Serial.println("\n‚ùå Failed to connect to saved WiFi");
      Serial.println("WiFi status: " + String(WiFi.status()));
      wifi_configured = false;
    }
  }
  
  if (!wifi_configured) {
    // Start configuration mode
    Serial.println("=== Starting WiFi Configuration Mode ===");
    WiFi.mode(WIFI_AP);
    WiFi.softAP(default_ssid.c_str(), default_password);
    Serial.println("AP SSID: " + String(default_ssid));
    Serial.println("AP Password: " + String(default_password));
    Serial.println("AP IP address: " + WiFi.softAPIP().toString());
    Serial.println("Connect to '" + String(default_ssid) + "' network with password '" + String(default_password) + "'");
    Serial.println("Then navigate to http://" + WiFi.softAPIP().toString() + " to configure");
    Serial.println("=== WiFi Configuration Mode Active ===");
  }
}

void setupMQTT() {
  Serial.println("=== Setting up MQTT ===");
  
  // Initialize mDNS if not already done
  if (!MDNS.begin("esp32-jmri-client")) {
    Serial.println("Error setting up mDNS responder");
  }
  
  // If we have a hostname, try to resolve it
  if (mqtt_broker_hostname.length() > 0) {
    if (resolveMDNSHost(mqtt_broker_hostname.c_str())) {
      Serial.println("Successfully resolved hostname to IP");
    } else {
      Serial.println("Warning: Could not resolve hostname, will try direct IP");
    }
  }
  
  Serial.println("Using configuration:");
  Serial.println("  Broker: " + (mqtt_broker_hostname.length() > 0 ? mqtt_broker_hostname : mqtt_broker_ip));
  Serial.println("  IP: " + mqtt_broker_ip);
  Serial.println("  Port: " + String(mqtt_broker_port));
  Serial.println("  Client ID: " + String(MQTT_CLIENT_ID));
  Serial.println("  Channel Name: " + mqtt_channel_name);
  Serial.println("  Topic Prefix: " + String(MQTT_TOPIC_PREFIX));
  
  // Update MQTT client settings
  mqtt_client.setServer(mqtt_broker_ip.c_str(), mqtt_broker_port);
  mqtt_client.setCallback(mqttCallback);
  mqtt_client.setKeepAlive(60);
  mqtt_client.setSocketTimeout(30);
  
  // Update topic strings with current values including channel name
  String channel_prefix = mqtt_channel_name;
  if (!channel_prefix.startsWith("/")) {
    channel_prefix = "/" + channel_prefix;
  }
  mqtt_base_topic = channel_prefix + String(MQTT_TOPIC_PREFIX) + "/";
  mqtt_sensor_topic = mqtt_base_topic + "sensor/";
  mqtt_turnout_topic = mqtt_base_topic + "turnout/";
  mqtt_light_topic = mqtt_base_topic + "light/";
  mqtt_status_topic = mqtt_base_topic + "status/";
  
  Serial.println("Final MQTT configuration:");
  Serial.println("  Broker: " + mqtt_broker_ip + ":" + String(mqtt_broker_port));
  Serial.println("  Base Topic: " + mqtt_base_topic);
  Serial.println("  Sensor Topic: " + mqtt_sensor_topic);
  Serial.println("  Turnout Topic: " + mqtt_turnout_topic);
  Serial.println("  Signal Topic: " + mqtt_light_topic); // Changed from signal to light
  Serial.println("  Status Topic: " + mqtt_status_topic);
  Serial.println("===============================");
}

void setupWebServer() {
  // Configuration page
  web_server.on("/", HTTP_GET, handleRoot);
  web_server.on("/configure", HTTP_POST, handleWiFiConfig);
  web_server.on("/configure_mqtt", HTTP_POST, handleMQTTConfig); // New handler for MQTT config
  web_server.on("/status", HTTP_GET, handleStatus);
  web_server.on("/control", HTTP_POST, handleDeviceControl); // Device control endpoint
  web_server.on("/restart", HTTP_POST, handleRestart);
  web_server.on("/reset", HTTP_POST, handleReset);
  web_server.on("/backup", HTTP_GET, handleBackup);
  web_server.on("/restore", HTTP_POST, handleRestore);
  web_server.on("/save_device_labels", HTTP_POST, handleSaveDeviceLabels);
  
  // Test endpoint for debugging
  web_server.on("/test", HTTP_GET, []() {
    web_server.send(200, "text/plain", "Web server is working! Firmware version: " + String(FIRMWARE_VERSION));
  });
  
  // OTA update page

  web_server.on("/doUpdate", HTTP_POST, handleDoUpdate, handleUpdateBody);
  
  // Add missing endpoints that the HTML expects
  web_server.on("/devices", HTTP_GET, handleDevices);
  web_server.on("/wifi", HTTP_POST, handleWiFiConfig);
  web_server.on("/mqtt", HTTP_POST, handleMQTTConfig);
  web_server.on("/config", HTTP_GET, handleConfig);
  web_server.on("/upload", HTTP_POST, handleDoUpdate, handleUpdateBody);
  
  web_server.begin();
  Serial.println("Web server started");
}

void setupOTA() {
  Serial.println("Setting up OTA...");
  
  ArduinoOTA.setHostname(DEVICE_NAME);
  ArduinoOTA.setPassword("admin");
  
  // Set OTA port (default is 3232)
  ArduinoOTA.setPort(3232);
  
  ArduinoOTA.onStart([]() {
    Serial.println("=== OTA Update Started ===");
    Serial.println("Disabling watchdog during update...");
    digitalWrite(STATUS_LED, LOW);
  });
  
  ArduinoOTA.onProgress([](unsigned int progress, unsigned int total) {
    Serial.printf("OTA Progress: %u%%\n", (progress / (total / 100)));
    // Feed watchdog during progress
    yield();
  });
  
  ArduinoOTA.onEnd([]() {
    Serial.println("=== OTA Update Completed ===");
    Serial.println("Update successful, restarting...");
    digitalWrite(STATUS_LED, HIGH);
  });
  
  ArduinoOTA.onError([](ota_error_t error) {
    Serial.printf("=== OTA Error: %u ===\n", error);
    Serial.println("Error details:");
    switch (error) {
      case OTA_AUTH_ERROR:
        Serial.println("Auth Failed");
        break;
      case OTA_BEGIN_ERROR:
        Serial.println("Begin Failed");
        break;
      case OTA_CONNECT_ERROR:
        Serial.println("Connect Failed");
        break;
      case OTA_RECEIVE_ERROR:
        Serial.println("Receive Failed");
        break;
      case OTA_END_ERROR:
        Serial.println("End Failed");
        break;
      default:
        Serial.println("Unknown Error");
        break;
    }
    digitalWrite(STATUS_LED, LOW);
  });
  
  ArduinoOTA.begin();
  Serial.println("OTA ready on port 3232");
  Serial.println("You can also use Arduino IDE or other OTA tools to update");
}

void handleWiFiReconnection() {
  static unsigned long last_reconnect_attempt = 0;
  unsigned long current_time = millis();
  
  if (current_time - last_reconnect_attempt > WIFI_RECONNECT_INTERVAL) { // Try every 30 seconds
    Serial.println("Attempting WiFi reconnection...");
    WiFi.reconnect();
    last_reconnect_attempt = current_time;
  }
}

void handleMQTT() {
  if (!mqtt_client.connected()) {
    if (millis() - last_mqtt_attempt > MQTT_RETRY_INTERVAL) {
      Serial.println("üîç DEBUG: MQTT disconnected, calling mqttReconnect() from handleMQTT()");
      mqttReconnect();
      last_mqtt_attempt = millis();
    }
  } else {
    mqtt_client.loop();
  }
}

void testMQTTBrokerConnectivity() {
  Serial.println("=== Testing MQTT Broker Connectivity ===");
  Serial.println("Broker: " + mqtt_broker_ip + ":" + String(mqtt_broker_port));
  
  // Create a temporary WiFi client to test connectivity
  WiFiClient testClient;
  
  Serial.println("Attempting TCP connection to broker...");
  if (testClient.connect(mqtt_broker_ip.c_str(), mqtt_broker_port)) {
    Serial.println("‚úÖ TCP connection to broker successful");
    Serial.println("Broker is reachable on the network");
    testClient.stop();
  } else {
    Serial.println("‚ùå TCP connection to broker failed");
    Serial.println("Broker may be unreachable or port may be blocked");
    Serial.println("Check:");
    Serial.println("  - Broker IP address is correct");
    Serial.println("  - Broker is running and listening on port " + String(mqtt_broker_port));
    Serial.println("  - Network firewall allows connections to this port");
    Serial.println("  - WiFi network can reach the broker subnet");
  }
  Serial.println("===============================");
}

void mqttReconnect() {
  Serial.println("üîç DEBUG: mqttReconnect() called at " + String(millis()) + " ms");
  Serial.println("=== Attempting MQTT Connection ===");
  Serial.println("Broker: " + mqtt_broker_ip);
  Serial.println("Port: " + String(mqtt_broker_port));
  Serial.println("Client ID: " + String(MQTT_CLIENT_ID));
  Serial.println("WiFi Status: " + String(WiFi.status()));
  Serial.println("WiFi IP: " + WiFi.localIP().toString());
  
  if (mqtt_client.connect(MQTT_CLIENT_ID)) {
    Serial.println("‚úÖ MQTT connected successfully!");
    mqtt_connected = true;
    
    // Subscribe to control topics (not status topics to avoid feedback loops)
    String turnout_topic = mqtt_turnout_topic + "+";
    String sensor_topic = mqtt_sensor_topic + "+";
    String light_topic = mqtt_light_topic + "+";
    
    Serial.println("Subscribing to turnout topic: " + turnout_topic);
    mqtt_client.subscribe(turnout_topic.c_str());
    
    Serial.println("Subscribing to sensor topic: " + sensor_topic);
    mqtt_client.subscribe(sensor_topic.c_str());
    
    Serial.println("Subscribing to light topic: " + light_topic);
    mqtt_client.subscribe(light_topic.c_str());
    
    Serial.println("Subscriptions completed");
    
    // Request retained messages for initial state sync
    Serial.println("Requesting retained messages for state synchronization...");
    delay(1000); // Give broker time to send retained messages
    
    // Process retained messages multiple times to ensure we get them all
    for (int i = 0; i < 10; i++) {
      mqtt_client.loop();
      delay(100);
    }
    
    Serial.println("=== Current States After MQTT Sync ===");
    Serial.println("Turnout 1: " + String(turnout_states[0] ? "THROWN" : "CLOSED"));
    Serial.println("Turnout 2: " + String(turnout_states[1] ? "THROWN" : "CLOSED"));
    Serial.println("Turnouts: " + String(turnout_states[0] ? "THROWN" : "CLOSED") + " / " + String(turnout_states[1] ? "THROWN" : "CLOSED"));
    Serial.println("Lights: " + String(light_states[0] ? "ON" : "OFF") + " " + String(light_states[1] ? "ON" : "OFF") + " " + String(light_states[2] ? "ON" : "OFF") + " " + String(light_states[3] ? "ON" : "OFF") + " " + String(light_states[4] ? "ON" : "OFF") + " " + String(light_states[5] ? "ON" : "OFF"));
    Serial.println("=====================================");
    
    // Skip initial status publish - we now sync from retained messages
    // The ESP32 state is now controlled by JMRI via retained messages
    Serial.println("Skipping initial status publish - using retained message states");
    
    Serial.println("=== MQTT Setup Complete ===");
  } else {
    Serial.printf("‚ùå MQTT connection failed, rc=%d\n", mqtt_client.state());
    Serial.println("Error codes:");
    Serial.println("  -4: MQTT_CONNECTION_TIMEOUT");
    Serial.println("  -3: MQTT_CONNECTION_LOST");
    Serial.println("  -2: MQTT_CONNECT_FAILED");
    Serial.println("  -1: MQTT_DISCONNECTED");
    Serial.println("   0: MQTT_CONNECTED");
    Serial.println("   1: MQTT_CONNECT_BAD_PROTOCOL");
    Serial.println("   2: MQTT_CONNECT_BAD_CLIENT_ID");
    Serial.println("   3: MQTT_CONNECT_UNAVAILABLE");
    Serial.println("   4: MQTT_CONNECT_BAD_CREDENTIALS");
    Serial.println("   5: MQTT_CONNECT_UNAUTHORIZED");
    mqtt_connected = false;
  }
}

// Track our own recent publications to prevent feedback loops
struct RecentPublication {
  String topic;
  String payload;
  unsigned long timestamp;
};

RecentPublication recent_pubs[10];  // Track last 10 publications
int recent_pub_index = 0;

void trackPublication(String topic, String payload) {
  recent_pubs[recent_pub_index].topic = topic;
  recent_pubs[recent_pub_index].payload = payload;
  recent_pubs[recent_pub_index].timestamp = millis();
  recent_pub_index = (recent_pub_index + 1) % 10;
}

bool isOurOwnMessage(String topic, String payload) {
  unsigned long now = millis();
  for (int i = 0; i < 10; i++) {
    if (recent_pubs[i].topic == topic && 
        recent_pubs[i].payload == payload && 
        (now - recent_pubs[i].timestamp) < 2000) {  // Within 2 seconds
      return true;
    }
  }
  return false;
}

void mqttCallback(char* topic, byte* payload, unsigned int length) {
  String topic_str = String(topic);
  String payload_str = "";
  
  for (int i = 0; i < length; i++) {
    payload_str += (char)payload[i];
  }
  
  Serial.println("=== MQTT Message Received ===");
  Serial.println("  Topic: " + topic_str);
  Serial.println("  Payload: " + payload_str);
  Serial.println("  Length: " + String(length) + " bytes");
  Serial.println("  From Broker: " + mqtt_broker_ip + ":" + String(mqtt_broker_port));
  Serial.println("  Timestamp: " + String(millis()) + " ms");
  Serial.println("  Is Retained: " + String(length > 0 ? "Unknown" : "Unknown")); // MQTT lib doesn't expose retain flag
  
  // Check if this is our own message to prevent feedback loops
  // BUT: Always process messages during first 30 seconds (boot sync period)
  bool isBootSync = (millis() < 30000);
  if (!isBootSync && isOurOwnMessage(topic_str, payload_str)) {
    Serial.println("  üîÑ Ignoring our own message to prevent feedback loop");
    Serial.println("================================");
    return;
  }
  
  if (isBootSync) {
    Serial.println("  üöÄ Processing message during boot sync period");
  }
  
  // Ignore $SYS topics
  if (topic_str.startsWith("$SYS")) {
    Serial.println("  ‚ÑπÔ∏è Ignoring $SYS topic");
    Serial.println("================================");
    return;
  }
  
  Serial.println("================================");
  
  // Handle turnout control messages
  if (topic_str.indexOf("/turnout/") > 0) {
    Serial.println("üéØ Processing turnout control message");
    handleTurnoutControl(topic_str, payload_str);
  }
  
  // Handle light control messages
  if (topic_str.indexOf("/light/") > 0) {
    Serial.println("üéØ Processing light control message");
    Serial.println("  Full topic: " + topic_str);
    Serial.println("  Payload: " + payload_str);
    Serial.println("  Topic contains '/light/': " + String(topic_str.indexOf("/light/")));
    handleLightControl(topic_str, payload_str);
  }
  
  // Handle sensor truth verification - respond with actual state if different
  if (topic_str.indexOf("/sensor/") > 0) {
    Serial.println("üéØ Processing sensor verification message");
    Serial.println("  Sensor topic detected: " + topic_str);
    Serial.println("  Payload: " + payload_str);
    Serial.println("  Current sensor states:");
    for (int i = 0; i < 4; i++) {  // Changed from 3 to 4 sensors
      Serial.println("    Sensor " + String(i+1) + ": " + String(sensor_states[i] ? "ACTIVE" : "INACTIVE"));
    }
    handleSensorVerification(topic_str, payload_str);
  }
}

void handleTurnoutControl(String topic, String payload) {
  // Extract turnout number from topic (e.g., "track/turnout/1" -> turnout 1)
  int turnout_num = 0;
  
  // Find the last number in the topic
  int lastSlash = topic.lastIndexOf('/');
  if (lastSlash > 0) {
    String turnout_str = topic.substring(lastSlash + 1);
    turnout_num = turnout_str.toInt() - 1;  // Convert to 0-based index
  }
  
  // Validate turnout number
  if (turnout_num < 0 || turnout_num > 1) {
    Serial.println("‚ùå Error: Invalid turnout number: " + String(turnout_num + 1));
    Serial.println("=====================");
    return;
  }
  
  Serial.println("=== Turnout Control ===");
  Serial.println("Turnout: " + String(turnout_num + 1));
  Serial.println("Topic: " + topic);
  Serial.println("Payload: " + payload);
  Serial.println("Current state: " + String(turnout_states[turnout_num] ? "THROWN" : "CLOSED"));
  
  bool state_changed = false;
  
  if (payload == "THROWN") {
    Serial.println("üéØ Requested position: THROWN");
    
    if (turnout_states[turnout_num] != true) {  // Only change if state is different
      state_changed = true;
    
    if (turnout_num == 0) {
        digitalWrite(TURNOUT_PIN_1, HIGH);
        turnout_states[0] = true;
        Serial.println("‚úÖ Turnout 1 pin " + String(TURNOUT_PIN_1) + " set to HIGH");
    } else if (turnout_num == 1) {
        digitalWrite(TURNOUT_PIN_2, HIGH);
        turnout_states[1] = true;
        Serial.println("‚úÖ Turnout 2 pin " + String(TURNOUT_PIN_2) + " set to HIGH");
      }
      
      Serial.println("‚úÖ Turnout " + String(turnout_num + 1) + " moved to THROWN");
    } else {
      Serial.println("‚ÑπÔ∏è Turnout " + String(turnout_num + 1) + " already in THROWN position");
    }
    
  } else if (payload == "CLOSED") {
    Serial.println("üéØ Requested position: CLOSED");
    
    if (turnout_states[turnout_num] != false) {  // Only change if state is different
      state_changed = true;
      
      if (turnout_num == 0) {
        digitalWrite(TURNOUT_PIN_1, LOW);
        turnout_states[0] = false;
        Serial.println("‚úÖ Turnout 1 pin " + String(TURNOUT_PIN_1) + " set to LOW");
      } else if (turnout_num == 1) {
        digitalWrite(TURNOUT_PIN_2, LOW);
        turnout_states[1] = false;
        Serial.println("‚úÖ Turnout 2 pin " + String(TURNOUT_PIN_2) + " set to LOW");
      }
      
      Serial.println("‚úÖ Turnout " + String(turnout_num + 1) + " moved to CLOSED");
    } else {
      Serial.println("‚ÑπÔ∏è Turnout " + String(turnout_num + 1) + " already in CLOSED position");
    }
    
  } else {
    Serial.println("‚ùå Unknown position specified in turnout control message: " + payload);
    Serial.println("=====================");
    return;
  }
  
  // Don't publish when state changes due to MQTT commands
  // JMRI already knows it sent the command, no need to echo back
  if (state_changed) {
    Serial.println("üîÑ State changed due to MQTT command, but not publishing back to JMRI");
    Serial.println("‚ÑπÔ∏è JMRI already knows it sent this command - no echo needed");
  } else {
    Serial.println("‚ÑπÔ∏è No state change, already in requested state");
  }
  
  Serial.println("=====================");
}

/*
 * Handle light control messages from JMRI
 * 
 * RACE CONDITION PREVENTION:
 * - Only change state and publish if it's actually different from current state
 * - This prevents feedback loops where JMRI sends a command and we echo back unnecessarily
 * - Uses the same pattern as turnout control for consistency
 */
void handleLightControl(String topic, String payload) {
  Serial.println("=== Light Control ===");
  Serial.println("Topic: " + topic);
  Serial.println("Payload: " + payload);
  
  // Extract light number from topic
  // JMRI can send: /trains/track/light/1 or /trains/track/light/1/red
  int lightNum = 0;
  
  // Parse topic to get light number
  int lastSlash = topic.lastIndexOf('/');
  if (lastSlash > 0) {
    String lastPart = topic.substring(lastSlash + 1);
    lightNum = lastPart.toInt();
    Serial.println("  Last slash position: " + String(lastSlash));
    Serial.println("  Last part: '" + lastPart + "'");
    Serial.println("  Parsed light number: " + String(lightNum));
  } else {
    Serial.println("  ‚ùå No slash found in topic");
  }
  
  Serial.println("Light Number: " + String(lightNum));
  
  // Validate light number (1-6)
  if (lightNum < 1 || lightNum > 6) {
    Serial.println("‚ùå Invalid light number: " + String(lightNum));
    return;
  }
  
  // Parse payload (JMRI sends "ON" or "OFF")
  bool lightState = (payload == "ON");
  Serial.println("  Payload: '" + payload + "' -> lightState: " + String(lightState ? "true" : "false"));
  
  // RACE CONDITION PREVENTION: Only change state and publish if it's actually different
  // This prevents feedback loops where JMRI sends a command and we echo back unnecessarily
  bool stateChanged = (light_states[lightNum - 1] != lightState);
  Serial.println("  Current state: " + String(light_states[lightNum - 1] ? "ON" : "OFF"));
  Serial.println("  Requested state: " + String(lightState ? "ON" : "OFF"));
  Serial.println("  State will change: " + String(stateChanged ? "YES" : "NO"));
  
  if (stateChanged) {
    // Control the appropriate light
    light_states[lightNum - 1] = lightState;
    Serial.println("  Updated light_states[" + String(lightNum - 1) + "] = " + String(lightState));
    
    // Set the physical pin
    switch(lightNum) {
      case 1:
        digitalWrite(LIGHT_PIN_1, lightState ? HIGH : LOW);
        break;
      case 2:
        digitalWrite(LIGHT_PIN_2, lightState ? HIGH : LOW);
        break;
      case 3:
        digitalWrite(LIGHT_PIN_3, lightState ? HIGH : LOW);
        break;
      case 4:
        digitalWrite(LIGHT_PIN_4, lightState ? HIGH : LOW);
        break;
      case 5:
        digitalWrite(LIGHT_PIN_5, lightState ? HIGH : LOW);
        break;
      case 6:
        digitalWrite(LIGHT_PIN_6, lightState ? HIGH : LOW);
        break;
    }
    
    Serial.println("Light " + String(lightNum) + " set to: " + String(lightState ? "ON" : "OFF"));
    
    // Only publish when state actually changes
    Serial.println("üîÑ State changed due to MQTT command, publishing back to JMRI");
    publishLightStatus(lightNum, lightState);
  } else {
    Serial.println("‚ÑπÔ∏è Light " + String(lightNum) + " already in requested state - no change needed");
    Serial.println("üîÑ State unchanged, not publishing back to JMRI");
  }
  
  Serial.println("=== Light Control Complete ===");
}

void handleSensorVerification(String topic, String payload) {
  Serial.println("=== Sensor Verification START ===");
  
  // Extract sensor number from topic (e.g., "trains/track/sensor/1" -> sensor 1)
  int sensor_num = 0;
  
  // Find the last number in the topic
  int lastSlash = topic.lastIndexOf('/');
  if (lastSlash > 0) {
    String sensor_str = topic.substring(lastSlash + 1);
    sensor_num = sensor_str.toInt();
    Serial.println("  Extracted sensor number: " + String(sensor_num));
  }
  
  // Validate sensor number
  if (sensor_num < 1 || sensor_num > 4) {  // Changed from 3 to 4 sensors
    Serial.println("‚ùå Error: Invalid sensor number: " + String(sensor_num));
    Serial.println("=====================");
    return;
  }
  
  String actual_state = sensor_states[sensor_num - 1] ? "ACTIVE" : "INACTIVE";
  
  Serial.println("=== Sensor Verification ===");
  Serial.println("Sensor: " + String(sensor_num));
  Serial.println("Topic: " + topic);
  Serial.println("JMRI expects: " + payload);
  Serial.println("Actual physical state: " + actual_state);
  
  // Get the correct pin for the sensor number
  int pin_to_read;
  switch(sensor_num) {
    case 1: pin_to_read = SENSOR_PIN_1; break;
    case 2: pin_to_read = SENSOR_PIN_2; break;
    case 3: pin_to_read = SENSOR_PIN_3; break;
    case 4: pin_to_read = SENSOR_PIN_4; break;
    default: pin_to_read = SENSOR_PIN_1; break;
  }
  Serial.println("Physical pin state: " + String(digitalRead(pin_to_read)));
  
  // Only publish if JMRI's expectation differs from reality
  if (payload != actual_state) {
    Serial.println("‚ö†Ô∏è MISMATCH: JMRI expects '" + payload + "' but sensor is actually '" + actual_state + "'");
    Serial.println("üì§ Publishing correct sensor state to update JMRI...");
    publishSensorStatus(sensor_num);
  } else {
    Serial.println("‚úÖ JMRI state matches actual sensor state - no publish needed");
  }
  
  Serial.println("=== Sensor Verification END ===");
}

void handleSensors() {
  // Read sensor states (inverted because of pull-up resistors)
  sensor_states[0] = !digitalRead(SENSOR_PIN_1);
  sensor_states[1] = !digitalRead(SENSOR_PIN_2);
  sensor_states[2] = !digitalRead(SENSOR_PIN_3);
  sensor_states[3] = !digitalRead(SENSOR_PIN_4);
  
  // Check for changes and publish if needed
  for (int i = 0; i < 4; i++) {  // Changed from 3 to 4 sensors
    if (sensor_states[i] != last_sensor_states[i]) {
      Serial.println("Sensor " + String(i + 1) + " state changed from " + 
                    String(last_sensor_states[i] ? "ACTIVE" : "INACTIVE") + " to " + 
                    String(sensor_states[i] ? "ACTIVE" : "INACTIVE"));
      
      last_sensor_states[i] = sensor_states[i];
      publishSensorStatus(i + 1);
    }
  }
}

void publishSensorStatus(int sensor_num) {
  if (!mqtt_connected) return;
  
  // Publish to same topic as commands - filtering prevents feedback loops
  String state = sensor_states[sensor_num - 1] ? "ACTIVE" : "INACTIVE";
  String topic = mqtt_sensor_topic + String(sensor_num);
  
  // Track this publication to prevent feedback loops
  trackPublication(topic, state);
  
  mqtt_client.publish(topic.c_str(), state.c_str(), true); // Retained message
  
  Serial.println("Published sensor " + String(sensor_num) + " status: " + state + " to topic: " + topic);
}

void publishTurnoutStatus(int turnout_num) {
  if (!mqtt_connected) return;
  
  // Publish to same topic as commands - filtering prevents feedback loops
  String position = turnout_states[turnout_num - 1] ? "THROWN" : "CLOSED";
  String topic = mqtt_turnout_topic + String(turnout_num);
  
  // Debug: show the source of this publication
  Serial.println("üîç DEBUG: Publishing turnout " + String(turnout_num) + " status");
  Serial.println("   Internal state: " + String(turnout_states[turnout_num - 1] ? "true (THROWN)" : "false (CLOSED)"));
  Serial.println("   Pin state: " + String(digitalRead(turnout_num == 1 ? TURNOUT_PIN_1 : TURNOUT_PIN_2) ? "HIGH (THROWN)" : "LOW (CLOSED)"));
  
  // Track this publication to prevent feedback loops
  trackPublication(topic, position);
  
  mqtt_client.publish(topic.c_str(), position.c_str(), true); // Retained message
  
  Serial.println("Published turnout " + String(turnout_num) + " status: " + position + " to topic: " + topic);
}

void publishLightStatus(int lightNum, bool lightState) {
  if (!mqtt_connected) return;
  
  // Publish to the JMRI light topic format: /trains/track/light/1
  String topic = mqtt_light_topic + String(lightNum);
  String state = lightState ? "ON" : "OFF";
  
  // Track this publication to prevent feedback loops
  trackPublication(topic, state);
  
  mqtt_client.publish(topic.c_str(), state.c_str(), true); // Retained message
  
  Serial.println("Published light " + String(lightNum) + " status: " + state + " to topic: " + topic);
}

void publishInitialStatus() {
  if (!mqtt_connected) return;
  
  Serial.println("=== Publishing Initial Status for All Devices to JMRI ===");
  Serial.println("üîç DEBUG: publishInitialStatus() called");
  
  // Publish individual sensor statuses
  for (int i = 1; i <= 4; i++) {  // Changed from 3 to 4 sensors
    publishSensorStatus(i);
    delay(100);  // Small delay between publishes
  }
  
  // Publish individual turnout statuses
  for (int i = 1; i <= 2; i++) {
    Serial.println("üîç DEBUG: publishTurnoutStatus() called from publishInitialStatus()");
    publishTurnoutStatus(i);
    delay(100);  // Small delay between publishes
  }
  
  // Publish individual light statuses for all 6 lights
  for (int i = 1; i <= 6; i++) {
    // Only publish if light is ON to avoid triggering JMRI commands for OFF lights
    if (light_states[i-1]) {
      publishLightStatus(i, light_states[i-1]);
      delay(100);
    }
  }
  
  Serial.println("=== Initial Device States Published to JMRI ===");
}

// Removed publishAllDeviceStatus() - only publish when states actually change

// Removed publishStatus() and updateStatus() functions
// MQTT status is now only published when device states actually change

// Web server handlers
void handleRoot() {
  String html = getMainPageHTML();
  
  // Substitute placeholders with actual values
  html.replace("CLIENT_ID_PLACEHOLDER", String(MQTT_CLIENT_ID));
  html.replace("IP_ADDRESS_PLACEHOLDER", WiFi.localIP().toString());
  html.replace("WIFI_STATUS_PLACEHOLDER", WiFi.status() == WL_CONNECTED ? 
    "<span class=\"status-badge status-connected\">WiFi Connected</span>" : 
    "<span class=\"status-badge status-disconnected\">WiFi Disconnected</span>");
  html.replace("MQTT_BROKER_PLACEHOLDER", mqtt_broker_ip + ":" + String(mqtt_broker_port));
  html.replace("MQTT_STATUS_PLACEHOLDER", mqtt_client.connected() ? 
    "<span class=\"status-badge status-connected\">Connected</span>" : 
    "<span class=\"status-badge status-disconnected\">Disconnected</span>");
  html.replace("WIFI_SSID_PLACEHOLDER", wifi_ssid);
  html.replace("WIFI_PASSWORD_PLACEHOLDER", wifi_password);
  html.replace("MQTT_BROKER_PLACEHOLDER", mqtt_broker_ip);
  html.replace("MQTT_PORT_PLACEHOLDER", String(mqtt_broker_port));
  html.replace("MQTT_CLIENT_ID_PLACEHOLDER", String(MQTT_CLIENT_ID));
  html.replace("MQTT_CHANNEL_NAME_PLACEHOLDER", mqtt_channel_name);
  html.replace("MQTT_TOPIC_PREFIX_PLACEHOLDER", String(MQTT_TOPIC_PREFIX));
  html.replace("FIRMWARE_VERSION_PLACEHOLDER", String(FIRMWARE_VERSION));
  
  web_server.send(200, "text/html", html);
}

// Handler for /devices endpoint - returns device table HTML
void handleDevices() {
  web_server.send(200, "text/html", getDeviceTableHTML());
}

// Handler for /config endpoint - returns current configuration as JSON
void handleConfig() {
  DynamicJsonDocument doc(512);
  
  doc["wifi_ssid"] = wifi_ssid;
  doc["mqtt_broker"] = mqtt_broker_ip;
  doc["mqtt_port"] = mqtt_broker_port;
  doc["mqtt_client_id"] = String(MQTT_CLIENT_ID);
  doc["mqtt_channel_name"] = mqtt_channel_name;
  doc["mqtt_topic_prefix"] = String(MQTT_TOPIC_PREFIX);
  
  String response;
  serializeJson(doc, response);
  web_server.send(200, "application/json", response);
}

void handleWiFiConfig() {
  if (web_server.hasArg("ssid") && web_server.hasArg("password")) {
    String new_ssid = web_server.arg("ssid");
    String new_password = web_server.arg("password");
    
    // Save to preferences
    preferences.putString("wifi_ssid", new_ssid);
    preferences.putString("wifi_password", new_password);
    
    wifi_ssid = new_ssid;
    wifi_password = new_password;
    wifi_configured = true;
    
    // Restart WiFi connection
    WiFi.disconnect();
    delay(1000);
    WiFi.begin(wifi_ssid.c_str(), wifi_password.c_str());
    
    web_server.send(200, "text/plain", "WiFi configuration saved. Device will connect to the new network.");
  } else {
    web_server.send(400, "text/plain", "Missing SSID or password");
  }
}

void handleMQTTConfig() {
  if (web_server.hasArg("mqtt_broker") && web_server.hasArg("mqtt_port") && web_server.hasArg("mqtt_client_id") && web_server.hasArg("mqtt_channel_name") && web_server.hasArg("mqtt_topic_prefix")) {
    String new_broker = web_server.arg("mqtt_broker");
    int new_port = web_server.arg("mqtt_port").toInt();
    String new_client_id = web_server.arg("mqtt_client_id");
    String new_channel_name = web_server.arg("mqtt_channel_name");
    String new_topic_prefix = web_server.arg("mqtt_topic_prefix");

    Serial.println("=== MQTT Configuration Update ===");
    Serial.println("New Broker: " + new_broker);
    Serial.println("New Port: " + String(new_port));
    Serial.println("New Client ID: " + new_client_id);
    Serial.println("New Channel Name: " + new_channel_name);
    Serial.println("New Topic Prefix: " + new_topic_prefix);

    // Save to preferences
    preferences.putString("mqtt_broker", new_broker);
    preferences.putInt("mqtt_port", new_port);
    preferences.putString("mqtt_client_id", new_client_id);
    preferences.putString("mqtt_channel_name", new_channel_name);
    preferences.putString("mqtt_topic_prefix", new_topic_prefix);

    // Update global variables
    mqtt_broker_ip = new_broker;
    mqtt_broker_port = new_port;
    mqtt_channel_name = new_channel_name;

    // Update MQTT client settings
    mqtt_client.disconnect();
    mqtt_client.setServer(new_broker.c_str(), new_port);
    
    // Update topic strings with channel name prefix
    String channel_prefix = mqtt_channel_name;
    if (!channel_prefix.startsWith("/")) {
      channel_prefix = "/" + channel_prefix;
    }
    mqtt_base_topic = channel_prefix + String(new_topic_prefix) + "/";
    mqtt_sensor_topic = mqtt_base_topic + "sensor/";
    mqtt_turnout_topic = mqtt_base_topic + "turnout/";
    mqtt_light_topic = mqtt_base_topic + "light/";
    mqtt_status_topic = mqtt_base_topic + "status/";

    Serial.println("Updated topic strings:");
    Serial.println("  Base: " + mqtt_base_topic);
    Serial.println("  Sensors: " + mqtt_sensor_topic);
    Serial.println("  Turnouts: " + mqtt_turnout_topic);
    Serial.println("  Signals: " + mqtt_light_topic); // Changed from signal to light
    Serial.println("  Status: " + mqtt_status_topic);

    // Disconnect current MQTT connection
    Serial.println("Disconnecting current MQTT connection...");
    mqtt_client.disconnect();
    mqtt_connected = false;
    delay(1000);
    
    // Try to reconnect with new settings
    Serial.println("Attempting to reconnect with new MQTT settings...");
    if (mqtt_client.connect(new_client_id.c_str())) {
      Serial.println("‚úÖ MQTT reconnected with new configuration successfully!");
      mqtt_connected = true;
      
      // Resubscribe to control topics
      String turnout_topic = mqtt_turnout_topic + "+";
      String sensor_topic = mqtt_sensor_topic + "+";
      String light_topic = mqtt_light_topic + "+";
      
      Serial.println("Resubscribing to turnout topic: " + turnout_topic);
      mqtt_client.subscribe(turnout_topic.c_str());
      
      Serial.println("Resubscribing to sensor topic: " + sensor_topic);
      mqtt_client.subscribe(sensor_topic.c_str());

      Serial.println("Resubscribing to light topic: " + light_topic);
      mqtt_client.subscribe(light_topic.c_str());
      
      // Skip republishing status on config changes - JMRI already knows current states
      Serial.println("Skipping status republish (no state changes)");
      
      Serial.println("=== MQTT Reconfiguration Complete ===");
    } else {
      Serial.println("‚ùå Failed to reconnect to MQTT with new configuration");
      Serial.printf("Error code: %d\n", mqtt_client.state());
      mqtt_connected = false;
    }

    web_server.send(200, "text/plain", "MQTT configuration saved. Device will reconnect to MQTT broker.");
  } else {
    web_server.send(400, "text/plain", "Missing MQTT configuration parameters (broker, port, client_id, channel_name, or topic_prefix)");
  }
}

void handleStatus() {
  DynamicJsonDocument doc(1024);
  
  // Add sensor states
  JsonArray sensorArray = doc.createNestedArray("sensor_states");
  for (int i = 0; i < 4; i++) {  // Changed from 3 to 4 sensors
    JsonObject sensor = sensorArray.createNestedObject();
    sensor["sensor"] = i + 1;
    sensor["state"] = sensor_states[i] ? "ACTIVE" : "INACTIVE";
    sensor["label"] = preferences.getString(("sensor_label_" + String(i + 1)).c_str(), ("Sensor " + String(i + 1)).c_str());
  }
  
  // Add turnout states
  JsonArray turnoutArray = doc.createNestedArray("turnout_states");
  for (int i = 0; i < 2; i++) {
    JsonObject turnout = turnoutArray.createNestedObject();
    turnout["turnout"] = i + 1;
    turnout["position"] = turnout_states[i] ? "THROWN" : "CLOSED";
    turnout["label"] = preferences.getString(("turnout_label_" + String(i + 1)).c_str(), ("Turnout " + String(i + 1)).c_str());
  }
  
  // Add individual light states
  JsonArray lightArray = doc.createNestedArray("lights");
  for (int i = 0; i < 6; i++) {
    JsonObject light = lightArray.createNestedObject();
    light["light"] = i + 1;
    light["state"] = light_states[i] ? "ON" : "OFF";
    light["label"] = preferences.getString(("light_label_" + String(i + 1)).c_str(), ("Light " + String(i + 1)).c_str());
  }
  
  // Add system info
  doc["version"] = FIRMWARE_VERSION;
  doc["mqtt_connected"] = mqtt_connected;
  doc["wifi_connected"] = WiFi.status() == WL_CONNECTED;
  
  String response;
  serializeJson(doc, response);
  web_server.send(200, "application/json", response);
}

void handleDeviceControl() {
  if (!web_server.hasArg("type") || !web_server.hasArg("number") || !web_server.hasArg("action")) {
    web_server.send(400, "text/plain", "Missing required parameters");
    return;
  }
  
  String type = web_server.arg("type");
  int number = web_server.arg("number").toInt();
  String action = web_server.arg("action");
  
  Serial.println("=== Device Control Request ===");
  Serial.println("Type: " + type);
  Serial.println("Number: " + String(number));
  Serial.println("Action: " + action);
  
  if (type == "turnout") {
    if (number < 1 || number > 2) {
      web_server.send(400, "text/plain", "Invalid turnout number");
      return;
    }
    
    if (action == "THROWN") {
      turnout_states[number - 1] = true;
      digitalWrite(number == 1 ? TURNOUT_PIN_1 : TURNOUT_PIN_2, HIGH);
      Serial.println("Turnout " + String(number) + " set to THROWN");
    } else if (action == "CLOSED") {
      turnout_states[number - 1] = false;
      digitalWrite(number == 1 ? TURNOUT_PIN_1 : TURNOUT_PIN_2, LOW);
      Serial.println("Turnout " + String(number) + " set to CLOSED");
    } else {
      web_server.send(400, "text/plain", "Invalid turnout action");
      return;
    }
    
    // Publish status to JMRI
    publishTurnoutStatus(number);
    
  } else if (type == "light") {
    // Handle light control for signal heads
    if (number < 1 || number > 6) {
      web_server.send(400, "text/plain", "Invalid light number");
      return;
    }
    
    // Toggle the light state
    bool newState = false;
    if (number == 1) {
      light_states[0] = !light_states[0];
      newState = light_states[0];
      digitalWrite(LIGHT_PIN_1, newState ? HIGH : LOW);
    } else if (number == 2) {
      light_states[1] = !light_states[1];
      newState = light_states[1];
      digitalWrite(LIGHT_PIN_2, newState ? HIGH : LOW);
    } else if (number == 3) {
      light_states[2] = !light_states[2];
      newState = light_states[2];
      digitalWrite(LIGHT_PIN_3, newState ? HIGH : LOW);
    } else if (number == 4) {
      light_states[3] = !light_states[3];
      newState = light_states[3];
      digitalWrite(LIGHT_PIN_4, newState ? HIGH : LOW);
    } else if (number == 5) {
      light_states[4] = !light_states[4];
      newState = light_states[4];
      digitalWrite(LIGHT_PIN_5, newState ? HIGH : LOW);
    } else if (number == 6) {
      light_states[5] = !light_states[5];
      newState = light_states[5];
      digitalWrite(LIGHT_PIN_6, newState ? HIGH : LOW);
    }
    
    Serial.println("Light " + String(number) + " toggled to " + (newState ? "ON" : "OFF"));
    
    // Publish status to JMRI
    publishLightStatus(number, newState);
    
  } else {
    web_server.send(400, "text/plain", "Invalid device type");
    return;
  }
  
  web_server.send(200, "text/plain", "Device control successful");
}

void handleRestart() {
  web_server.send(200, "text/plain", "Device restarting...");
  delay(1000);
  ESP.restart();
}

void handleReset() {
  Serial.println("=== FACTORY RESET REQUESTED ===");
  web_server.send(200, "text/plain", "Clearing all saved variables and restarting...");
  
  // Clear all stored preferences
  preferences.clear();
  Serial.println("All preferences cleared");
  
  // Give a moment for the response to be sent
  delay(2000);
  
  Serial.println("Restarting with factory defaults...");
  ESP.restart();
}



void handleDoUpdate() {
  web_server.sendHeader("Connection", "close");
  
  if (Update.hasError()) {
    String error_msg = "Update failed: " + String(Update.errorString());
    Serial.println(error_msg);
    web_server.send(500, "text/plain", error_msg);
  } else {
    Serial.println("Update successful, restarting device...");
    web_server.send(200, "text/plain", "Update successful! Device will restart in 3 seconds...");
    delay(3000);
    ESP.restart();
  }
}

// Static variable to track if update has been initialized
static bool updateInitialized = false;

void handleUpdateBody() {
  HTTPUpload& upload = web_server.upload();
  
  if (upload.status == UPLOAD_FILE_START) {
    Serial.println("=== OTA Update Started ===");
    Serial.println("File name: " + upload.filename);
    Serial.println("Upload status: " + String(upload.status));
    
    // Check if we have enough free space
    size_t freeSpace = ESP.getFreeSketchSpace();
    Serial.println("Free sketch space: " + String(freeSpace) + " bytes");
    
    if (freeSpace < 100000) {  // Less than 100KB free
      Serial.println("‚ùå Error: Insufficient free space for update");
                return;
            }
            
    // Debug upload information
    Serial.println("Upload total size: " + String(upload.totalSize) + " bytes");
    Serial.println("Upload current size: " + String(upload.currentSize) + " bytes");
    
    Serial.println("Starting OTA update...");
    
    // Reset initialization flag
    updateInitialized = false;
    
    // Don't call Update.begin() here - wait for first write chunk to determine size
    Serial.println("‚úÖ Upload started - waiting for first chunk to determine size...");
    
  } else if (upload.status == UPLOAD_FILE_WRITE) {
    if (upload.buf == nullptr) {
      Serial.println("‚ùå Error: Upload buffer is null");
      return;
    }
    
    // Initialize Update library on first write chunk
    if (!updateInitialized) {
      Serial.println("=== First Write Chunk ===");
      Serial.println("Chunk size: " + String(upload.currentSize) + " bytes");
      
      // Debug: Check first few bytes of the chunk for firmware header
      Serial.print("First chunk header bytes: ");
      for (int i = 0; i < min(16, (int)upload.currentSize); i++) {
        Serial.printf("%02X ", upload.buf[i]);
      }
      Serial.println();
      
      // Use maximum available space and let Update library determine actual size from firmware
      size_t maxUpdateSize = (ESP.getFreeSketchSpace() - 0x1000) & 0xFFFFF000;
      Serial.println("Max update size: " + String(maxUpdateSize) + " bytes");
      
      if (!Update.begin(maxUpdateSize, U_FLASH)) {
        Serial.println("‚ùå Error: Update.begin() failed");
        Serial.println("Update error: " + String(Update.getError()));
        Update.printError(Serial);
        return;
      }
      
      updateInitialized = true;
      Serial.println("‚úÖ Update initialized successfully");
      Serial.println("Update size after begin: " + String(Update.size()) + " bytes");
    }
    
    size_t written = Update.write(upload.buf, upload.currentSize);
    if (written != upload.currentSize) {
      Serial.println("‚ùå Error: Update.write() failed");
      Serial.println("Expected: " + String(upload.currentSize) + " bytes, Written: " + String(written) + " bytes");
      Serial.println("Update error: " + String(Update.getError()));
      Serial.println("Current progress: " + String(Update.progress()) + " bytes");
      Update.printError(Serial);
    return;
  }
  
    // Calculate progress
    if (Update.size() > 0) {
      size_t progress = (Update.progress() * 100) / Update.size();
      Serial.println("üì§ Chunk written: " + String(upload.currentSize) + " bytes");
      Serial.println("üìä Progress: " + String(progress) + "% (" + String(Update.progress()) + "/" + String(Update.size()) + ")");
    }
    
  } else if (upload.status == UPLOAD_FILE_END) {
    Serial.println("=== Upload File End ===");
    Serial.println("Total bytes received: " + String(Update.progress()));
    
    // Reset initialization flag for next upload
    updateInitialized = false;
    
    if (Update.end(true)) {  // true = set new sketch as boot partition
      Serial.println("‚úÖ Update completed successfully!");
      Serial.println("Final size: " + String(Update.size()) + " bytes");
      
      if (Update.isFinished()) {
        Serial.println("‚úÖ Update is finished and verified");
        Serial.println("üîÑ Restarting device in 3 seconds...");
        delay(3000);
        ESP.restart();
    } else {
        Serial.println("‚ùå Update not finished properly");
    }
      
  } else {
      Serial.println("‚ùå Error: Update.end() failed");
      Serial.println("Update error: " + String(Update.getError()));
      Update.printError(Serial);
    }
    
    // Check for any remaining errors
    if (Update.hasError()) {
      Serial.println("‚ùå Final verification failed");
      Serial.println("Error: " + String(Update.getError()));
      Update.printError(Serial);
    }
  }
}

void handleBackup() {
  // Create a JSON document to store all preferences
  DynamicJsonDocument doc(1024);
  
  // Add WiFi settings
  doc["wifi_ssid"] = preferences.getString("wifi_ssid", "");
  doc["wifi_password"] = preferences.getString("wifi_password", "");
  
  // Add MQTT settings
  doc["mqtt_broker"] = preferences.getString("mqtt_broker", "");
  doc["mqtt_port"] = preferences.getInt("mqtt_port", 0);
  doc["mqtt_client_id"] = preferences.getString("mqtt_client_id", "");
  doc["mqtt_channel_name"] = preferences.getString("mqtt_channel_name", "");
  doc["mqtt_topic_prefix"] = preferences.getString("mqtt_topic_prefix", "");
  
  // Add device configuration
  doc["device_name"] = DEVICE_NAME;
  doc["firmware_version"] = FIRMWARE_VERSION;
  
  // Add device labels (sensors, turnouts, and lights)
  JsonObject device_labels = doc.createNestedObject("device_labels");
  
  // Sensor labels
  device_labels["sensor_1"] = preferences.getString("sensor_label_1", "Sensor 1");
  device_labels["sensor_2"] = preferences.getString("sensor_label_2", "Sensor 2");
  device_labels["sensor_3"] = preferences.getString("sensor_label_3", "Sensor 3");
  device_labels["sensor_4"] = preferences.getString("sensor_label_4", "Sensor 4");
  
  // Turnout labels
  device_labels["turnout_1"] = preferences.getString("turnout_label_1", "Turnout 1");
  device_labels["turnout_2"] = preferences.getString("turnout_label_2", "Turnout 2");
  
  // Light labels
  device_labels["light_1"] = preferences.getString("light_label_1", "Light 1");
  device_labels["light_2"] = preferences.getString("light_label_2", "Light 2");
  device_labels["light_3"] = preferences.getString("light_label_3", "Light 3");
  device_labels["light_4"] = preferences.getString("light_label_4", "Light 4");
  device_labels["light_5"] = preferences.getString("light_label_5", "Light 5");
  device_labels["light_6"] = preferences.getString("light_label_6", "Light 6");
  
  // Add timestamp
  doc["backup_timestamp"] = String(millis());
  
  // Serialize to JSON string
  String jsonStr;
  serializeJsonPretty(doc, jsonStr);
  
  // Generate filename with client ID and timestamp
  String filename = String(MQTT_CLIENT_ID) + "_backup_" + String(millis()) + ".json";
  
  // Send as file download
  web_server.sendHeader("Content-Disposition", "attachment; filename=" + filename);
  web_server.send(200, "application/json", jsonStr);
}

void handleRestore() {
  HTTPUpload& upload = web_server.upload();
  
  if (upload.status == UPLOAD_FILE_START) {
    Serial.println("=== Starting config restore ===");
  } else if (upload.status == UPLOAD_FILE_WRITE) {
    // Parse JSON from uploaded file
    DynamicJsonDocument doc(1024);
    DeserializationError error = deserializeJson(doc, (char*)upload.buf);
    
    if (error) {
      Serial.println("Failed to parse config file");
      return;
    }
    
    // Restore WiFi settings
    if (doc.containsKey("wifi_ssid")) {
      preferences.putString("wifi_ssid", doc["wifi_ssid"].as<String>());
    }
    if (doc.containsKey("wifi_password")) {
      preferences.putString("wifi_password", doc["wifi_password"].as<String>());
    }
    
    // Restore MQTT settings
    if (doc.containsKey("mqtt_broker")) {
      preferences.putString("mqtt_broker", doc["mqtt_broker"].as<String>());
    }
    if (doc.containsKey("mqtt_port")) {
      preferences.putInt("mqtt_port", doc["mqtt_port"].as<int>());
    }
    if (doc.containsKey("mqtt_client_id")) {
      preferences.putString("mqtt_client_id", doc["mqtt_client_id"].as<String>());
    }
    if (doc.containsKey("mqtt_channel_name")) {
      preferences.putString("mqtt_channel_name", doc["mqtt_channel_name"].as<String>());
    }
    if (doc.containsKey("mqtt_topic_prefix")) {
      preferences.putString("mqtt_topic_prefix", doc["mqtt_topic_prefix"].as<String>());
    }
    
    // Restore device labels
    if (doc.containsKey("device_labels")) {
      JsonObject device_labels = doc["device_labels"];
      
      // Restore sensor labels
      if (device_labels.containsKey("sensor_1")) preferences.putString("sensor_label_1", device_labels["sensor_1"].as<String>());
      if (device_labels.containsKey("sensor_2")) preferences.putString("sensor_label_2", device_labels["sensor_2"].as<String>());
      if (device_labels.containsKey("sensor_3")) preferences.putString("sensor_label_3", device_labels["sensor_3"].as<String>());
      if (device_labels.containsKey("sensor_4")) preferences.putString("sensor_label_4", device_labels["sensor_4"].as<String>());
      
      // Restore turnout labels
      if (device_labels.containsKey("turnout_1")) preferences.putString("turnout_label_1", device_labels["turnout_1"].as<String>());
      if (device_labels.containsKey("turnout_2")) preferences.putString("turnout_label_2", device_labels["turnout_2"].as<String>());
      
      // Restore light labels
      if (device_labels.containsKey("light_1")) preferences.putString("light_label_1", device_labels["light_1"].as<String>());
      if (device_labels.containsKey("light_2")) preferences.putString("light_label_2", device_labels["light_2"].as<String>());
      if (device_labels.containsKey("light_3")) preferences.putString("light_label_3", device_labels["light_3"].as<String>());
      if (device_labels.containsKey("light_4")) preferences.putString("light_label_4", device_labels["light_4"].as<String>());
      if (device_labels.containsKey("light_5")) preferences.putString("light_label_5", device_labels["light_5"].as<String>());
      if (device_labels.containsKey("light_6")) preferences.putString("light_label_6", device_labels["light_6"].as<String>());
    }
  } else if (upload.status == UPLOAD_FILE_END) {
    Serial.println("Config restore complete");
    web_server.send(200, "text/plain", "Configuration restored. Device will restart...");
    delay(1000);
    ESP.restart();
  }
}

void handleSaveDeviceLabels() {
  if (web_server.hasArg("device_labels")) {
    String labelsJson = web_server.arg("device_labels");
    DynamicJsonDocument doc(1024);
    DeserializationError error = deserializeJson(doc, labelsJson);

    if (error) {
      Serial.println("Failed to parse device labels JSON");
      web_server.send(400, "text/plain", "Invalid device labels JSON");
      return;
    }

    // Save to preferences
    JsonObject device_labels = doc["device_labels"];
    if (device_labels.containsKey("sensor_1")) preferences.putString("sensor_label_1", device_labels["sensor_1"].as<String>());
    if (device_labels.containsKey("sensor_2")) preferences.putString("sensor_label_2", device_labels["sensor_2"].as<String>());
    if (device_labels.containsKey("sensor_3")) preferences.putString("sensor_label_3", device_labels["sensor_3"].as<String>());
    if (device_labels.containsKey("sensor_4")) preferences.putString("sensor_label_4", device_labels["sensor_4"].as<String>());
    if (device_labels.containsKey("turnout_1")) preferences.putString("turnout_label_1", device_labels["turnout_1"].as<String>());
    if (device_labels.containsKey("turnout_2")) preferences.putString("turnout_label_2", device_labels["turnout_2"].as<String>());
    if (device_labels.containsKey("light_1")) preferences.putString("light_label_1", device_labels["light_1"].as<String>());
    if (device_labels.containsKey("light_2")) preferences.putString("light_label_2", device_labels["light_2"].as<String>());
    if (device_labels.containsKey("light_3")) preferences.putString("light_label_3", device_labels["light_3"].as<String>());
    if (device_labels.containsKey("light_4")) preferences.putString("light_label_4", device_labels["light_4"].as<String>());
    if (device_labels.containsKey("light_5")) preferences.putString("light_label_5", device_labels["light_5"].as<String>());
    if (device_labels.containsKey("light_6")) preferences.putString("light_label_6", device_labels["light_6"].as<String>());

    Serial.println("Device labels saved successfully.");
    web_server.send(200, "text/plain", "Device labels saved successfully.");
  } else {
    web_server.send(400, "text/plain", "Missing device_labels argument");
  }
}
