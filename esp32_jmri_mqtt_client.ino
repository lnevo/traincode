/*
 * ESP32 JMRI MQTT Client
 * 
 * This project provides an ESP32-based MQTT client for interfacing with JMRI
 * for model railroad control. Features include:
 * - Sensor feedback detection
 * - Turnout control
 * - Signal control
 * - OTA updates
 * - WiFi configuration via web interface
 * - MQTT communication with JMRI
 * 
 * Author: Generated by AI Assistant
 * Date: 2024
 */

#include "config.h"
#include <WiFi.h>
#include <esp_wifi.h>
#include <PubSubClient.h>
#include <ArduinoJson.h>
#include <WebServer.h>
#include <Update.h>
#include <SPIFFS.h>
#include <Preferences.h>
#include <ArduinoOTA.h>
#include <ESPmDNS.h>
#include "html_content.h"
#include <vector>

// Pin capability definitions
struct PinCapability {
  int pin;
  bool canInput;
  bool canOutput;
  bool canPWM;
  String description;
};

// Define available pins and their capabilities
// Reserved pins: GPIO0, GPIO2, GPIO4, GPIO5, GPIO12, GPIO15 (boot-strap)
// Reserved pins: GPIO1, GPIO3 (USB-Serial), GPIO16, GPIO17 (UART2), GPIO21, GPIO22 (I¬≤C)
const PinCapability AVAILABLE_PINS[] = {
  // General I/O pins with PWM capability (sorted by pin number)
  {6,  true,  true,  true,  "GPIO6 - I/O + PWM"},
  {7,  true,  true,  true,  "GPIO7 - I/O + PWM"},
  {8,  true,  true,  true,  "GPIO8 - I/O + PWM"},
  {9,  true,  true,  true,  "GPIO9 - I/O + PWM"},
  {10, true,  true,  true,  "GPIO10 - I/O + PWM"},
  {11, true,  true,  true,  "GPIO11 - I/O + PWM"},
  {13, true,  true,  true,  "GPIO13 - I/O + PWM"},
  {14, true,  true,  true,  "GPIO14 - I/O + PWM"},
  {18, true,  true,  true,  "GPIO18 - I/O + PWM"},
  {19, true,  true,  true,  "GPIO19 - I/O + PWM"},
  {20, true,  true,  true,  "GPIO20 - I/O + PWM"},
  {23, true,  true,  true,  "GPIO23 - I/O + PWM"},
  {24, true,  true,  true,  "GPIO24 - I/O + PWM"},
  {25, true,  true,  true,  "GPIO25 - I/O + PWM"},
  {26, true,  true,  true,  "GPIO26 - I/O + PWM"},
  {27, true,  true,  true,  "GPIO27 - I/O + PWM"},
  {28, true,  true,  true,  "GPIO28 - I/O + PWM"},
  {29, true,  true,  true,  "GPIO29 - I/O + PWM"},
  {30, true,  true,  true,  "GPIO30 - I/O + PWM"},
  {31, true,  true,  true,  "GPIO31 - I/O + PWM"},
  {32, true,  true,  true,  "GPIO32 - I/O + PWM"},
  {33, true,  true,  true,  "GPIO33 - I/O + PWM"},
  
  // Input-only pins (no PWM, no output)
  {34, true,  false, false, "GPIO34 - Input Only"},
  {35, true,  false, false, "GPIO35 - Input Only"},
  {36, true,  false, false, "GPIO36 - Input Only"},
  {37, true,  false, false, "GPIO37 - Input Only"},
  {38, true,  false, false, "GPIO38 - Input Only"},
  {39, true,  false, false, "GPIO39 - Input Only"}
};

const int NUM_AVAILABLE_PINS = sizeof(AVAILABLE_PINS) / sizeof(AVAILABLE_PINS[0]);

// Function to get pin capabilities
PinCapability getPinCapability(int pin) {
  for (int i = 0; i < NUM_AVAILABLE_PINS; i++) {
    if (AVAILABLE_PINS[i].pin == pin) {
      return AVAILABLE_PINS[i];
    }
  }
  // Return default capability for reserved pins
  return {pin, false, false, false, "Reserved Pin"};
}

// Function to check if pin is available for a specific function
bool isPinAvailableForFunction(int pin, const String& function) {
  PinCapability cap = getPinCapability(pin);
  
  if (function == "unused") {
    return false; // Unused pins are not available for any function
  } else if (function == "sensor") {
    return cap.canInput;
  } else if (function == "turnout") {
    return cap.canOutput;
  } else if (function == "light") {
    return cap.canOutput && cap.canPWM;
  }
  
  return false;
}

// Function to get available pins for a specific function
std::vector<int> getAvailablePinsForFunction(const String& function) {
  std::vector<int> availablePins;
  
  for (int i = 0; i < NUM_AVAILABLE_PINS; i++) {
    if (isPinAvailableForFunction(AVAILABLE_PINS[i].pin, function)) {
      availablePins.push_back(AVAILABLE_PINS[i].pin);
    }
  }
  
  return availablePins;
}

// WiFi configuration
String default_ssid = "";  // Will be set in setup using MAC address
const char* default_password = DEFAULT_PASSWORD;
String wifi_ssid = "";
String wifi_password = "";

// Function to get unique SSID suffix from MAC address
String getUniqueId() {
  uint8_t mac[6];
  WiFi.softAPmacAddress(mac);  // Get AP MAC address specifically
  
  // Use last 4 digits of MAC
  char suffix[5];
  snprintf(suffix, sizeof(suffix), "%02X%02X", mac[4], mac[5]);
  Serial.printf("Using last 4 digits of AP MAC: %s\n", suffix);
  
  return String(suffix);
}

// Function to get unique client ID from MAC address
String getUniqueClientId() {
  static bool messagePrinted = false;
  static String cachedClientId = "";
  
  // If we already have a cached ID, return it without printing
  if (cachedClientId.length() > 0) {
    return cachedClientId;
  }
  
  // Generate the unique client ID
  uint8_t mac[6];
  WiFi.macAddress(mac);
  String clientId = "esp32_jmri_" + String(mac[4], HEX) + String(mac[5], HEX);
  
  // Only print the message once during device initialization
  if (!messagePrinted) {
    Serial.printf("Generated unique client ID: %s\n", clientId.c_str());
    messagePrinted = true;
  }
  
  // Cache the result
  cachedClientId = clientId;
  return clientId;
}

// Function to get unique hostname from MAC address
String getUniqueHostname() {
  static bool messagePrinted = false;
  static String cachedHostname = "";
  
  // If we already have a cached hostname, return it without printing
  if (cachedHostname.length() > 0) {
    return cachedHostname;
  }
  
  uint8_t mac[6];
  WiFi.macAddress(mac);  // Get station MAC address for hostname
  
  // Create unique hostname: esp32-jmri-XXXX (where XXXX is last 4 digits of MAC)
  // Ensure only valid hostname characters (letters, numbers, hyphens)
  char hostname[25];
  snprintf(hostname, sizeof(hostname), "esp32-jmri-%02x%02x", mac[4], mac[5]);
  
  // Convert to lowercase for better compatibility
  String result = String(hostname);
  result.toLowerCase();
  
  // Only print the message once during device initialization
  if (!messagePrinted) {
    Serial.printf("Generated unique hostname: %s\n", result.c_str());
    Serial.printf("MAC bytes used: %02X:%02X\n", mac[4], mac[5]);
    messagePrinted = true;
  }
  
  // Cache the result
  cachedHostname = result;
  return result;
}

// MQTT topics - Updated to match JMRI format
String mqtt_base_topic = String(MQTT_TOPIC_PREFIX) + "/";
String mqtt_sensor_topic = mqtt_base_topic + "sensor/";
String mqtt_turnout_topic = mqtt_base_topic + "turnout/";
String mqtt_light_topic = mqtt_base_topic + "light/";  // Changed from signal to light
String mqtt_status_topic = mqtt_base_topic + "status/";

// Global objects
WiFiClient espClient;
PubSubClient mqtt_client(espClient);
WebServer web_server(80);
Preferences preferences;

// MQTT broker info storage
String mqtt_broker_ip = "";
String mqtt_broker_hostname = "";  // For mDNS hostname like "rpi-jmri.local"
int mqtt_broker_port = 0;
String mqtt_channel_name = "";

// Function to resolve mDNS hostname to IP
bool resolveMDNSHost(const char* hostname) {
  Serial.printf("Resolving mDNS hostname: %s\n", hostname);
  
  // Remove .local suffix if present
  String host = String(hostname);
  if (host.endsWith(".local")) {
    host = host.substring(0, host.length() - 6);
  }
  
  // Try to resolve hostname
  IPAddress ip = MDNS.queryHost(host.c_str(), 5000);
  if (ip.toString() != "0.0.0.0") {
    mqtt_broker_ip = ip.toString();
    Serial.printf("Resolved %s to IP: %s\n", hostname, mqtt_broker_ip.c_str());
    return true;
  }
  
  Serial.printf("Failed to resolve %s\n", hostname);
  return false;
}

// State variables
bool wifi_configured = false;
bool mqtt_connected = false;
unsigned long last_mqtt_attempt = 0;
// Removed periodic status publishing - only publish on state changes

// Sensor states
bool sensor_states[4] = {false, false, false, false};  // Changed from 3 to 4 sensors
bool last_sensor_states[4] = {false, false, false, false};

// Turnout states
bool turnout_states[2] = {false, false};  // false = CLOSED, true = THROWN
bool last_turnout_states[2] = {false, false};

// Global state variables for lights (6 individual lights)
bool light_states[6] = {false, false, false, false, false, false};  // 6 individual lights
bool last_light_states[6] = {false, false, false, false, false, false};

// Track recent publications to prevent feedback loops
struct RecentPublication {
  String topic;
  String payload;
  unsigned long timestamp;
  bool from_web_gui;
};

RecentPublication recent_pubs[20];  // Track last 20 publications
int recent_pub_index = 0;

void trackPublication(String topic, String payload, bool fromWebGui = false) {
  recent_pubs[recent_pub_index].topic = topic;
  recent_pubs[recent_pub_index].payload = payload;
  recent_pubs[recent_pub_index].timestamp = millis();
  recent_pubs[recent_pub_index].from_web_gui = fromWebGui;
  recent_pub_index = (recent_pub_index + 1) % 20;
}

bool isOurOwnMessage(String topic, String payload) {
  unsigned long now = millis();
  for (int i = 0; i < 20; i++) {
    if (recent_pubs[i].topic == topic && 
        recent_pubs[i].payload == payload && 
        (now - recent_pubs[i].timestamp) < 2000) {  // Within 2 seconds
      return true;
    }
  }
  return false;
}

void displaySystemInfo() {
  Serial.println("=== System Information ===");
  Serial.println("Device: " + String(DEVICE_NAME));
  Serial.println("Firmware Version: " + String(FIRMWARE_VERSION));
  
  // Show unique identifiers
  String uniqueClientId = getUniqueClientId();
  String uniqueHostname = getUniqueHostname();
  Serial.println("Unique Client ID: " + uniqueClientId);
  Serial.println("Unique Hostname: " + uniqueHostname + ".local");
  
  Serial.println("Free Sketch Space: " + String(ESP.getFreeSketchSpace()) + " bytes");
  Serial.println("Free Heap: " + String(ESP.getFreeHeap()) + " bytes");
  Serial.println("Flash Chip Size: " + String(ESP.getFlashChipSize()) + " bytes");
  Serial.println("Max OTA Size: " + String(ESP.getFreeSketchSpace() - 0x1000) + " bytes");
  Serial.println("SDK Version: " + String(ESP.getSdkVersion()));
  Serial.println("CPU Frequency: " + String(ESP.getCpuFreqMHz()) + " MHz");
  Serial.println("===============================");
}

void setup() {
  Serial.begin(SERIAL_BAUD_RATE);
  Serial.println("\n\n=== ESP32 JMRI MQTT Client ===");
  Serial.println("Firmware Version: " + String(FIRMWARE_VERSION));
  
  // Initialize WiFi early
  WiFi.mode(WIFI_MODE_APSTA);
  delay(100);  // Give WiFi time to initialize
  
  // Debug WiFi status
  Serial.println("=== WiFi Debug Info ===");
  Serial.print("WiFi Mode: ");
  switch(WiFi.getMode()) {
    case WIFI_MODE_NULL: Serial.println("NULL"); break;
    case WIFI_MODE_STA: Serial.println("STA"); break;
    case WIFI_MODE_AP: Serial.println("AP"); break;
    case WIFI_MODE_APSTA: Serial.println("AP+STA"); break;
    default: Serial.println("UNKNOWN"); break;
  }
  
  // Get and display raw MAC address
  uint8_t mac[6];
  WiFi.macAddress(mac);
  Serial.print("STA MAC Address: ");
  for (int i = 0; i < 6; i++) {
    Serial.printf("%02X", mac[i]);
    if (i < 5) Serial.print(":");
  }
  Serial.println();
  
  WiFi.softAPmacAddress(mac);
  Serial.print("AP MAC Address:  ");
  for (int i = 0; i < 6; i++) {
    Serial.printf("%02X", mac[i]);
    if (i < 5) Serial.print(":");
  }
  Serial.println();
  
  // Generate unique identifiers
  String uniqueId = getUniqueId();
  String uniqueClientId = getUniqueClientId();
  String uniqueHostname = getUniqueHostname();
  
  default_ssid = String(DEFAULT_SSID) + "_" + uniqueId;
  Serial.println("Device Unique ID: " + uniqueId);
  Serial.println("Unique Client ID: " + uniqueClientId);
  Serial.println("Unique Hostname: " + uniqueHostname);
  Serial.println("AP SSID will be: " + default_ssid);
  
  // Display system information
  displaySystemInfo();
  
  // Initialize pins
  setupPins();
  
  // Initialize SPIFFS
  if (!SPIFFS.begin(true)) {
    Serial.println("SPIFFS initialization failed");
  }
  
  // Initialize preferences
  preferences.begin("jmri_client", false);
  
  // Load saved WiFi credentials
  loadWiFiCredentials();
  
  // Load saved MQTT credentials
  loadMQTTCredentials();
  
  // Setup WiFi
  setupWiFi();
  
  // Wait for WiFi to stabilize
  if (WiFi.status() == WL_CONNECTED) {
    delay(2000);  // Give WiFi time to stabilize
    Serial.println("WiFi connected, attempting MQTT connection...");
    
    // Now setup MQTT with the loaded credentials
    setupMQTT();
    
    // Test broker connectivity before attempting connection
    testMQTTBrokerConnectivity();
    
    // Attempt initial MQTT connection
    Serial.println("Attempting initial MQTT connection...");
    mqttReconnect();
  } else {
    // If WiFi didn't connect, still setup MQTT for when it does connect
    setupMQTT();
  }
  
  // Setup web server for configuration
  setupWebServer();
  
  // Setup OTA
  setupOTA();
  
  Serial.println("Setup complete!");
  Serial.println("If WiFi connects, you can access this device at:");
  Serial.println("  - IP Address: " + WiFi.localIP().toString());
  
  // Show the hostname that will be used for mDNS
  String savedClientId = preferences.getString("mqtt_client_id", "");
  if (savedClientId.length() > 0) {
    Serial.println("  - Hostname: " + savedClientId + ".local");
  } else {
    Serial.println("  - Hostname: " + getUniqueHostname() + ".local (generated)");
  }
}

void loop() {
  // Feed the watchdog to prevent resets
  yield();
  
  // Handle WiFi
  if (WiFi.status() != WL_CONNECTED) {
    handleWiFiReconnection();
  }
  
  // Handle MQTT
  if (WiFi.status() == WL_CONNECTED) {
    handleMQTT();
  }
  
  // Handle sensors
  handleSensors();
  
  // Handle web server
  web_server.handleClient();
  
  // Handle OTA
  ArduinoOTA.handle();
  
  // Only publish device status when states actually change
  // Removed periodic status publishing - JMRI only needs state change notifications
  
  // Connection status (keep minimal logging)
  static unsigned long last_connection_log = 0;
  if (millis() - last_connection_log > 60000) { // Log every minute
    if (WiFi.status() == WL_CONNECTED) {
      Serial.println("SSID: " + WiFi.SSID());
      Serial.println("IP: " + WiFi.localIP().toString());
      Serial.println("RSSI: " + String(WiFi.RSSI()) + " dBm");
    }
    Serial.println("MQTT Status: " + String(mqtt_connected ? "Connected" : "Disconnected"));
    if (mqtt_connected) {
      Serial.println("Broker: " + mqtt_broker_ip + ":" + String(mqtt_broker_port));
    }
    last_connection_log = millis();
  }
  
  delay(10);
}

void setupPins() {
  // Configure turnout pins as outputs
  pinMode(TURNOUT_PIN_1, OUTPUT);
  pinMode(TURNOUT_PIN_2, OUTPUT);
  
  // Configure individual light pins as outputs
  pinMode(LIGHT_PIN_1, OUTPUT);
  pinMode(LIGHT_PIN_2, OUTPUT);
  pinMode(LIGHT_PIN_3, OUTPUT);
  pinMode(LIGHT_PIN_4, OUTPUT);
  pinMode(LIGHT_PIN_5, OUTPUT);
  pinMode(LIGHT_PIN_6, OUTPUT);
  
  // Configure sensor pins as inputs with pull-up resistors
  pinMode(SENSOR_PIN_1, INPUT_PULLUP);
  pinMode(SENSOR_PIN_2, INPUT_PULLUP);
  pinMode(SENSOR_PIN_3, INPUT_PULLUP);
  pinMode(SENSOR_PIN_4, INPUT_PULLUP);
  
  // Configure status LED
  pinMode(STATUS_LED, OUTPUT);
  
  // Set initial states
  digitalWrite(TURNOUT_PIN_1, LOW);   // CLOSED
  digitalWrite(TURNOUT_PIN_2, LOW);   // CLOSED
  
  // Set all lights to OFF initially
  digitalWrite(LIGHT_PIN_1, LOW);
  digitalWrite(LIGHT_PIN_2, LOW);
  digitalWrite(LIGHT_PIN_3, LOW);
  digitalWrite(LIGHT_PIN_4, LOW);
  digitalWrite(LIGHT_PIN_5, LOW);
  digitalWrite(LIGHT_PIN_6, LOW);
  
  digitalWrite(STATUS_LED, HIGH);  // Status LED ON
  
  Serial.println("Pins configured for 2 turnouts, 6 individual lights, and 4 sensors");
}

void loadWiFiCredentials() {
  wifi_ssid = preferences.getString("wifi_ssid", "");
  wifi_password = preferences.getString("wifi_password", "");
  wifi_configured = (wifi_ssid.length() > 0);
  
  if (wifi_configured) {
    Serial.println("Loaded saved WiFi credentials for: " + wifi_ssid);
  } else {
    Serial.println("No saved WiFi credentials found");
  }
}

void loadMQTTCredentials() {
  Serial.println("=== Loading MQTT Credentials ===");
  
  // Get unique client ID for default value
  String uniqueClientId = getUniqueClientId();
  
  // Load MQTT settings from preferences with defaults from config.h
  String broker = preferences.getString("mqtt_broker", MQTT_BROKER);
  int port = preferences.getInt("mqtt_port", MQTT_PORT);
  String client_id = preferences.getString("mqtt_client_id", uniqueClientId);
  String channel_name = preferences.getString("mqtt_channel_name", MQTT_CHANNEL_NAME);
  String topic_prefix = preferences.getString("mqtt_topic_prefix", MQTT_TOPIC_PREFIX);
  
  Serial.println("Loaded configuration:");
  Serial.println("  Broker: " + broker + (broker == MQTT_BROKER ? " (default)" : " (saved)"));
  Serial.println("  Port: " + String(port) + (port == MQTT_PORT ? " (default)" : " (saved)"));
  Serial.println("  Client ID: " + client_id + (client_id == uniqueClientId ? " (default)" : " (saved)"));
  Serial.println("  Channel Name: " + channel_name + (channel_name == MQTT_CHANNEL_NAME ? " (default)" : " (saved)"));
  Serial.println("  Topic Prefix: " + topic_prefix + (topic_prefix == MQTT_TOPIC_PREFIX ? " (default)" : " (saved)"));
  
  // Update MQTT client settings
  mqtt_broker_ip = broker;
  mqtt_broker_port = port;
  mqtt_channel_name = channel_name;
  
  // Update topic strings with channel name prefix
  String channel_prefix = mqtt_channel_name;
  if (!channel_prefix.startsWith("/")) {
    channel_prefix = "/" + channel_prefix;
  }
  mqtt_base_topic = channel_prefix + String(topic_prefix) + "/";
  mqtt_sensor_topic = mqtt_base_topic + "sensor/";
  mqtt_turnout_topic = mqtt_base_topic + "turnout/";
  mqtt_light_topic = mqtt_base_topic + "light/";
  mqtt_status_topic = mqtt_base_topic + "status/";
  
  Serial.println("Updated topic strings:");
  Serial.println("  Base: " + mqtt_base_topic);
  Serial.println("  Sensors: " + mqtt_sensor_topic);
  Serial.println("  Turnouts: " + mqtt_turnout_topic);
  Serial.println("  Signals: " + mqtt_light_topic); // Changed from signal to light
  Serial.println("  Status: " + mqtt_status_topic);
  
  Serial.println("===============================");
}

void setupWiFi() {
  if (wifi_configured) {
    // Try to connect to saved network
    Serial.println("=== WiFi Setup ===");
    Serial.println("Attempting to connect to saved WiFi network: " + wifi_ssid);
    Serial.println("WiFi mode: Station");
    
    WiFi.mode(WIFI_STA);
    WiFi.begin(wifi_ssid.c_str(), wifi_password.c_str());
    
    int attempts = 0;
    while (WiFi.status() != WL_CONNECTED && attempts < WIFI_MAX_ATTEMPTS) {
      delay(500);
      Serial.print(".");
      attempts++;
    }
    
    if (WiFi.status() == WL_CONNECTED) {
      Serial.println("\n‚úÖ WiFi connected successfully!");
      Serial.println("SSID: " + WiFi.SSID());
      Serial.println("IP address: " + WiFi.localIP().toString());
      Serial.println("Gateway: " + WiFi.gatewayIP().toString());
      Serial.println("DNS: " + WiFi.dnsIP().toString());
      Serial.println("RSSI: " + String(WiFi.RSSI()) + " dBm");
      Serial.println("Channel: " + String(WiFi.channel()));
      digitalWrite(STATUS_LED, HIGH);
      
      // Start mDNS after WiFi connects
      startMDNS();
      
      Serial.println("=== WiFi Setup Complete ===");
    } else {
      Serial.println("\n‚ùå Failed to connect to saved WiFi");
      Serial.println("WiFi status: " + String(WiFi.status()));
      wifi_configured = false;
    }
  }
  
  if (!wifi_configured) {
    // Start configuration mode
    Serial.println("=== Starting WiFi Configuration Mode ===");
    WiFi.mode(WIFI_AP);
    WiFi.softAP(default_ssid.c_str(), default_password);
    Serial.println("AP SSID: " + String(default_ssid));
    Serial.println("AP Password: " + String(default_password));
    Serial.println("AP IP address: " + WiFi.softAPIP().toString());
    Serial.println("Connect to '" + String(default_ssid) + "' network with password '" + String(default_password) + "'");
    Serial.println("Then navigate to http://" + WiFi.softAPIP().toString() + " to configure");
    Serial.println("=== WiFi Configuration Mode Active ===");
  }
}

void setupMQTT() {
  Serial.println("=== Setting up MQTT ===");
  
  // Note: mDNS will be started after WiFi connects to ensure it works properly
  
  // If we have a hostname, try to resolve it
  if (mqtt_broker_hostname.length() > 0) {
    if (resolveMDNSHost(mqtt_broker_hostname.c_str())) {
      Serial.println("Successfully resolved hostname to IP");
    } else {
      Serial.println("Warning: Could not resolve hostname, will try direct IP");
    }
  }
  
  Serial.println("Using configuration:");
  Serial.println("  Broker: " + (mqtt_broker_hostname.length() > 0 ? mqtt_broker_hostname : mqtt_broker_ip));
  Serial.println("  IP: " + mqtt_broker_ip);
  Serial.println("  Port: " + String(mqtt_broker_port));
  Serial.println("  Client ID: " + String(MQTT_CLIENT_ID));
  Serial.println("  Channel Name: " + mqtt_channel_name);
  Serial.println("  Topic Prefix: " + String(MQTT_TOPIC_PREFIX));
  
  // Update MQTT client settings
  mqtt_client.setServer(mqtt_broker_ip.c_str(), mqtt_broker_port);
  mqtt_client.setCallback(mqttCallback);
  mqtt_client.setKeepAlive(60);
  mqtt_client.setSocketTimeout(30);
  
  // Update topic strings with current values including channel name
  String channel_prefix = mqtt_channel_name;
  if (!channel_prefix.startsWith("/")) {
    channel_prefix = "/" + channel_prefix;
  }
  mqtt_base_topic = channel_prefix + String(MQTT_TOPIC_PREFIX) + "/";
  mqtt_sensor_topic = mqtt_base_topic + "sensor/";
  mqtt_turnout_topic = mqtt_base_topic + "turnout/";
  mqtt_light_topic = mqtt_base_topic + "light/";
  mqtt_status_topic = mqtt_base_topic + "status/";
  
  Serial.println("Final MQTT configuration:");
  Serial.println("  Broker: " + mqtt_broker_ip + ":" + String(mqtt_broker_port));
  Serial.println("  Base Topic: " + mqtt_base_topic);
  Serial.println("  Sensor Topic: " + mqtt_sensor_topic);
  Serial.println("  Turnout Topic: " + mqtt_turnout_topic);
  Serial.println("  Signal Topic: " + mqtt_light_topic); // Changed from signal to light
  Serial.println("  Status Topic: " + mqtt_status_topic);
  Serial.println("===============================");
}

void setupWebServer() {
  // Configuration page
  web_server.on("/", HTTP_GET, handleRoot);
  web_server.on("/configure", HTTP_POST, handleWiFiConfig);
  web_server.on("/configure_mqtt", HTTP_POST, handleMQTTConfig); // New handler for MQTT config
  web_server.on("/status", HTTP_GET, handleStatus);
  web_server.on("/control", HTTP_POST, handleDeviceControl); // Device control endpoint
  web_server.on("/restart", HTTP_POST, handleRestart);
  web_server.on("/reset", HTTP_POST, handleReset);
  web_server.on("/backup", HTTP_GET, handleBackup);
  web_server.on("/restore", HTTP_POST, handleRestore);
  web_server.on("/save_device_labels", HTTP_POST, handleSaveDeviceLabels);
  web_server.on("/save_device_settings", HTTP_POST, handleSaveDeviceSettings);
  
  // Test endpoint for debugging
  web_server.on("/test", HTTP_GET, []() {
    web_server.send(200, "text/plain", "Web server is working! Firmware version: " + String(FIRMWARE_VERSION));
  });
  
  // mDNS test endpoint
  web_server.on("/mdns-test", HTTP_GET, []() {
    String response = "=== mDNS Status Debug ===\n";
    
    // Get the hostname being used
    String savedClientId = preferences.getString("mqtt_client_id", "");
    String hostname;
    if (savedClientId.length() > 0) {
      hostname = savedClientId + ".local";
      response += "Hostname: " + hostname + " (from saved client ID)\n";
    } else {
      hostname = getUniqueHostname() + ".local";
      response += "Hostname: " + hostname + " (generated from MAC)\n";
    }
    
    response += "IP Address: " + WiFi.localIP().toString() + "\n";
    response += "WiFi Status: " + String(WiFi.status()) + "\n";
    response += "mDNS should be running if WiFi is connected\n";
    
    // Test mDNS resolution
    response += "\n=== Testing mDNS Resolution ===\n";
    response += "Try accessing: http://" + hostname + "\n";
    response += "Or use: nslookup " + hostname + "\n";
    
    web_server.send(200, "text/plain", response);
  });
  
  web_server.on("/test-set-device-id", HTTP_GET, []() {
    // Test setting a device ID manually
    String testId = "TEST123";
    preferences.putString("light_6_id", testId);
    preferences.putString("light_6_label", "Test Light");
    preferences.putString("light_6_pin", "25");
    preferences.putString("light_6_type", "light");
    
    String response = "=== Test Device ID Set ===\n";
    response += "Set light_6_id = " + testId + "\n";
      response += "Set light_6_label = Test Light\n";
      response += "Set light_6_pin = 25\n";
      response += "Set light_6_type = light\n\n";
      
      // Verify it was saved
      String savedId = preferences.getString("light_6_id", "NOT_FOUND");
      response += "Verified light_6_id = " + savedId + "\n";
      
      // Now test if the MQTT system can read it
      response += "\n=== Testing MQTT System Read ===\n";
      String mqttId = preferences.getString("light_6_id", "NOT_FOUND");
      response += "MQTT system reads light_6_id = " + mqttId + "\n";
      
      // Test the actual function that the MQTT system uses
      String customId = preferences.getString(("light_" + String(6) + "_id").c_str(), String(6));
      response += "publishLightStatus(6) would use ID = " + customId + "\n";
      
            web_server.send(200, "text/plain", response);
    });
    
    web_server.on("/test-preferences-basic", HTTP_GET, []() {
      // Basic test of preferences system
      String testKey = "test_key";
      String testValue = "test_value_" + String(millis());
      
      // Write a test value
      preferences.putString(testKey.c_str(), testValue);
      
      // Read it back
      String readValue = preferences.getString(testKey.c_str(), "NOT_FOUND");
      
      // Clean up
      preferences.remove(testKey.c_str());
      
      String response = "=== Basic Preferences Test ===\n";
      response += "Wrote: " + testKey + " = " + testValue + "\n";
      response += "Read: " + testKey + " = " + readValue + "\n";
      response += "Match: " + String(testValue == readValue ? "YES" : "NO") + "\n";
      
      web_server.send(200, "text/plain", response);
    });
    
    web_server.on("/manual-set-light-id", HTTP_GET, []() {
      // Manually set a light ID and test it
      String customId = "CUSTOM99";
      preferences.putString("light_6_id", customId);
      preferences.putString("light_6_label", "Custom Light 99");
      preferences.putString("light_6_pin", "25");
      preferences.putString("light_6_type", "light");
      
      String response = "=== Manual Light ID Set ===\n";
      response += "Set light_6_id = " + customId + "\n";
      response += "Set light_6_label = Custom Light 99\n";
      response += "Set light_6_pin = 25\n";
      response += "Set light_6_type = light\n\n";
      
      // Verify it was saved
      String savedId = preferences.getString("light_6_id", "NOT_FOUND");
      response += "Verified light_6_id = " + savedId + "\n";
      
      // Test the MQTT system
      response += "\n=== MQTT System Test ===\n";
      String mqttId = preferences.getString(("light_" + String(6) + "_id").c_str(), String(6));
      response += "publishLightStatus(6) would use ID = " + mqttId + "\n";
      
      // Test the actual topic generation
      String topic = mqtt_light_topic + mqttId;
      response += "Topic would be: " + topic + "\n";
      
      // Now test if the light control can find this ID
      response += "\n=== Testing Light Control Mapping ===\n";
      bool found = false;
      for (int i = 1; i <= 6; i++) {
        String stored_id = preferences.getString(("light_" + String(i) + "_id").c_str(), String(i));
        if (stored_id == customId) {
          response += "Light control found custom ID '" + customId + "' maps to physical light " + String(i) + "\n";
          found = true;
          break;
        }
      }
      if (!found) {
        response += "Light control could NOT find custom ID '" + customId + "'\n";
      }
      
      web_server.send(200, "text/plain", response);
    });
    
    web_server.on("/debug-device-ids", HTTP_GET, []() {
    String response = "=== Device ID Mapping Debug ===\n\n";
    
    response += "MQTT Topics:\n";
    response += "  Base: " + mqtt_base_topic + "\n";
    response += "  Sensors: " + mqtt_sensor_topic + "\n";
    response += "  Turnouts: " + mqtt_turnout_topic + "\n";
    response += "  Lights: " + mqtt_light_topic + "\n";
    response += "  Status: " + mqtt_status_topic + "\n\n";
    
    response += "Device ID Mappings:\n";
    
    // Show sensor mappings - dynamically count how many exist
    response += "Sensors:\n";
    int debugSensorCount = 0;
    for (int i = 1; i <= 10; i++) {
      String id = preferences.getString(("sensor_" + String(i) + "_id").c_str(), "");
      if (id != "" && id != "NOT_FOUND") {
        debugSensorCount++;
        String customId = preferences.getString(("sensor_" + String(i) + "_id").c_str(), String(i));
        String topic = mqtt_sensor_topic + customId;
        response += "  Sensor " + String(i) + " -> ID: " + customId + " -> Topic: " + topic + "\n";
      }
    }
    if (debugSensorCount == 0) {
      response += "  No sensors configured\n";
    }
    
    // Show turnout mappings - dynamically count how many exist
    response += "\nTurnouts:\n";
    int debugTurnoutCount = 0;
    for (int i = 1; i <= 10; i++) {
      String id = preferences.getString(("turnout_" + String(i) + "_id").c_str(), "");
      if (id != "" && id != "NOT_FOUND") {
        debugTurnoutCount++;
        String customId = preferences.getString(("turnout_" + String(i) + "_id").c_str(), String(i));
        String topic = mqtt_turnout_topic + customId;
        response += "  Turnout " + String(i) + " -> ID: " + customId + " -> Topic: " + topic + "\n";
      }
    }
    if (debugTurnoutCount == 0) {
      response += "  No turnouts configured\n";
    }
    
    // Show light mappings - dynamically count how many exist
    response += "Lights:\n";
    int debugLightCount = 0;
    for (int i = 1; i <= 10; i++) {
      String id = preferences.getString(("light_" + String(i) + "_id").c_str(), "");
      if (id != "" && id != "NOT_FOUND") {
        debugLightCount++;
        String customId = preferences.getString(("light_" + String(i) + "_id").c_str(), String(i));
        String topic = mqtt_light_topic + customId;
        response += "  Light " + String(i) + " -> Topic: " + topic + "\n";
      }
    }
    if (debugLightCount == 0) {
      response += "  No lights configured\n";
    }
    
    // Also show what's actually in the preferences for comparison
    response += "\n=== Raw Preferences Values ===\n";
    response += "Sensors:\n";
    for (int i = 1; i <= 4; i++) {
      String id = preferences.getString(("sensor_" + String(i) + "_id").c_str(), "NOT_FOUND");
      String label = preferences.getString(("sensor_" + String(i) + "_label").c_str(), "NOT_FOUND");
      String pin = preferences.getString(("sensor_" + String(i) + "_pin").c_str(), "NOT_FOUND");
      response += "  sensor_" + String(i) + "_id = " + id + "\n";
      response += "  sensor_" + String(i) + "_label = " + label + "\n";
      response += "  sensor_" + String(i) + "_pin = " + pin + "\n";
    }
    
    response += "\nTurnouts:\n";
    int turnoutCount = 0;
    for (int i = 1; i <= 10; i++) {
      String id = preferences.getString(("turnout_" + String(i) + "_id").c_str(), "");
      if (id != "" && id != "NOT_FOUND") {
        turnoutCount++;
        String label = preferences.getString(("turnout_" + String(i) + "_label").c_str(), "NOT_FOUND");
        String pin = preferences.getString(("turnout_" + String(i) + "_pin").c_str(), "NOT_FOUND");
        response += "  turnout_" + String(i) + "_id = " + id + "\n";
        response += "  turnout_" + String(i) + "_label = " + label + "\n";
        response += "  turnout_" + String(i) + "_pin = " + pin + "\n";
      }
    }
    if (turnoutCount == 0) {
      response += "  No turnouts configured\n";
    }
    
    response += "\nLights:\n";
    for (int i = 1; i <= 6; i++) {
      String id = preferences.getString(("light_" + String(i) + "_id").c_str(), "NOT_FOUND");
      String label = preferences.getString(("light_" + String(i) + "_label").c_str(), "NOT_FOUND");
      String pin = preferences.getString(("light_" + String(i) + "_pin").c_str(), "NOT_FOUND");
      response += "  light_" + String(i) + "_id = " + id + "\n";
      response += "  light_" + String(i) + "_pin = " + pin + "\n";
      response += "  light_" + String(i) + "_label = " + label + "\n";
    }
    
    web_server.send(200, "text/plain", response);
  });
  
  web_server.on("/debug-preferences", HTTP_GET, []() {
    String response = "=== Device Settings in Preferences ===\n\n";
    
    // Check for sensor settings
    response += "Sensors:\n";
    for (int i = 1; i <= 4; i++) {
      String id_key = "sensor_" + String(i) + "_id";
      String pin_key = "sensor_" + String(i) + "_pin";
      String label_key = "sensor_" + String(i) + "_label";
      
      String id = preferences.getString(id_key.c_str(), "NOT_SET");
      String pin = preferences.getString(pin_key.c_str(), "NOT_SET");
      String label = preferences.getString(label_key.c_str(), "NOT_SET");
      
      response += "  Sensor " + String(i) + ":\n";
      response += "    ID: " + id + "\n";
      response += "    Pin: " + pin + "\n";
      response += "    Label: " + label + "\n";
    }
    
    response += "\nTurnouts:\n";
    for (int i = 1; i <= 2; i++) {
      String id_key = "turnout_" + String(i) + "_id";
      String pin_key = "turnout_" + String(i) + "_pin";
      String label_key = "turnout_" + String(i) + "_label";
      
      String id = preferences.getString(id_key.c_str(), "NOT_SET");
      String pin = preferences.getString(pin_key.c_str(), "NOT_SET");
      String label = preferences.getString(label_key.c_str(), "NOT_SET");
      
      response += "  Turnout " + String(i) + ":\n";
      response += "    ID: " + id + "\n";
      response += "    Pin: " + pin + "\n";
      response += "    Label: " + label + "\n";
    }
    
    response += "\nLights:\n";
    for (int i = 1; i <= 6; i++) {
      String id_key = "light_" + String(i) + "_id";
      String pin_key = "light_" + String(i) + "_pin";
      String label_key = "light_" + String(i) + "_label";
      
      String id = preferences.getString(id_key.c_str(), "NOT_SET");
      String pin = preferences.getString(pin_key.c_str(), "NOT_SET");
      String label = preferences.getString(label_key.c_str(), "NOT_SET");
      
      response += "  Light " + String(i) + ":\n";
      response += "    ID: " + id + "\n";
      response += "    Pin: " + pin + "\n";
      response += "    Label: " + label + "\n";
    }
    
    // Also show pin-based settings for comparison
    response += "\n=== Pin-Based Settings ===\n";
    int allPins[] = {13,14,18,19,21,22,23,25,26,27,32,33,34,35,36,39};
    for (int pinNum : allPins) {
      String deviceType = preferences.getString(("pin_" + String(pinNum) + "_type").c_str(), "unused");
      if (deviceType != "unused") {
        String deviceLabel = preferences.getString(("pin_" + String(pinNum) + "_label").c_str(), "");
        String deviceId = preferences.getString(("pin_" + String(pinNum) + "_id").c_str(), "");
        
        response += "  Pin " + String(pinNum) + " (" + deviceType + "):\n";
        response += "    ID: " + deviceId + "\n";
        response += "    Label: " + deviceLabel + "\n";
      }
    }
    
    web_server.send(200, "text/plain", response);
  });
  
  web_server.on("/pin-capabilities", HTTP_GET, []() {
    DynamicJsonDocument doc(1024);
    JsonArray pinsArray = doc.createNestedArray("pins");
    
    for (int i = 0; i < NUM_AVAILABLE_PINS; i++) {
      JsonObject pinObj = pinsArray.createNestedObject();
      pinObj["pin"] = AVAILABLE_PINS[i].pin;
      pinObj["canInput"] = AVAILABLE_PINS[i].canInput;
      pinObj["canOutput"] = AVAILABLE_PINS[i].canOutput;
      pinObj["canPWM"] = AVAILABLE_PINS[i].canPWM;
      pinObj["description"] = AVAILABLE_PINS[i].description;
    }
    
    String response;
    serializeJson(doc, response);
    web_server.send(200, "application/json", response);
  });
  
  // OTA update page

  web_server.on("/doUpdate", HTTP_POST, handleDoUpdate, handleUpdateBody);
  
  // Add missing endpoints that the HTML expects
  web_server.on("/devices", HTTP_GET, handleDevices);
  web_server.on("/wifi", HTTP_POST, handleWiFiConfig);
  web_server.on("/mqtt", HTTP_POST, handleMQTTConfig);
  web_server.on("/config", HTTP_GET, handleConfig);
  web_server.on("/upload", HTTP_POST, handleDoUpdate, handleUpdateBody);
  
  web_server.begin();
  Serial.println("Web server started");
}

void setupOTA() {
  Serial.println("Setting up OTA...");
  
  // Get the actual saved client ID for OTA hostname
  String savedClientId = preferences.getString("mqtt_client_id", "");
  String hostname;
  
  if (savedClientId.length() > 0) {
    // Use the saved client ID as the hostname
    hostname = savedClientId;
    Serial.println("Using saved client ID for OTA hostname: " + hostname);
  } else {
    // Fallback to generated hostname if no saved client ID
    hostname = getUniqueHostname();
    Serial.println("No saved client ID, using generated hostname for OTA: " + hostname);
  }
  
  ArduinoOTA.setHostname(hostname.c_str());
  ArduinoOTA.setPassword("admin");
  
  // Set OTA port (default is 3232)
  ArduinoOTA.setPort(3232);
  
  ArduinoOTA.onStart([]() {
    Serial.println("=== OTA Update Started ===");
    Serial.println("Disabling watchdog during update...");
    digitalWrite(STATUS_LED, LOW);
  });
  
  ArduinoOTA.onProgress([](unsigned int progress, unsigned int total) {
    Serial.printf("OTA Progress: %u%%\n", (progress / (total / 100)));
    // Feed watchdog during progress
    yield();
  });
  
  ArduinoOTA.onEnd([]() {
    Serial.println("=== OTA Update Completed ===");
    Serial.println("Update successful, restarting...");
    digitalWrite(STATUS_LED, HIGH);
  });
  
  ArduinoOTA.onError([](ota_error_t error) {
    Serial.printf("=== OTA Error: %u ===\n", error);
    Serial.println("Error details:");
    switch (error) {
      case OTA_AUTH_ERROR:
        Serial.println("Auth Failed");
        break;
      case OTA_BEGIN_ERROR:
        Serial.println("Begin Failed");
        break;
      case OTA_CONNECT_ERROR:
        Serial.println("Connect Failed");
        break;
      case OTA_RECEIVE_ERROR:
        Serial.println("Receive Failed");
        break;
      case OTA_END_ERROR:
        Serial.println("End Failed");
        break;
      default:
        Serial.println("Unknown Error");
        break;
    }
    digitalWrite(STATUS_LED, LOW);
  });
  
  ArduinoOTA.begin();
  Serial.println("OTA ready on port 3232");
  Serial.println("You can also use Arduino IDE or other OTA tools to update");
}

void handleWiFiReconnection() {
  static unsigned long last_reconnect_attempt = 0;
  unsigned long current_time = millis();
  
  if (current_time - last_reconnect_attempt > WIFI_RECONNECT_INTERVAL) { // Try every 30 seconds
    Serial.println("Attempting WiFi reconnection...");
    WiFi.reconnect();
    last_reconnect_attempt = current_time;
  }
}

void handleMQTT() {
  if (!mqtt_client.connected()) {
    if (millis() - last_mqtt_attempt > MQTT_RETRY_INTERVAL) {
      Serial.println("üîç DEBUG: MQTT disconnected, calling mqttReconnect() from handleMQTT()");
      mqttReconnect();
      last_mqtt_attempt = millis();
    }
  } else {
    mqtt_client.loop();
  }
}

void testMQTTBrokerConnectivity() {
  Serial.println("=== Testing MQTT Broker Connectivity ===");
  Serial.println("Broker: " + mqtt_broker_ip + ":" + String(mqtt_broker_port));
  
  // Create a temporary WiFi client to test connectivity
  WiFiClient testClient;
  
  Serial.println("Attempting TCP connection to broker...");
  if (testClient.connect(mqtt_broker_ip.c_str(), mqtt_broker_port)) {
    Serial.println("‚úÖ TCP connection to broker successful");
    Serial.println("Broker is reachable on the network");
    testClient.stop();
  } else {
    Serial.println("‚ùå TCP connection to broker failed");
    Serial.println("Broker may be unreachable or port may be blocked");
    Serial.println("Check:");
    Serial.println("  - Broker IP address is correct");
    Serial.println("  - Broker is running and listening on port " + String(mqtt_broker_port));
    Serial.println("  - Network firewall allows connections to this port");
    Serial.println("  - WiFi network can reach the broker subnet");
  }
  Serial.println("===============================");
}

void mqttReconnect() {
  Serial.println("üîç DEBUG: mqttReconnect() called at " + String(millis()) + " ms");
  Serial.println("=== Attempting MQTT Connection ===");
  Serial.println("Broker: " + mqtt_broker_ip);
  Serial.println("Port: " + String(mqtt_broker_port));
  Serial.println("Client ID: " + String(MQTT_CLIENT_ID));
  Serial.println("WiFi Status: " + String(WiFi.status()));
  Serial.println("WiFi IP: " + WiFi.localIP().toString());
  
  if (mqtt_client.connect(MQTT_CLIENT_ID)) {
    Serial.println("‚úÖ MQTT connected successfully!");
    mqtt_connected = true;
    
    // Subscribe to control topics (not status topics to avoid feedback loops)
    String turnout_topic = mqtt_turnout_topic + "+";
    String sensor_topic = mqtt_sensor_topic + "+";
    String light_topic = mqtt_light_topic + "+";
    
    Serial.println("Subscribing to turnout topic: " + turnout_topic);
    mqtt_client.subscribe(turnout_topic.c_str());
    
    Serial.println("Subscribing to sensor topic: " + sensor_topic);
    mqtt_client.subscribe(sensor_topic.c_str());
    
    Serial.println("Subscribing to light topic: " + light_topic);
    mqtt_client.subscribe(light_topic.c_str());
    
    Serial.println("Subscriptions completed");
    
    // Request retained messages for initial state sync
    Serial.println("Requesting retained messages for state synchronization...");
    delay(1000); // Give broker time to send retained messages
    
    // Process retained messages multiple times to ensure we get them all
    for (int i = 0; i < 10; i++) {
      mqtt_client.loop();
      delay(100);
    }
    
    Serial.println("=== Current States After MQTT Sync ===");
    Serial.println("Turnout 1: " + String(turnout_states[0] ? "THROWN" : "CLOSED"));
    Serial.println("Turnout 2: " + String(turnout_states[1] ? "THROWN" : "CLOSED"));
    Serial.println("Turnouts: " + String(turnout_states[0] ? "THROWN" : "CLOSED") + " / " + String(turnout_states[1] ? "THROWN" : "CLOSED"));
    Serial.println("Lights: " + String(light_states[0] ? "ON" : "OFF") + " " + String(light_states[1] ? "ON" : "OFF") + " " + String(light_states[2] ? "ON" : "OFF") + " " + String(light_states[3] ? "ON" : "OFF") + " " + String(light_states[4] ? "ON" : "OFF") + " " + String(light_states[5] ? "ON" : "OFF"));
    Serial.println("=====================================");
    
    // Skip initial status publish - we now sync from retained messages
    // The ESP32 state is now controlled by JMRI via retained messages
    Serial.println("Skipping initial status publish - using retained message states");
    
    Serial.println("=== MQTT Setup Complete ===");
  } else {
    Serial.printf("‚ùå MQTT connection failed, rc=%d\n", mqtt_client.state());
    Serial.println("Error codes:");
    Serial.println("  -4: MQTT_CONNECTION_TIMEOUT");
    Serial.println("  -3: MQTT_CONNECTION_LOST");
    Serial.println("  -2: MQTT_CONNECT_FAILED");
    Serial.println("  -1: MQTT_DISCONNECTED");
    Serial.println("   0: MQTT_CONNECTED");
    Serial.println("   1: MQTT_CONNECT_BAD_PROTOCOL");
    Serial.println("   2: MQTT_CONNECT_BAD_CLIENT_ID");
    Serial.println("   3: MQTT_CONNECT_UNAVAILABLE");
    Serial.println("   4: MQTT_CONNECT_BAD_CREDENTIALS");
    Serial.println("   5: MQTT_CONNECT_UNAUTHORIZED");
    mqtt_connected = false;
  }
}



void mqttCallback(char* topic, byte* payload, unsigned int length) {
  String topic_str = String(topic);
  String payload_str = "";
  
  for (int i = 0; i < length; i++) {
    payload_str += (char)payload[i];
  }
  
  Serial.println("=== MQTT Message Received ===");
  Serial.println("  Topic: " + topic_str);
  Serial.println("  Payload: " + payload_str);
  Serial.println("  Length: " + String(length) + " bytes");
  Serial.println("  From Broker: " + mqtt_broker_ip + ":" + String(mqtt_broker_port));
  Serial.println("  Timestamp: " + String(millis()) + " ms");
  Serial.println("  Is Retained: " + String(length > 0 ? "Unknown" : "Unknown")); // MQTT lib doesn't expose retain flag
  
  // Always process messages during first 30 seconds (boot sync period)
  bool isBootSync = (millis() < 30000);
  
  if (isBootSync) {
    Serial.println("  üöÄ Processing message during boot sync period");
  }
  
  // Ignore $SYS topics
  if (topic_str.startsWith("$SYS")) {
    Serial.println("  ‚ÑπÔ∏è Ignoring $SYS topic");
    Serial.println("================================");
    return;
  }
  
  Serial.println("================================");
  
  // Handle turnout control messages
  if (topic_str.indexOf("/turnout/") > 0) {
    Serial.println("üéØ Processing turnout control message");
    
    // Check if this is a feedback loop from our own recent publication
    if (isOurOwnMessage(topic_str, payload_str)) {
      Serial.println("  üîÑ Ignoring our own message to prevent feedback loop");
      return;
    }
    
    handleTurnoutControl(topic_str, payload_str);
  }
  
  // Handle light control messages
  if (topic_str.indexOf("/light/") > 0) {
    Serial.println("üéØ Processing light control message");
    Serial.println("  Full topic: " + topic_str);
    Serial.println("  Payload: " + payload_str);
    Serial.println("  Topic contains '/light/': " + String(topic_str.indexOf("/light/")));
    
    // Check if this is a feedback loop from our own recent publication
    if (isOurOwnMessage(topic_str, payload_str)) {
      Serial.println("  üîÑ Ignoring our own message to prevent feedback loop");
      return;
    }
    
    handleLightControl(topic_str, payload_str);
  }
  
  // Handle sensor truth verification - respond with actual state if different
  if (topic_str.indexOf("/sensor/") > 0) {
    Serial.println("üéØ Processing sensor verification message");
    Serial.println("  Sensor topic detected: " + topic_str);
    Serial.println("  Payload: " + payload_str);
    Serial.println("  Current sensor states:");
    for (int i = 0; i < 4; i++) {  // Changed from 3 to 4 sensors
      Serial.println("    Sensor " + String(i+1) + ": " + String(sensor_states[i] ? "ACTIVE" : "INACTIVE"));
    }
    handleSensorVerification(topic_str, payload_str);
  }
}

void handleTurnoutControl(String topic, String payload) {
  // Extract turnout ID from topic (e.g., "track/turnout/7" -> ID 7)
  String turnout_id_str = "";
  
  // Find the last number in the topic
  int lastSlash = topic.lastIndexOf('/');
  if (lastSlash > 0) {
    turnout_id_str = topic.substring(lastSlash + 1);
  }
  
  // Find which physical turnout this ID maps to
  int physical_turnout = 0;
  for (int i = 1; i <= 2; i++) {
    String stored_id = preferences.getString(("turnout_" + String(i) + "_id").c_str(), String(i));
    if (stored_id == turnout_id_str) {
      physical_turnout = i;
      break;
    }
  }
  
  // Validate turnout number
  if (physical_turnout < 1 || physical_turnout > 2) {
    Serial.println("‚ùå Error: Invalid turnout ID: " + turnout_id_str);
    Serial.println("No physical turnout found with this ID");
    Serial.println("=====================");
    return;
  }
  
  int turnout_num = physical_turnout - 1;  // Convert to 0-based index
  
  Serial.println("=== Turnout Control ===");
  Serial.println("Turnout ID: " + turnout_id_str);
  Serial.println("Physical Turnout: " + String(physical_turnout));
  Serial.println("Topic: " + topic);
  Serial.println("Payload: " + payload);
  Serial.println("Current state: " + String(turnout_states[turnout_num] ? "THROWN" : "CLOSED"));
  
  bool state_changed = false;
  
  if (payload == "THROWN") {
    Serial.println("üéØ Requested position: THROWN");
    
    if (turnout_states[turnout_num] != true) {  // Only change if state is different
      state_changed = true;
    
    if (turnout_num == 0) {
        digitalWrite(TURNOUT_PIN_1, HIGH);
        turnout_states[0] = true;
        Serial.println("‚úÖ Turnout 1 pin " + String(TURNOUT_PIN_1) + " set to HIGH");
    } else if (turnout_num == 1) {
        digitalWrite(TURNOUT_PIN_2, HIGH);
        turnout_states[1] = true;
        Serial.println("‚úÖ Turnout 2 pin " + String(TURNOUT_PIN_2) + " set to HIGH");
      }
      
      Serial.println("‚úÖ Turnout " + String(turnout_num + 1) + " moved to THROWN");
    } else {
      Serial.println("‚ÑπÔ∏è Turnout " + String(turnout_num + 1) + " already in THROWN position");
    }
    
  } else if (payload == "CLOSED") {
    Serial.println("üéØ Requested position: CLOSED");
    
    if (turnout_states[turnout_num] != false) {  // Only change if state is different
      state_changed = true;
      
      if (turnout_num == 0) {
        digitalWrite(TURNOUT_PIN_1, LOW);
        turnout_states[0] = false;
        Serial.println("‚úÖ Turnout 1 pin " + String(TURNOUT_PIN_1) + " set to LOW");
      } else if (turnout_num == 1) {
        digitalWrite(TURNOUT_PIN_2, LOW);
        turnout_states[1] = false;
        Serial.println("‚úÖ Turnout 2 pin " + String(TURNOUT_PIN_2) + " set to LOW");
      }
      
      Serial.println("‚úÖ Turnout " + String(turnout_num + 1) + " moved to CLOSED");
    } else {
      Serial.println("‚ÑπÔ∏è Turnout " + String(turnout_num + 1) + " already in CLOSED position");
    }
    
  } else if (payload == "toggle") {
    // Toggle the current state
    turnout_states[turnout_num] = !turnout_states[turnout_num];
    digitalWrite(turnout_num == 0 ? TURNOUT_PIN_1 : TURNOUT_PIN_2, turnout_states[turnout_num] ? HIGH : LOW);
    String newState = turnout_states[turnout_num] ? "THROWN" : "CLOSED";
    Serial.println("Turnout " + String(turnout_num + 1) + " toggled to " + newState);
    state_changed = true;
  } else {
    Serial.println("‚ùå Unknown position specified in turnout control message: " + payload);
    Serial.println("=====================");
    return;
  }
  
  // Don't publish when state changes due to MQTT commands
  // JMRI already knows it sent the command, no need to echo back
  if (state_changed) {
    Serial.println("üîÑ State changed due to MQTT command, but not publishing back to JMRI");
    Serial.println("‚ÑπÔ∏è JMRI already knows it sent this command - no echo needed");
  } else {
    Serial.println("‚ÑπÔ∏è No state change, already in requested state");
  }
  
  Serial.println("=====================");
}

/*
 * Handle light control messages from JMRI
 * 
 * RACE CONDITION PREVENTION:
 * - Only change state and publish if it's actually different from current state
 * - This prevents feedback loops where JMRI sends a command and we echo back unnecessarily
 * - Uses the same pattern as turnout control for consistency
 */
void handleLightControl(String topic, String payload) {
  // Extract light ID from topic (e.g., "track/light/7" -> ID 7)
  String light_id_str = "";
  
  // Find the last number in the topic
  int lastSlash = topic.lastIndexOf('/');
  if (lastSlash > 0) {
    light_id_str = topic.substring(lastSlash + 1);
  }
  
  // Find which physical light this ID maps to
  int physical_light = 0;
  for (int i = 1; i <= 6; i++) {
    String stored_id = preferences.getString(("light_" + String(i) + "_id").c_str(), String(i));
    if (stored_id == light_id_str) {
      physical_light = i;
      break;
    }
  }
  
  // Validate light number
  if (physical_light < 1 || physical_light > 6) {
    Serial.println("‚ùå Error: Invalid light ID: " + light_id_str);
    Serial.println("No physical light found with this ID");
    Serial.println("=====================");
    return;
  }
  
  int light_num = physical_light - 1;  // Convert to 0-based index
  
  Serial.println("=== Light Control ===");
  Serial.println("Light ID: " + light_id_str);
  Serial.println("Physical Light: " + String(physical_light));
  Serial.println("Topic: " + topic);
  Serial.println("Payload: " + payload);
  Serial.println("Current state: " + String(light_states[light_num] ? "ON" : "OFF"));
  
  bool state_changed = false;
  
  if (payload == "ON") {
    Serial.println("üéØ Requested state: ON");
    
    if (light_states[light_num] != true) {
      state_changed = true;
      light_states[light_num] = true;
      Serial.println("‚úÖ Light " + String(light_num + 1) + " set to ON");
    } else {
      Serial.println("‚ÑπÔ∏è Light " + String(light_num + 1) + " is already ON");
    }
  } else if (payload == "OFF") {
    Serial.println("üéØ Requested state: OFF");
    
    if (light_states[light_num] != false) {
      state_changed = true;
      light_states[light_num] = false;
      Serial.println("‚úÖ Light " + String(light_num + 1) + " set to OFF");
    } else {
      Serial.println("‚ÑπÔ∏è Light " + String(light_num + 1) + " is already OFF");
    }
  } else {
    Serial.println("‚ùå Unknown state specified in light control message: " + payload);
    Serial.println("=====================");
    return;
  }
  
  // Don't publish when state changes due to MQTT commands
  // JMRI already knows it sent the command, no need to echo back
  if (state_changed) {
    Serial.println("üîÑ State changed due to MQTT command, but not publishing back to JMRI");
    Serial.println("‚ÑπÔ∏è JMRI already knows it sent this command - no echo needed");
  } else {
    Serial.println("‚ÑπÔ∏è No state change, already in requested state");
  }
  
  Serial.println("=====================");
}

void handleSensorVerification(String topic, String payload) {
  Serial.println("=== Sensor Verification START ===");
  
  // Extract sensor ID from topic (e.g., "trains/track/sensor/7" -> ID 7)
  String sensor_id_str = "";
  
  // Find the last number in the topic
  int lastSlash = topic.lastIndexOf('/');
  if (lastSlash > 0) {
    sensor_id_str = topic.substring(lastSlash + 1);
    Serial.println("  Extracted sensor ID: " + sensor_id_str);
  }
  
  // Find which physical sensor this ID maps to
  int physical_sensor = 0;
  for (int i = 1; i <= 4; i++) {
    String stored_id = preferences.getString(("sensor_" + String(i) + "_id").c_str(), String(i));
    if (stored_id == sensor_id_str) {
      physical_sensor = i;
      break;
    }
  }
  
  // Validate sensor number
  if (physical_sensor < 1 || physical_sensor > 4) {
    Serial.println("‚ùå Error: Invalid sensor ID: " + sensor_id_str);
    Serial.println("No physical sensor found with this ID");
    Serial.println("=====================");
    return;
  }
  
  int sensor_num = physical_sensor;
  
  Serial.println("  Physical Sensor: " + String(physical_sensor));
  Serial.println("  Sensor ID: " + sensor_id_str);
  
  String actual_state = sensor_states[sensor_num - 1] ? "ACTIVE" : "INACTIVE";
  
  Serial.println("=== Sensor Verification ===");
  Serial.println("Sensor: " + String(sensor_num));
  Serial.println("Topic: " + topic);
  Serial.println("JMRI expects: " + payload);
  Serial.println("Actual physical state: " + actual_state);
  
  // Get the correct pin for the sensor number
  int pin_to_read;
  switch(sensor_num) {
    case 1: pin_to_read = SENSOR_PIN_1; break;
    case 2: pin_to_read = SENSOR_PIN_2; break;
    case 3: pin_to_read = SENSOR_PIN_3; break;
    case 4: pin_to_read = SENSOR_PIN_4; break;
    default: pin_to_read = SENSOR_PIN_1; break;
  }
  Serial.println("Physical pin state: " + String(digitalRead(pin_to_read)));
  
  // Only publish if JMRI's expectation differs from reality
  if (payload != actual_state) {
    Serial.println("‚ö†Ô∏è MISMATCH: JMRI expects '" + payload + "' but sensor is actually '" + actual_state + "'");
    Serial.println("üì§ Publishing correct sensor state to update JMRI...");
    publishSensorStatus(sensor_num);
  } else {
    Serial.println("‚úÖ JMRI state matches actual sensor state - no publish needed");
  }
  
  Serial.println("=== Sensor Verification END ===");
}

void handleSensors() {
  // Read sensor states (inverted because of pull-up resistors)
  sensor_states[0] = !digitalRead(SENSOR_PIN_1);
  sensor_states[1] = !digitalRead(SENSOR_PIN_2);
  sensor_states[2] = !digitalRead(SENSOR_PIN_3);
  sensor_states[3] = !digitalRead(SENSOR_PIN_4);
  
  // Check for changes and publish if needed
  for (int i = 0; i < 4; i++) {  // Changed from 3 to 4 sensors
    if (sensor_states[i] != last_sensor_states[i]) {
      Serial.println("Sensor " + String(i + 1) + " state changed from " + 
                    String(last_sensor_states[i] ? "ACTIVE" : "INACTIVE") + " to " + 
                    String(sensor_states[i] ? "ACTIVE" : "INACTIVE"));
      
      last_sensor_states[i] = sensor_states[i];
      publishSensorStatus(i + 1);
    }
  }
}

void publishSensorStatus(int sensor_num) {
  if (!mqtt_connected) return;
  
  // Get the custom ID for this sensor
  String customId = preferences.getString(("sensor_" + String(sensor_num) + "_id").c_str(), String(sensor_num));
  
  String topic = mqtt_sensor_topic + customId;
  String payload = sensor_states[sensor_num - 1] ? "ACTIVE" : "INACTIVE";
  
  // Track this publication to prevent feedback loops
  trackPublication(topic, payload, false); // false = not from web GUI
  
  mqtt_client.publish(topic.c_str(), payload.c_str(), true); // Retained message
  
  Serial.println("Published sensor " + String(sensor_num) + " (ID: " + customId + ") status: " + payload + " to topic: " + topic);
  Serial.println("  Debug: sensor_num=" + String(sensor_num) + ", customId=" + customId + ", topic=" + topic);
}

void publishTurnoutStatus(int turnout_num, bool fromWebGui = false) {
  if (!mqtt_connected) return;
  
  // Get the custom ID for this turnout
  String customId = preferences.getString(("turnout_" + String(turnout_num) + "_id").c_str(), String(turnout_num));
  
  String topic = mqtt_turnout_topic + customId;
  String payload = turnout_states[turnout_num - 1] ? "THROWN" : "CLOSED";
  
  // Track this publication to prevent feedback loops
  trackPublication(topic, payload, fromWebGui);
  
  mqtt_client.publish(topic.c_str(), payload.c_str(), true); // Retained message
  
  Serial.println("Published turnout " + String(turnout_num) + " (ID: " + customId + ") status: " + payload + " to topic: " + topic);
  Serial.println("  Debug: turnout_num=" + String(turnout_num) + ", customId=" + customId + ", topic=" + topic);
  if (fromWebGui) {
    Serial.println("  üì± Published from web GUI");
  }
}

void publishLightStatus(int light_num, bool lightState, bool fromWebGui = false) {
  if (!mqtt_connected) return;
  
  // Get the custom ID for this light
  String customId = preferences.getString(("light_" + String(light_num) + "_id").c_str(), String(light_num));
  
  String topic = mqtt_light_topic + customId;
  String state = lightState ? "ON" : "OFF";
  
  // Track this publication to prevent feedback loops
  trackPublication(topic, state, fromWebGui);
  
  mqtt_client.publish(topic.c_str(), state.c_str(), true); // Retained message
  
  Serial.println("Published light " + String(light_num) + " (ID: " + customId + ") status: " + state + " to topic: " + topic);
  Serial.println("  Debug: light_num=" + String(light_num) + ", customId=" + customId + ", topic=" + topic);
  if (fromWebGui) {
    Serial.println("  üì± Published from web GUI");
  }
}

// publishInitialStatus() function removed - no longer needed
// Device states are now synced from retained MQTT messages on boot

// Removed publishAllDeviceStatus() - only publish when states actually change

// Removed publishStatus() and updateStatus() functions
// MQTT status is now only published when device states actually change

// Web server handlers
void handleRoot() {
  String html = getMainPageHTML();
  
  // Get unique client ID for banner display
  String uniqueClientId = getUniqueClientId();
  
  // Substitute placeholders with actual values for display
  html.replace("CLIENT_ID_PLACEHOLDER", preferences.getString("mqtt_client_id", uniqueClientId));
  html.replace("IP_ADDRESS_PLACEHOLDER", WiFi.localIP().toString());
  html.replace("WIFI_STATUS_PLACEHOLDER", WiFi.status() == WL_CONNECTED ? 
    "<span class=\"status-badge status-connected\">WiFi Connected</span>" : 
    "<span class=\"status-badge status-disconnected\">WiFi Disconnected</span>");
  html.replace("MQTT_STATUS_PLACEHOLDER", mqtt_client.connected() ? 
    "<span class=\"status-badge status-connected\">Connected</span>" : 
    "<span class=\"status-badge status-disconnected\">Disconnected</span>");
  
  // Get the hostname for display
  String savedClientId = preferences.getString("mqtt_client_id", "");
  String hostname;
  if (savedClientId.length() > 0) {
    hostname = savedClientId + ".local";
  } else {
    hostname = getUniqueHostname() + ".local";
  }
  html.replace("HOSTNAME_PLACEHOLDER", hostname);
  
  // Replace form field placeholders with actual saved values from preferences
  // This ensures the form shows current saved settings, not default config values
  html.replace("WIFI_SSID_PLACEHOLDER", wifi_ssid);
  html.replace("WIFI_PASSWORD_PLACEHOLDER", wifi_password);
  html.replace("MQTT_BROKER_PLACEHOLDER", mqtt_broker_ip);
  html.replace("MQTT_PORT_PLACEHOLDER", String(mqtt_broker_port));
  html.replace("MQTT_CLIENT_ID_PLACEHOLDER", preferences.getString("mqtt_client_id", uniqueClientId));
  html.replace("MQTT_CHANNEL_NAME_PLACEHOLDER", preferences.getString("mqtt_channel_name", MQTT_CHANNEL_NAME));
  html.replace("MQTT_TOPIC_PREFIX_PLACEHOLDER", preferences.getString("mqtt_topic_prefix", MQTT_TOPIC_PREFIX));
  html.replace("FIRMWARE_VERSION_PLACEHOLDER", String(FIRMWARE_VERSION));
  
  web_server.send(200, "text/html", html);
}

// Handler for /devices endpoint - returns device table HTML
void handleDevices() {
  web_server.send(200, "text/html", getDeviceTableHTML());
}

// Handler for /config endpoint - returns current configuration as JSON
void handleConfig() {
  DynamicJsonDocument doc(512);
  
  // Get unique client ID for default value
  String uniqueClientId = getUniqueClientId();
  
  doc["wifi_ssid"] = wifi_ssid;
  doc["wifi_password"] = wifi_password;
  doc["mqtt_broker"] = mqtt_broker_ip;
  doc["mqtt_port"] = mqtt_broker_port;
  doc["mqtt_client_id"] = preferences.getString("mqtt_client_id", uniqueClientId);
  doc["mqtt_channel_name"] = preferences.getString("mqtt_channel_name", MQTT_CHANNEL_NAME);
  doc["mqtt_topic_prefix"] = preferences.getString("mqtt_topic_prefix", MQTT_TOPIC_PREFIX);
  
  String response;
  serializeJson(doc, response);
  web_server.send(200, "application/json", response);
}

void handleWiFiConfig() {
  if (web_server.hasArg("ssid") && web_server.hasArg("password")) {
    String new_ssid = web_server.arg("ssid");
    String new_password = web_server.arg("password");
    
    // Save to preferences
    preferences.putString("wifi_ssid", new_ssid);
    preferences.putString("wifi_password", new_password);
    
    wifi_ssid = new_ssid;
    wifi_password = new_password;
    wifi_configured = true;
    
    // Restart WiFi connection
    WiFi.disconnect();
    delay(1000);
    WiFi.begin(wifi_ssid.c_str(), wifi_password.c_str());
    
    web_server.send(200, "text/plain", "WiFi configuration saved. Device will connect to the new network.");
  } else {
    web_server.send(400, "text/plain", "Missing SSID or password");
  }
}

void handleMQTTConfig() {
  if (web_server.hasArg("mqtt_broker") && web_server.hasArg("mqtt_port") && web_server.hasArg("mqtt_client_id") && web_server.hasArg("mqtt_channel_name") && web_server.hasArg("mqtt_topic_prefix")) {
    String new_broker = web_server.arg("mqtt_broker");
    int new_port = web_server.arg("mqtt_port").toInt();
    String new_client_id = web_server.arg("mqtt_client_id");
    String new_channel_name = web_server.arg("mqtt_channel_name");
    String new_topic_prefix = web_server.arg("mqtt_topic_prefix");

    Serial.println("=== MQTT Configuration Update ===");
    Serial.println("New Broker: " + new_broker);
    Serial.println("New Port: " + String(new_port));
    Serial.println("New Client ID: " + new_client_id);
    Serial.println("New Channel Name: " + new_channel_name);
    Serial.println("New Topic Prefix: " + new_topic_prefix);

    // Save to preferences
    preferences.putString("mqtt_broker", new_broker);
    preferences.putInt("mqtt_port", new_port);
    preferences.putString("mqtt_client_id", new_client_id);
    preferences.putString("mqtt_channel_name", new_channel_name);
    preferences.putString("mqtt_topic_prefix", new_topic_prefix);

    // Update global variables
    mqtt_broker_ip = new_broker;
    mqtt_broker_port = new_port;
    mqtt_channel_name = new_channel_name;

    // Update MQTT client settings
    mqtt_client.disconnect();
    mqtt_client.setServer(new_broker.c_str(), new_port);
    
    // Update topic strings with channel name prefix
    String channel_prefix = mqtt_channel_name;
    if (!channel_prefix.startsWith("/")) {
      channel_prefix = "/" + channel_prefix;
    }
    mqtt_base_topic = channel_prefix + String(new_topic_prefix) + "/";
    mqtt_sensor_topic = mqtt_base_topic + "sensor/";
    mqtt_turnout_topic = mqtt_base_topic + "turnout/";
    mqtt_light_topic = mqtt_base_topic + "light/";
    mqtt_status_topic = mqtt_base_topic + "status/";

    Serial.println("Updated topic strings:");
    Serial.println("  Base: " + mqtt_base_topic);
    Serial.println("  Sensors: " + mqtt_sensor_topic);
    Serial.println("  Turnouts: " + mqtt_turnout_topic);
    Serial.println("  Signals: " + mqtt_light_topic); // Changed from signal to light
    Serial.println("  Status: " + mqtt_status_topic);

    // Disconnect current MQTT connection
    Serial.println("Disconnecting current MQTT connection...");
    mqtt_client.disconnect();
    mqtt_connected = false;
    delay(1000);
    
    // Try to reconnect with new settings
    Serial.println("Attempting to reconnect with new MQTT settings...");
    if (mqtt_client.connect(new_client_id.c_str())) {
      Serial.println("‚úÖ MQTT reconnected with new configuration successfully!");
      mqtt_connected = true;
      
      // Resubscribe to control topics
      String turnout_topic = mqtt_turnout_topic + "+";
      String sensor_topic = mqtt_sensor_topic + "+";
      String light_topic = mqtt_light_topic + "+";
      
      Serial.println("Resubscribing to turnout topic: " + turnout_topic);
      mqtt_client.subscribe(turnout_topic.c_str());
      
      Serial.println("Resubscribing to sensor topic: " + sensor_topic);
      mqtt_client.subscribe(sensor_topic.c_str());

      Serial.println("Resubscribing to light topic: " + light_topic);
      mqtt_client.subscribe(light_topic.c_str());
      
      // Skip republishing status on config changes - JMRI already knows current states
      Serial.println("Skipping status republish (no state changes)");
      
      Serial.println("=== MQTT Reconfiguration Complete ===");
    } else {
      Serial.println("‚ùå Failed to reconnect to MQTT with new configuration");
      Serial.printf("Error code: %d\n", mqtt_client.state());
      mqtt_connected = false;
    }

    web_server.send(200, "text/plain", "MQTT configuration saved. Device will reconnect to MQTT broker.");
  } else {
    web_server.send(400, "text/plain", "Missing MQTT configuration parameters (broker, port, client_id, channel_name, or topic_prefix)");
  }
}

void handleStatus() {
  DynamicJsonDocument doc(2048); // Increased size for more data
  
  // Add sensor states - dynamically count how many exist
  JsonArray sensorArray = doc.createNestedArray("sensor_states");
  int sensorCount = 0;
  for (int i = 1; i <= 10; i++) {
    String id = preferences.getString(("sensor_" + String(i) + "_id").c_str(), "");
    if (id != "" && id != "NOT_FOUND") {
      sensorCount++;
      JsonObject sensor = sensorArray.createNestedObject();
      sensor["sensor"] = i;
      sensor["state"] = (i <= 4) ? (sensor_states[i-1] ? "ACTIVE" : "INACTIVE") : "INACTIVE";
      sensor["label"] = preferences.getString(("sensor_" + String(i) + "_label").c_str(), ("Sensor " + String(i)).c_str());
      sensor["id"] = id;
      sensor["pin"] = preferences.getString(("sensor_" + String(i) + "_pin").c_str(), getSensorPin(i));
      sensor["type"] = preferences.getString(("sensor_" + String(i) + "_type").c_str(), "sensor");
    }
  }
  
  // Add turnout states - dynamically count how many exist
  JsonArray turnoutArray = doc.createNestedArray("turnout_states");
  int turnoutCount = 0;
  for (int i = 1; i <= 10; i++) {
    String id = preferences.getString(("turnout_" + String(i) + "_id").c_str(), "");
    if (id != "" && id != "NOT_FOUND") {
      turnoutCount++;
      JsonObject turnout = turnoutArray.createNestedObject();
      turnout["turnout"] = i;
      turnout["position"] = (i <= 2) ? (turnout_states[i-1] ? "THROWN" : "CLOSED") : "CLOSED";
      turnout["label"] = preferences.getString(("turnout_" + String(i) + "_label").c_str(), ("Turnout " + String(i)).c_str());
      turnout["id"] = id;
      turnout["pin"] = preferences.getString(("turnout_" + String(i) + "_pin").c_str(), getTurnoutPin(i));
      turnout["type"] = preferences.getString(("turnout_" + String(i) + "_type").c_str(), "turnout");
    }
  }
  
  // Add individual light states - dynamically count how many exist
  JsonArray lightArray = doc.createNestedArray("lights");
  int lightCount = 0;
  for (int i = 1; i <= 10; i++) {
    String id = preferences.getString(("light_" + String(i) + "_id").c_str(), "");
    if (id != "" && id != "NOT_FOUND") {
      lightCount++;
      JsonObject light = lightArray.createNestedObject();
      light["light"] = i;
      light["state"] = (i <= 6) ? (light_states[i-1] ? "ON" : "OFF") : "OFF";
      light["label"] = preferences.getString(("light_" + String(i) + "_label").c_str(), ("Light " + String(i)).c_str());
      light["id"] = id;
      light["pin"] = preferences.getString(("light_" + String(i) + "_pin").c_str(), getLightPin(i));
      light["type"] = preferences.getString(("light_" + String(i) + "_type").c_str(), "light");
    }
  }
  
  // Add all pin configurations for the device table
  JsonArray allPinsArray = doc.createNestedArray("all_pins");
  
  // Define all available pins (same as in JavaScript)
  int allPins[] = {13,14,18,19,21,22,23,25,26,27,32,33,34,35,36,39};
  
  for (int pinNum : allPins) {
    JsonObject pin = allPinsArray.createNestedObject();
    pin["pin"] = pinNum;
    
    // Check if this pin has a saved device type
    String deviceType = preferences.getString(("pin_" + String(pinNum) + "_type").c_str(), "unused");
    String deviceLabel = preferences.getString(("pin_" + String(pinNum) + "_label").c_str(), "");
    String deviceId = preferences.getString(("pin_" + String(pinNum) + "_id").c_str(), "");
    
    pin["device_type"] = deviceType;
    pin["device_label"] = deviceLabel;
    pin["device_id"] = deviceId;
    
    // Determine if this pin is currently active (has a device assigned)
    bool isActive = false;
    if (deviceType == "sensor") {
      // Check if this pin matches any sensor pin
      if (String(pinNum) == getSensorPin(1) || String(pinNum) == getSensorPin(2) || 
          String(pinNum) == getSensorPin(3) || String(pinNum) == getSensorPin(4)) {
        isActive = true;
      }
    } else if (deviceType == "turnout") {
      // Check if this pin matches any turnout pin
      if (String(pinNum) == getTurnoutPin(1) || String(pinNum) == getTurnoutPin(2)) {
        isActive = true;
      }
    } else if (deviceType == "light") {
      // Check if this pin matches any light pin
      if (String(pinNum) == getLightPin(1) || String(pinNum) == getLightPin(2) || 
          String(pinNum) == getLightPin(3) || String(pinNum) == getLightPin(4) ||
          String(pinNum) == getLightPin(5) || String(pinNum) == getLightPin(6)) {
        isActive = true;
      }
    }
    
    pin["is_active"] = isActive;
  }
  
  // Add system info
  doc["version"] = FIRMWARE_VERSION;
  doc["mqtt_connected"] = mqtt_connected;
  doc["wifi_connected"] = WiFi.status() == WL_CONNECTED;
  
  String response;
  serializeJson(doc, response);
  web_server.send(200, "application/json", response);
}

void handleDeviceControl() {
  if (!web_server.hasArg("type") || !web_server.hasArg("number") || !web_server.hasArg("action")) {
    web_server.send(400, "text/plain", "Missing required parameters");
    return;
  }
  
  String type = web_server.arg("type");
  int number = web_server.arg("number").toInt();
  String action = web_server.arg("action");
  
  Serial.println("=== Device Control Request ===");
  Serial.println("Type: " + type);
  Serial.println("Number: " + String(number));
  Serial.println("Action: " + action);
  
  if (type == "turnout") {
    if (number < 1 || number > 2) {
      web_server.send(400, "text/plain", "Invalid turnout number");
      return;
    }
    
    if (action == "THROWN") {
      turnout_states[number - 1] = true;
      digitalWrite(number == 1 ? TURNOUT_PIN_1 : TURNOUT_PIN_2, HIGH);
      Serial.println("Turnout " + String(number) + " set to THROWN");
    } else if (action == "CLOSED") {
      turnout_states[number - 1] = false;
      digitalWrite(number == 1 ? TURNOUT_PIN_1 : TURNOUT_PIN_2, LOW);
      Serial.println("Turnout " + String(number) + " set to CLOSED");
    } else if (action == "toggle") {
      // Toggle the current state
      turnout_states[number - 1] = !turnout_states[number - 1];
      digitalWrite(number == 1 ? TURNOUT_PIN_1 : TURNOUT_PIN_2, turnout_states[number - 1] ? HIGH : LOW);
      String newState = turnout_states[number - 1] ? "THROWN" : "CLOSED";
      Serial.println("Turnout " + String(number) + " toggled to " + newState);
    } else {
      web_server.send(400, "text/plain", "Invalid turnout action");
      return;
    }
    
    // Publish status to JMRI so it knows about the state change
    publishTurnoutStatus(number, true); // true = from web GUI
    Serial.println("State change from web GUI - published to MQTT for JMRI awareness");
    
  } else if (type == "light") {
    // Handle light control for signal heads
    if (number < 1 || number > 6) {
      web_server.send(400, "text/plain", "Invalid light number");
      return;
    }
    
    // Toggle the light state
    bool newState = false;
    if (number == 1) {
      light_states[0] = !light_states[0];
      newState = light_states[0];
      digitalWrite(LIGHT_PIN_1, newState ? HIGH : LOW);
    } else if (number == 2) {
      light_states[1] = !light_states[1];
      newState = light_states[1];
      digitalWrite(LIGHT_PIN_2, newState ? HIGH : LOW);
    } else if (number == 3) {
      light_states[2] = !light_states[2];
      newState = light_states[2];
      digitalWrite(LIGHT_PIN_3, newState ? HIGH : LOW);
    } else if (number == 4) {
      light_states[3] = !light_states[3];
      newState = light_states[3];
      digitalWrite(LIGHT_PIN_4, newState ? HIGH : LOW);
    } else if (number == 5) {
      light_states[4] = !light_states[4];
      newState = light_states[4];
      digitalWrite(LIGHT_PIN_5, newState ? HIGH : LOW);
    } else if (number == 6) {
      light_states[5] = !light_states[5];
      newState = light_states[5];
      digitalWrite(LIGHT_PIN_6, newState ? HIGH : LOW);
    }
    
    Serial.println("Light " + String(number) + " toggled to " + (newState ? "ON" : "OFF"));
    
    // Publish status to JMRI so it knows about the state change
    publishLightStatus(number, newState, true); // true = from web GUI
    Serial.println("State change from web GUI - published to MQTT for JMRI awareness");
    
  } else {
    web_server.send(400, "text/plain", "Invalid device type");
    return;
  }
  
  web_server.send(200, "text/plain", "Device control successful");
}

void handleRestart() {
  web_server.send(200, "text/plain", "Device restarting...");
  delay(1000);
  ESP.restart();
}

void handleReset() {
  Serial.println("=== FACTORY RESET REQUESTED ===");
  web_server.send(200, "text/plain", "Clearing all saved variables and restarting...");
  
  // Clear all stored preferences
  preferences.clear();
  Serial.println("All preferences cleared");
  
  // Give a moment for the response to be sent
  delay(2000);
  
  Serial.println("Restarting with factory defaults...");
  ESP.restart();
}



void handleDoUpdate() {
  web_server.sendHeader("Connection", "close");
  
  if (Update.hasError()) {
    String error_msg = "Update failed: " + String(Update.errorString());
    Serial.println(error_msg);
    web_server.send(500, "text/plain", error_msg);
  } else {
    Serial.println("Update successful, restarting device...");
    web_server.send(200, "text/plain", "Update successful! Device will restart in 3 seconds...");
    delay(3000);
    ESP.restart();
  }
}

// Static variable to track if update has been initialized
static bool updateInitialized = false;

void handleUpdateBody() {
  HTTPUpload& upload = web_server.upload();
  
  if (upload.status == UPLOAD_FILE_START) {
    Serial.println("=== OTA Update Started ===");
    Serial.println("File name: " + upload.filename);
    Serial.println("Upload status: " + String(upload.status));
    
    // Check if we have enough free space
    size_t freeSpace = ESP.getFreeSketchSpace();
    Serial.println("Free sketch space: " + String(freeSpace) + " bytes");
    
    if (freeSpace < 100000) {  // Less than 100KB free
      Serial.println("‚ùå Error: Insufficient free space for update");
                return;
            }
            
    // Debug upload information
    Serial.println("Upload total size: " + String(upload.totalSize) + " bytes");
    Serial.println("Upload current size: " + String(upload.currentSize) + " bytes");
    
    Serial.println("Starting OTA update...");
    
    // Reset initialization flag
    updateInitialized = false;
    
    // Don't call Update.begin() here - wait for first write chunk to determine size
    Serial.println("‚úÖ Upload started - waiting for first chunk to determine size...");
    
  } else if (upload.status == UPLOAD_FILE_WRITE) {
    if (upload.buf == nullptr) {
      Serial.println("‚ùå Error: Upload buffer is null");
      return;
    }
    
    // Initialize Update library on first write chunk
    if (!updateInitialized) {
      Serial.println("=== First Write Chunk ===");
      Serial.println("Chunk size: " + String(upload.currentSize) + " bytes");
      
      // Debug: Check first few bytes of the chunk for firmware header
      Serial.print("First chunk header bytes: ");
      for (int i = 0; i < min(16, (int)upload.currentSize); i++) {
        Serial.printf("%02X ", upload.buf[i]);
      }
      Serial.println();
      
      // Use maximum available space and let Update library determine actual size from firmware
      size_t maxUpdateSize = (ESP.getFreeSketchSpace() - 0x1000) & 0xFFFFF000;
      Serial.println("Max update size: " + String(maxUpdateSize) + " bytes");
      
      if (!Update.begin(maxUpdateSize, U_FLASH)) {
        Serial.println("‚ùå Error: Update.begin() failed");
        Serial.println("Update error: " + String(Update.getError()));
        Update.printError(Serial);
        return;
      }
      
      updateInitialized = true;
      Serial.println("‚úÖ Update initialized successfully");
      Serial.println("Update size after begin: " + String(Update.size()) + " bytes");
    }
    
    size_t written = Update.write(upload.buf, upload.currentSize);
    if (written != upload.currentSize) {
      Serial.println("‚ùå Error: Update.write() failed");
      Serial.println("Expected: " + String(upload.currentSize) + " bytes, Written: " + String(written) + " bytes");
      Serial.println("Update error: " + String(Update.getError()));
      Serial.println("Current progress: " + String(Update.progress()) + " bytes");
      Update.printError(Serial);
    return;
  }
  
    // Calculate progress
    if (Update.size() > 0) {
      size_t progress = (Update.progress() * 100) / Update.size();
      Serial.println("üì§ Chunk written: " + String(upload.currentSize) + " bytes");
      Serial.println("üìä Progress: " + String(progress) + "% (" + String(Update.progress()) + "/" + String(Update.size()) + ")");
    }
    
  } else if (upload.status == UPLOAD_FILE_END) {
    Serial.println("=== Upload File End ===");
    Serial.println("Total bytes received: " + String(Update.progress()));
    
    // Reset initialization flag for next upload
    updateInitialized = false;
    
    if (Update.end(true)) {  // true = set new sketch as boot partition
      Serial.println("‚úÖ Update completed successfully!");
      Serial.println("Final size: " + String(Update.size()) + " bytes");
      
      if (Update.isFinished()) {
        Serial.println("‚úÖ Update is finished and verified");
        Serial.println("üîÑ Restarting device in 3 seconds...");
        delay(3000);
        ESP.restart();
    } else {
        Serial.println("‚ùå Update not finished properly");
    }
      
  } else {
      Serial.println("‚ùå Error: Update.end() failed");
      Serial.println("Update error: " + String(Update.getError()));
      Update.printError(Serial);
    }
    
    // Check for any remaining errors
    if (Update.hasError()) {
      Serial.println("‚ùå Final verification failed");
      Serial.println("Error: " + String(Update.getError()));
      Update.printError(Serial);
    }
  }
}

void handleBackup() {
  // Create a JSON document to store all preferences
  DynamicJsonDocument doc(2048); // Increased size for more settings
  
  // Add WiFi settings
  doc["wifi_ssid"] = preferences.getString("wifi_ssid", "");
  doc["wifi_password"] = preferences.getString("wifi_password", "");
  
  // Add MQTT settings
  doc["mqtt_broker"] = preferences.getString("mqtt_broker", "");
  doc["mqtt_port"] = preferences.getInt("mqtt_port", 0);
  doc["mqtt_client_id"] = preferences.getString("mqtt_client_id", "");
  doc["mqtt_channel_name"] = preferences.getString("mqtt_channel_name", "");
  doc["mqtt_topic_prefix"] = preferences.getString("mqtt_topic_prefix", "");
  
  // Add device configuration
  doc["device_name"] = DEVICE_NAME;
  doc["firmware_version"] = FIRMWARE_VERSION;
  
  // Add device settings (labels, IDs, and pins)
  JsonObject device_settings = doc.createNestedObject("device_settings");
  
  // Sensor settings
  for (int i = 1; i <= 4; i++) {
    JsonObject sensor = device_settings.createNestedObject("sensor_" + String(i));
    sensor["label"] = preferences.getString(("sensor_" + String(i) + "_label").c_str(), "Sensor " + String(i));
    sensor["id"] = preferences.getString(("sensor_" + String(i) + "_id").c_str(), String(i));
    sensor["pin"] = preferences.getString(("sensor_" + String(i) + "_pin").c_str(), getSensorPin(i));
    sensor["type"] = preferences.getString(("sensor_" + String(i) + "_type").c_str(), "sensor");
  }
  
  // Turnout settings
  for (int i = 1; i <= 2; i++) {
    JsonObject turnout = device_settings.createNestedObject("turnout_" + String(i));
    turnout["label"] = preferences.getString(("turnout_" + String(i) + "_label").c_str(), "Turnout " + String(i));
    turnout["id"] = preferences.getString(("turnout_" + String(i) + "_id").c_str(), String(i));
    turnout["pin"] = preferences.getString(("turnout_" + String(i) + "_pin").c_str(), getTurnoutPin(i));
    turnout["type"] = preferences.getString(("turnout_" + String(i) + "_type").c_str(), "turnout");
  }
  
  // Light settings
  for (int i = 1; i <= 6; i++) {
    JsonObject light = device_settings.createNestedObject("light_" + String(i));
    light["label"] = preferences.getString(("light_" + String(i) + "_label").c_str(), "Light " + String(i));
    light["id"] = preferences.getString(("light_" + String(i) + "_id").c_str(), String(i));
    light["pin"] = preferences.getString(("light_" + String(i) + "_pin").c_str(), getLightPin(i));
    light["type"] = preferences.getString(("light_" + String(i) + "_type").c_str(), "light");
  }
  
  // Also save pin-based settings for complete backup
  JsonObject pin_settings = doc.createNestedObject("pin_settings");
  int allPins[] = {13,14,18,19,21,22,23,25,26,27,32,33,34,35,36,39};
  
  for (int pinNum : allPins) {
    String deviceType = preferences.getString(("pin_" + String(pinNum) + "_type").c_str(), "unused");
    if (deviceType != "unused") {
      JsonObject pin = pin_settings.createNestedObject("pin_" + String(pinNum));
      pin["type"] = deviceType;
      pin["label"] = preferences.getString(("pin_" + String(pinNum) + "_label").c_str(), "");
      pin["id"] = preferences.getString(("pin_" + String(pinNum) + "_id").c_str(), "");
    }
  }
  
  // Add timestamp
  doc["backup_timestamp"] = String(millis());
  
  // Serialize to JSON string
  String jsonStr;
  serializeJsonPretty(doc, jsonStr);
  
  // Get unique client ID for backup filename
  String uniqueClientId = getUniqueClientId();
  String filename = uniqueClientId + "_backup_" + String(millis()) + ".json";
  
  // Send as file download
  web_server.sendHeader("Content-Disposition", "attachment; filename=" + filename);
  web_server.send(200, "application/json", jsonStr);
}

void handleRestore() {
  HTTPUpload& upload = web_server.upload();
  
  if (upload.status == UPLOAD_FILE_START) {
    Serial.println("=== Starting config restore ===");
  } else if (upload.status == UPLOAD_FILE_WRITE) {
    // Parse JSON from uploaded file
    DynamicJsonDocument doc(1024);
    DeserializationError error = deserializeJson(doc, (char*)upload.buf);
    
    if (error) {
      Serial.println("Failed to parse config file");
      return;
    }
    
    // Restore WiFi settings
    if (doc.containsKey("wifi_ssid")) {
      preferences.putString("wifi_ssid", doc["wifi_ssid"].as<String>());
    }
    if (doc.containsKey("wifi_password")) {
      preferences.putString("wifi_password", doc["wifi_password"].as<String>());
    }
    
    // Restore MQTT settings
    if (doc.containsKey("mqtt_broker")) {
      preferences.putString("mqtt_broker", doc["mqtt_broker"].as<String>());
    }
    if (doc.containsKey("mqtt_port")) {
      preferences.putInt("mqtt_port", doc["mqtt_port"].as<int>());
    }
    if (doc.containsKey("mqtt_client_id")) {
      preferences.putString("mqtt_client_id", doc["mqtt_client_id"].as<String>());
    }
    if (doc.containsKey("mqtt_channel_name")) {
      preferences.putString("mqtt_channel_name", doc["mqtt_channel_name"].as<String>());
    }
    if (doc.containsKey("mqtt_topic_prefix")) {
      preferences.putString("mqtt_topic_prefix", doc["mqtt_topic_prefix"].as<String>());
    }
    
    // Restore device settings (labels, IDs, and pins)
    if (doc.containsKey("device_settings")) {
      JsonObject device_settings = doc["device_settings"];
      
      // Restore sensor settings
      for (int i = 1; i <= 4; i++) {
        String sensor_key = "sensor_" + String(i);
        if (device_settings.containsKey(sensor_key)) {
          JsonObject sensor = device_settings[sensor_key];
          if (sensor.containsKey("label")) preferences.putString(("sensor_" + String(i) + "_label").c_str(), sensor["label"].as<String>());
          if (sensor.containsKey("id")) preferences.putString(("sensor_" + String(i) + "_id").c_str(), sensor["id"].as<String>());
          if (sensor.containsKey("pin")) preferences.putString(("sensor_" + String(i) + "_pin").c_str(), sensor["pin"].as<String>());
          if (sensor.containsKey("type")) preferences.putString(("sensor_" + String(i) + "_type").c_str(), sensor["type"].as<String>());
        }
      }
      
      // Restore turnout settings
      for (int i = 1; i <= 2; i++) {
        String turnout_key = "turnout_" + String(i);
        if (device_settings.containsKey(turnout_key)) {
          JsonObject turnout = device_settings[turnout_key];
          if (turnout.containsKey("label")) preferences.putString(("turnout_" + String(i) + "_label").c_str(), turnout["label"].as<String>());
          if (turnout.containsKey("id")) preferences.putString(("turnout_" + String(i) + "_id").c_str(), turnout["id"].as<String>());
          if (turnout.containsKey("pin")) preferences.putString(("turnout_" + String(i) + "_pin").c_str(), turnout["pin"].as<String>());
          if (turnout.containsKey("type")) preferences.putString(("turnout_" + String(i) + "_type").c_str(), turnout["type"].as<String>());
        }
      }
      
      // Restore light settings
      for (int i = 1; i <= 6; i++) {
        String light_key = "light_" + String(i);
        if (device_settings.containsKey(light_key)) {
          JsonObject light = device_settings[light_key];
          if (light.containsKey("label")) preferences.putString(("light_" + String(i) + "_label").c_str(), light["label"].as<String>());
          if (light.containsKey("id")) preferences.putString(("light_" + String(i) + "_id").c_str(), light["id"].as<String>());
          if (light.containsKey("pin")) preferences.putString(("light_" + String(i) + "_pin").c_str(), light["pin"].as<String>());
          if (light.containsKey("type")) preferences.putString(("light_" + String(i) + "_type").c_str(), light["type"].as<String>());
        }
      }
    }
    
    // Restore pin-based settings if available
    if (doc.containsKey("pin_settings")) {
      JsonObject pin_settings = doc["pin_settings"];
      Serial.println("Restoring pin-based settings...");
      
      for (JsonPair pin : pin_settings) {
        String pinKey = pin.key().c_str();
        JsonObject pinData = pin.value();
        
        if (pinKey.startsWith("pin_")) {
          String pinNumStr = pinKey.substring(4);
          int pinNum = pinNumStr.toInt();
          
          if (pinNum > 0) {
            Serial.println("Restoring pin " + String(pinNum));
            
            if (pinData.containsKey("type")) {
              preferences.putString(("pin_" + String(pinNum) + "_type").c_str(), pinData["type"].as<String>());
              Serial.println("  Type: " + pinData["type"].as<String>());
            }
            if (pinData.containsKey("label")) {
              preferences.putString(("pin_" + String(pinNum) + "_label").c_str(), pinData["label"].as<String>());
              Serial.println("  Label: " + pinData["label"].as<String>());
            }
            if (pinData.containsKey("id")) {
              preferences.putString(("pin_" + String(pinNum) + "_id").c_str(), pinData["id"].as<String>());
              Serial.println("  ID: " + pinData["id"].as<String>());
            }
          }
        }
      }
    }
    
    // Legacy support: also check for old device_labels format
    if (doc.containsKey("device_labels")) {
      JsonObject device_labels = doc["device_labels"];
      
      // Restore sensor labels
      if (device_labels.containsKey("sensor_1")) preferences.putString("sensor_label_1", device_labels["sensor_1"].as<String>());
      if (device_labels.containsKey("sensor_2")) preferences.putString("sensor_label_2", device_labels["sensor_2"].as<String>());
      if (device_labels.containsKey("sensor_3")) preferences.putString("sensor_label_3", device_labels["sensor_3"].as<String>());
      if (device_labels.containsKey("sensor_4")) preferences.putString("sensor_label_4", device_labels["sensor_4"].as<String>());
      
      // Restore turnout labels
      if (device_labels.containsKey("turnout_1")) preferences.putString("turnout_label_1", device_labels["turnout_1"].as<String>());
      if (device_labels.containsKey("turnout_2")) preferences.putString("turnout_label_2", device_labels["turnout_2"].as<String>());
      
      // Restore light labels
      if (device_labels.containsKey("light_1")) preferences.putString("light_label_1", device_labels["light_1"].as<String>());
      if (device_labels.containsKey("light_2")) preferences.putString("light_label_2", device_labels["light_2"].as<String>());
      if (device_labels.containsKey("light_3")) preferences.putString("light_label_3", device_labels["light_3"].as<String>());
      if (device_labels.containsKey("light_4")) preferences.putString("light_label_4", device_labels["light_4"].as<String>());
      if (device_labels.containsKey("light_5")) preferences.putString("light_label_5", device_labels["light_5"].as<String>());
      if (device_labels.containsKey("light_6")) preferences.putString("light_label_6", device_labels["light_6"].as<String>());
    }
    
    // After restoring all settings, rebuild the device-type mappings for MQTT compatibility
    Serial.println("Rebuilding device-type mappings for MQTT compatibility...");
    rebuildDeviceTypeMappings();
    
    // Reload MQTT configuration to use the restored device IDs
    Serial.println("Reloading MQTT configuration with restored device IDs...");
    loadMQTTCredentials();
    
  } else if (upload.status == UPLOAD_FILE_END) {
    Serial.println("Config restore complete");
    web_server.send(200, "text/plain", "Configuration restored. Device will restart...");
    delay(1000);
    ESP.restart();
  }
}

void handleSaveDeviceLabels() {
  if (web_server.hasArg("device_labels")) {
    String labelsJson = web_server.arg("device_labels");
    DynamicJsonDocument doc(1024);
    DeserializationError error = deserializeJson(doc, labelsJson);

    if (error) {
      Serial.println("Failed to parse device labels JSON");
      web_server.send(400, "text/plain", "Invalid device labels JSON");
      return;
    }

    // Save to preferences
    JsonObject device_labels = doc["device_labels"];
    if (device_labels.containsKey("sensor_1")) preferences.putString("sensor_label_1", device_labels["sensor_1"].as<String>());
    if (device_labels.containsKey("sensor_2")) preferences.putString("sensor_label_2", device_labels["sensor_2"].as<String>());
    if (device_labels.containsKey("sensor_3")) preferences.putString("sensor_label_3", device_labels["sensor_3"].as<String>());
    if (device_labels.containsKey("sensor_4")) preferences.putString("sensor_label_4", device_labels["sensor_4"].as<String>());
    if (device_labels.containsKey("turnout_1")) preferences.putString("turnout_label_1", device_labels["turnout_1"].as<String>());
    if (device_labels.containsKey("turnout_2")) preferences.putString("turnout_label_2", device_labels["turnout_2"].as<String>());
    if (device_labels.containsKey("light_1")) preferences.putString("light_label_1", device_labels["light_1"].as<String>());
    if (device_labels.containsKey("light_2")) preferences.putString("light_label_2", device_labels["light_2"].as<String>());
    if (device_labels.containsKey("light_3")) preferences.putString("light_label_3", device_labels["light_3"].as<String>());
    if (device_labels.containsKey("light_4")) preferences.putString("light_label_4", device_labels["light_4"].as<String>());
    if (device_labels.containsKey("light_5")) preferences.putString("light_label_5", device_labels["light_5"].as<String>());
    if (device_labels.containsKey("light_6")) preferences.putString("light_label_6", device_labels["light_6"].as<String>());

    Serial.println("Device labels saved successfully.");
    web_server.send(200, "text/plain", "Device labels saved successfully.");
  } else {
    web_server.send(400, "text/plain", "Missing device_labels argument");
  }
}

void startMDNS() {
  Serial.println("=== Starting mDNS ===");
  
  // Stop any existing mDNS service
  MDNS.end();
  delay(100);
  
  // Get the actual saved client ID for mDNS hostname
  String savedClientId = preferences.getString("mqtt_client_id", "");
  String hostname;
  
  if (savedClientId.length() > 0) {
    // Use the saved client ID as the hostname
    hostname = savedClientId;
    Serial.println("Using saved client ID as hostname: " + hostname);
  } else {
    // Fallback to generated hostname if no saved client ID
    hostname = getUniqueHostname();
    Serial.println("No saved client ID, using generated hostname: " + hostname);
  }
  
  Serial.println("Attempting to start mDNS with hostname: " + hostname);
  
  // Validate hostname
  if (hostname.length() > 63) {
    Serial.println("‚ùå Error: Hostname too long (max 63 characters)");
    return;
  }
  
  if (hostname.length() == 0) {
    Serial.println("‚ùå Error: Empty hostname");
    return;
  }
  
  Serial.println("Hostname validation passed");
  
  // Start mDNS service
  if (!MDNS.begin(hostname.c_str())) {
    Serial.println("‚ùå Error setting up mDNS responder");
    Serial.println("This may prevent hostname resolution");
    Serial.println("Common causes:");
    Serial.println("  - Hostname contains invalid characters");
    Serial.println("  - mDNS service already running");
    Serial.println("  - WiFi not fully connected");
  } else {
    Serial.println("‚úÖ mDNS responder started successfully");
    Serial.println("Hostname: " + hostname + ".local");
    Serial.println("You can now access this device at: http://" + hostname + ".local");
    
    // Add service announcements
    MDNS.addService("http", "tcp", 80);
    MDNS.addService("arduino", "tcp", 3232);
    Serial.println("HTTP and OTA services announced via mDNS");
    
    // Give mDNS time to initialize
    delay(500);
    Serial.println("mDNS initialization complete");
  }
  Serial.println("===============================");
}

// Helper functions to get pin numbers
String getSensorPin(int sensorNum) {
  switch(sensorNum) {
    case 1: return String(SENSOR_PIN_1);
    case 2: return String(SENSOR_PIN_2);
    case 3: return String(SENSOR_PIN_3);
    case 4: return String(SENSOR_PIN_4);
    default: return "N/A";
  }
}

String getTurnoutPin(int turnoutNum) {
  switch(turnoutNum) {
    case 1: return String(TURNOUT_PIN_1);
    case 2: return String(TURNOUT_PIN_2);
    default: return "N/A";
  }
}

String getLightPin(int lightNum) {
  switch(lightNum) {
    case 1: return String(LIGHT_PIN_1);
    case 2: return String(LIGHT_PIN_2);
    case 3: return String(LIGHT_PIN_3);
    case 4: return String(LIGHT_PIN_4);
    case 5: return String(LIGHT_PIN_5);
    case 6: return String(LIGHT_PIN_6);
    default: return "N/A";
  }
}



void rebuildDeviceTypeMappings() {
  Serial.println("=== Rebuilding Device-Type Mappings ===");
  
  // Clear existing device-type mappings to avoid conflicts
  Serial.println("Clearing existing device-type mappings...");
  for (int i = 1; i <= 4; i++) {
    preferences.remove(("sensor_" + String(i) + "_id").c_str());
    preferences.remove(("sensor_" + String(i) + "_label").c_str());
    preferences.remove(("sensor_" + String(i) + "_pin").c_str());
    preferences.remove(("sensor_" + String(i) + "_type").c_str());
  }
  for (int i = 1; i <= 2; i++) {
    preferences.remove(("turnout_" + String(i) + "_id").c_str());
    preferences.remove(("turnout_" + String(i) + "_label").c_str());
    preferences.remove(("turnout_" + String(i) + "_pin").c_str());
    preferences.remove(("turnout_" + String(i) + "_type").c_str());
  }
  for (int i = 1; i <= 6; i++) {
    preferences.remove(("light_" + String(i) + "_id").c_str());
    preferences.remove(("light_" + String(i) + "_label").c_str());
    preferences.remove(("light_" + String(i) + "_pin").c_str());
    preferences.remove(("light_" + String(i) + "_type").c_str());
  }
  
  // Rebuild mappings from pin-based preferences
  int sensorCount = 0;
  int turnoutCount = 0;
  int lightCount = 0;
  
  int allPins[] = {13,14,18,19,21,22,23,25,26,27,32,33,34,35,36,39};
  
  for (int pinNum : allPins) {
    String deviceType = preferences.getString(("pin_" + String(pinNum) + "_type").c_str(), "unused");
    
    if (deviceType == "sensor" && sensorCount < 4) {
      sensorCount++;
      String deviceIdKey = "sensor_" + String(sensorCount) + "_id";
      String deviceLabelKey = "sensor_" + String(sensorCount) + "_label";
      String devicePinKey = "sensor_" + String(sensorCount) + "_pin";
      String deviceTypeKey = "sensor_" + String(sensorCount) + "_type";
      
      Serial.println("Rebuilding sensor " + String(sensorCount) + " from pin " + String(pinNum));
      
      String id = preferences.getString(("pin_" + String(pinNum) + "_id").c_str(), String(sensorCount));
      String label = preferences.getString(("pin_" + String(pinNum) + "_label").c_str(), "Sensor " + String(sensorCount));
      
      preferences.putString(deviceIdKey.c_str(), id);
      preferences.putString(deviceLabelKey.c_str(), label);
      preferences.putString(devicePinKey.c_str(), String(pinNum));
      preferences.putString(deviceTypeKey.c_str(), deviceType);
      
      Serial.println("  Mapped: " + deviceIdKey + " = " + id);
      
    } else if (deviceType == "turnout" && turnoutCount < 2) {
      turnoutCount++;
      String deviceIdKey = "turnout_" + String(turnoutCount) + "_id";
      String deviceLabelKey = "turnout_" + String(turnoutCount) + "_label";
      String devicePinKey = "turnout_" + String(turnoutCount) + "_pin";
      String deviceTypeKey = "turnout_" + String(turnoutCount) + "_type";
      
      Serial.println("Rebuilding turnout " + String(turnoutCount) + " from pin " + String(pinNum));
      
      String id = preferences.getString(("pin_" + String(pinNum) + "_id").c_str(), String(turnoutCount));
      String label = preferences.getString(("pin_" + String(pinNum) + "_label").c_str(), "Turnout " + String(turnoutCount));
      
      preferences.putString(deviceIdKey.c_str(), id);
      preferences.putString(deviceLabelKey.c_str(), label);
      preferences.putString(devicePinKey.c_str(), String(pinNum));
      preferences.putString(deviceTypeKey.c_str(), deviceType);
      
      Serial.println("  Mapped: " + deviceIdKey + " = " + id);
      
    } else if (deviceType == "light" && lightCount < 6) {
      lightCount++;
      String deviceIdKey = "light_" + String(lightCount) + "_id";
      String deviceLabelKey = "light_" + String(lightCount) + "_label";
      String devicePinKey = "light_" + String(lightCount) + "_pin";
      String deviceTypeKey = "light_" + String(lightCount) + "_type";
      
      Serial.println("Rebuilding light " + String(lightCount) + " from pin " + String(pinNum));
      
      String id = preferences.getString(("pin_" + String(pinNum) + "_id").c_str(), String(lightCount));
      String label = preferences.getString(("pin_" + String(pinNum) + "_label").c_str(), "Light " + String(lightCount));
      
      preferences.putString(deviceIdKey.c_str(), id);
      preferences.putString(deviceLabelKey.c_str(), label);
      preferences.putString(devicePinKey.c_str(), String(pinNum));
      preferences.putString(deviceTypeKey.c_str(), deviceType);
      
      Serial.println("  Mapped: " + deviceIdKey + " = " + id);
    }
  }
  
  Serial.println("=== Rebuild Complete ===");
  Serial.println("Sensors rebuilt: " + String(sensorCount));
  Serial.println("Turnouts rebuilt: " + String(turnoutCount));
  Serial.println("Lights rebuilt: " + String(lightCount));
}

void handleSaveDeviceSettings() {
  Serial.println("=== handleSaveDeviceSettings called ===");
  
  // For JSON data, we need to read the raw body
  String settingsJson = web_server.arg("plain");
  Serial.println("Raw body received: " + settingsJson);
  
  if (settingsJson.length() > 0) {
    
    DynamicJsonDocument doc(2048); // Increased size for more settings
    DeserializationError error = deserializeJson(doc, settingsJson);

    if (error) {
      Serial.println("Failed to parse device settings JSON: " + String(error.c_str()));
      web_server.send(400, "text/plain", "Invalid device settings JSON");
      return;
    }

    Serial.println("JSON parsed successfully");
    
    // Check if the JSON has the expected structure
    if (!doc.containsKey("device_settings")) {
      Serial.println("JSON does not contain 'device_settings' key");
      Serial.println("Available keys:");
      for (JsonPair kv : doc.as<JsonObject>()) {
        Serial.println("  " + String(kv.key().c_str()));
      }
      web_server.send(400, "text/plain", "JSON does not contain 'device_settings' key");
      return;
    }
    
    // Save to preferences
    JsonObject device_settings = doc["device_settings"];
    Serial.println("Device settings object found, processing...");
    
    // Clear existing device-type mappings to avoid conflicts
    Serial.println("Clearing existing device-type mappings...");
    // Clear more aggressively to handle device type changes
    for (int i = 1; i <= 10; i++) {
      preferences.remove(("sensor_" + String(i) + "_id").c_str());
      preferences.remove(("sensor_" + String(i) + "_label").c_str());
      preferences.remove(("sensor_" + String(i) + "_pin").c_str());
      preferences.remove(("sensor_" + String(i) + "_type").c_str());
    }
    for (int i = 1; i <= 10; i++) {
      preferences.remove(("turnout_" + String(i) + "_id").c_str());
      preferences.remove(("turnout_" + String(i) + "_label").c_str());
      preferences.remove(("turnout_" + String(i) + "_pin").c_str());
      preferences.remove(("turnout_" + String(i) + "_type").c_str());
    }
    for (int i = 1; i <= 10; i++) {
      preferences.remove(("light_" + String(i) + "_id").c_str());
      preferences.remove(("light_" + String(i) + "_label").c_str());
      preferences.remove(("light_" + String(i) + "_pin").c_str());
      preferences.remove(("light_" + String(i) + "_type").c_str());
    }
    
    // Process each device setting
    int deviceCount = 0;
    int sensorCount = 0;
    int turnoutCount = 0;
    int lightCount = 0;
    
    // First pass: count devices by type to allocate proper numbers
    Serial.println("=== First pass: Counting devices by type ===");
    for (JsonPair device : device_settings) {
      String deviceKey = device.key().c_str();
      JsonObject deviceData = device.value();
      
      if (deviceKey.startsWith("pin_")) {
        String deviceType = "unused";
        if (deviceData.containsKey("type")) {
          deviceType = deviceData["type"].as<String>();
        }
        
        if (deviceType == "sensor") {
          sensorCount++;
          Serial.println("  Found sensor #" + String(sensorCount) + " on " + deviceKey);
        } else if (deviceType == "turnout") {
          turnoutCount++;
          Serial.println("  Found turnout #" + String(turnoutCount) + " on " + deviceKey);
        } else if (deviceType == "light") {
          lightCount++;
          Serial.println("  Found light #" + String(lightCount) + " on " + deviceKey);
        }
      }
    }
    
    Serial.println("Device counts: " + String(sensorCount) + " sensors, " + String(turnoutCount) + " turnouts, " + String(lightCount) + " lights");
    
    // Reset counters for second pass
    sensorCount = 0;
    turnoutCount = 0;
    lightCount = 0;
    
    for (JsonPair device : device_settings) {
      deviceCount++;
      String deviceKey = device.key().c_str();
      JsonObject deviceData = device.value();
      
      Serial.println("Processing device " + String(deviceCount) + ": " + deviceKey);
      
      // Extract pin number from key (e.g., "pin_23", "pin_14")
      if (deviceKey.startsWith("pin_")) {
        String pinNumStr = deviceKey.substring(4); // Remove "pin_" prefix
        int pinNum = pinNumStr.toInt();
        
        if (pinNum > 0) {
          Serial.println("  Pin number: " + pinNum);
          
          // Get the device type from the data
          String deviceType = "unused";
          if (deviceData.containsKey("type")) {
            deviceType = deviceData["type"].as<String>();
          }
          
          Serial.println("  Device type: " + deviceType);
          
          // Add error checking - only skip if type is actually empty or "unused"
          if (deviceType.length() == 0 || deviceType == "unused") {
            Serial.println("  ERROR: Device type is empty or unused, skipping");
            continue;
          }
          
          // Save individual settings for this device
          if (deviceData.containsKey("label")) {
            String pinLabelKey = "pin_" + String(pinNum) + "_label";
            String value = deviceData["label"].as<String>();
            preferences.putString(pinLabelKey.c_str(), value);
            Serial.println("  Saved " + pinLabelKey + " = " + value);
          }
          
          if (deviceData.containsKey("id")) {
            String pinIdKey = "pin_" + String(pinNum) + "_id";
            String value = deviceData["id"].as<String>();
            preferences.putString(pinIdKey.c_str(), value);
            Serial.println("  Saved " + pinIdKey + " = " + value);
          }
          
          // Save pin type
          String pinTypeKey = "pin_" + String(pinNum) + "_type";
          preferences.putString(pinTypeKey.c_str(), deviceType);
          Serial.println("  Saved " + pinTypeKey + " = " + deviceType);
          
          // Now map pin settings to device-type settings for MQTT compatibility
          if (deviceType == "sensor") {
            sensorCount++;
            String deviceIdKey = "sensor_" + String(sensorCount) + "_id";
            String deviceLabelKey = "sensor_" + String(sensorCount) + "_label";
            String devicePinKey = "sensor_" + String(sensorCount) + "_pin";
            String deviceTypeKey = "sensor_" + String(sensorCount) + "_type";
            
            if (deviceData.containsKey("id")) {
              preferences.putString(deviceIdKey.c_str(), deviceData["id"].as<String>());
              Serial.println("  Mapped to " + deviceIdKey + " = " + deviceData["id"].as<String>());
            }
            if (deviceData.containsKey("label")) {
              preferences.putString(deviceLabelKey.c_str(), deviceData["label"].as<String>());
              Serial.println("  Mapped to " + deviceLabelKey + " = " + deviceData["label"].as<String>());
            }
            preferences.putString(devicePinKey.c_str(), String(pinNum));
            Serial.println("  Mapped to " + devicePinKey + " = " + String(pinNum));
            preferences.putString(deviceTypeKey.c_str(), deviceType);
            Serial.println("  Mapped to " + deviceTypeKey + " = " + deviceType);
            
          } else if (deviceType == "turnout") {
            turnoutCount++;
            String deviceIdKey = "turnout_" + String(turnoutCount) + "_id";
            String deviceLabelKey = "turnout_" + String(turnoutCount) + "_label";
            String devicePinKey = "turnout_" + String(turnoutCount) + "_pin";
            String deviceTypeKey = "turnout_" + String(turnoutCount) + "_type";
            
            if (deviceData.containsKey("id")) {
              preferences.putString(deviceIdKey.c_str(), deviceData["id"].as<String>());
              Serial.println("  Mapped to " + deviceIdKey + " = " + deviceData["id"].as<String>());
            }
            if (deviceData.containsKey("label")) {
              preferences.putString(deviceLabelKey.c_str(), deviceData["label"].as<String>());
              Serial.println("  Mapped to " + deviceLabelKey + " = " + deviceData["label"].as<String>());
            }
            preferences.putString(devicePinKey.c_str(), String(pinNum));
            Serial.println("  Mapped to " + devicePinKey + " = " + String(pinNum));
            preferences.putString(deviceTypeKey.c_str(), deviceType);
            Serial.println("  Mapped to " + deviceTypeKey + " = " + deviceType);
            
          } else if (deviceType == "light") {
            lightCount++;
            String deviceIdKey = "light_" + String(lightCount) + "_id";
            String deviceLabelKey = "light_" + String(lightCount) + "_label";
            String devicePinKey = "light_" + String(lightCount) + "_pin";
            String deviceTypeKey = "light_" + String(lightCount) + "_type";
            
            if (deviceData.containsKey("id")) {
              preferences.putString(deviceIdKey.c_str(), deviceData["id"].as<String>());
              Serial.println("  Mapped to " + deviceIdKey + " = " + deviceData["id"].as<String>());
            }
            if (deviceData.containsKey("label")) {
              preferences.putString(deviceLabelKey.c_str(), deviceData["label"].as<String>());
              Serial.println("  Mapped to " + deviceLabelKey + " = " + deviceData["label"].as<String>());
            }
            preferences.putString(devicePinKey.c_str(), String(pinNum));
            Serial.println("  Mapped to " + devicePinKey + " = " + String(pinNum));
            preferences.putString(deviceTypeKey.c_str(), deviceType);
            Serial.println("  Mapped to " + deviceTypeKey + " = " + deviceType);
            
          } else if (deviceType != "unused") {
            Serial.println("  WARNING: Device type '" + deviceType + "' not supported or limit reached");
          }
        }
      }
    }

    Serial.println("=== Processing complete ===");
    Serial.println("Total devices processed: " + String(deviceCount));
    Serial.println("Sensors mapped: " + String(sensorCount));
    Serial.println("Turnouts mapped: " + String(turnoutCount));
    Serial.println("Lights mapped: " + String(lightCount));
    Serial.println("Total devices in JSON: " + String(device_settings.size()));
    Serial.println("Free heap memory: " + String(ESP.getFreeHeap()) + " bytes");
    
    // Verify the device-type mappings were actually saved
    Serial.println("=== Verifying Device-Type Mappings ===");
    Serial.println("Sensors:");
    for (int i = 1; i <= sensorCount; i++) {
      String id = preferences.getString(("sensor_" + String(i) + "_id").c_str(), "NOT_FOUND");
      String label = preferences.getString(("sensor_" + String(i) + "_label").c_str(), "NOT_FOUND");
      String pin = preferences.getString(("sensor_" + String(i) + "_pin").c_str(), "NOT_FOUND");
      Serial.println("  Sensor " + String(i) + ": ID=" + id + ", Label=" + label + ", Pin=" + pin);
    }
    
    Serial.println("Turnouts:");
    for (int i = 1; i <= turnoutCount; i++) {
      String id = preferences.getString(("turnout_" + String(i) + "_id").c_str(), "NOT_FOUND");
      String label = preferences.getString(("turnout_" + String(i) + "_label").c_str(), "NOT_FOUND");
      String pin = preferences.getString(("turnout_" + String(i) + "_pin").c_str(), "NOT_FOUND");
      Serial.println("  Turnout " + String(i) + ": ID=" + id + ", Label=" + label + ", Pin=" + pin);
    }
    
    Serial.println("Lights:");
    for (int i = 1; i <= lightCount; i++) {
      String id = preferences.getString(("light_" + String(i) + "_id").c_str(), "NOT_FOUND");
      String label = preferences.getString(("light_" + String(i) + "_label").c_str(), "NOT_FOUND");
      String pin = preferences.getString(("light_" + String(i) + "_pin").c_str(), "NOT_FOUND");
      Serial.println("  Light " + String(i) + ": ID=" + id + ", Label=" + label + ", Pin=" + pin);
    }

    // Verify what was saved
    Serial.println("=== Verifying saved settings ===");
    for (JsonPair device : device_settings) {
      String deviceKey = device.key().c_str();
      JsonObject deviceData = device.value();
      
      if (deviceKey.startsWith("pin_")) {
        String pinNumStr = deviceKey.substring(4);
        int pinNum = pinNumStr.toInt();
        
        if (pinNum > 0) {
          Serial.println("Verifying pin: " + deviceKey);
          
          String pinTypeKey = "pin_" + String(pinNum) + "_type";
          String savedType = preferences.getString(pinTypeKey.c_str(), "NOT_FOUND");
          Serial.println("  " + pinTypeKey + ": " + savedType);
          
          String pinLabelKey = "pin_" + String(pinNum) + "_label";
          String savedLabel = preferences.getString(pinLabelKey.c_str(), "NOT_FOUND");
          Serial.println("  " + pinLabelKey + ": " + savedLabel);
          
          String pinIdKey = "pin_" + String(pinNum) + "_id";
          String savedId = preferences.getString(pinIdKey.c_str(), "NOT_FOUND");
          Serial.println("  " + pinIdKey + ": " + savedId);
        }
      }
    }

    Serial.println("Device settings saved successfully.");
    
    // Commit preferences to flash memory
    Serial.println("Committing preferences to flash memory...");
    preferences.end();
    preferences.begin("jmri_client", false);
    Serial.println("Preferences committed successfully to flash");
    
    // Reload MQTT credentials to update topic strings with new device IDs
    Serial.println("Reloading MQTT configuration to update topic strings...");
    loadMQTTCredentials();
    
    // If MQTT is connected, resubscribe to topics with new device IDs
    if (mqtt_connected) {
      Serial.println("Resubscribing to MQTT topics with new device IDs...");
      mqtt_client.disconnect();
      delay(1000);
      mqttReconnect();
    }
    
    web_server.send(200, "text/plain", "Device settings saved successfully. MQTT topics updated.");
  } else {
    Serial.println("No JSON data found in request body");
    web_server.send(400, "text/plain", "No JSON data found in request body");
  }
  
  Serial.println("=== handleSaveDeviceSettings end ===");
}
